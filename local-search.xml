<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AOP</title>
    <link href="/2021/11/19/AOP/"/>
    <url>/2021/11/19/AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>面向切面编程，增强对象</p><p><strong>Advice通知：</strong>定义连接点，提供增强接口</p><ul><li>BeforeAdvice</li><li>AfterAdvice</li><li>ThrowAdvice</li></ul><p><strong>BeforeAdvice</strong></p><p>    提供前置增强接口，需要设置回调函数</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">MethodBeforeAdvice</span> <span class="hljs-selector-tag">extends</span> <span class="hljs-selector-tag">BeforeAdvice</span> &#123;<br><br>   <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">before</span>(Method method, Object[] args, <span class="hljs-variable">@Nullable</span> Object target) <span class="hljs-selector-tag">throws</span> <span class="hljs-selector-tag">Throwable</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>method目标的反射对象，args参数</p><p><strong>AfterAdvice</strong></p><p>    提供后置增强接口，需要设置回调函数</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">AfterReturningAdvice</span> <span class="hljs-selector-tag">extends</span> <span class="hljs-selector-tag">AfterAdvice</span> &#123;<br><br>   <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">afterReturning</span>(<span class="hljs-variable">@Nullable</span> Object returnValue, Method method, Object[] args, <span class="hljs-variable">@Nullable</span> Object target) <span class="hljs-selector-tag">throws</span> <span class="hljs-selector-tag">Throwable</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC控制反转</title>
    <link href="/2021/11/19/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    <url>/2021/11/19/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h1><p>Dependency Inversion Principle，依赖倒置原理</p><p>对象之间的依赖通过容器来管理，并由容器完成注入</p><p><strong>BeanFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br><br>   <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>   &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>   <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>   &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>   &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br><br>   <span class="hljs-meta">@Nullable</span><br>   Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>   String[] getAliases(String name);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>containsBean方法，判断容器中是否含有指定名称的Bean</p><p>isSingleton方法，判断容器中是否含有指定名称的Singleton类型的Bean</p><p>isPrototype方法，判断容器中是否含有指定名称的Prototype类型的Bean</p><p>isTypeMatch方法，判断容器中是否含有指定名称和类型的Bean</p><p>通过getBean获取容器中的Bean</p><p><strong>XmlBeanFactory</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultListableBeanFactory</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">XmlBeanDefinitionReader</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-type">XmlBeanDefinitionReader</span>(<span class="hljs-keyword">this</span>);<br><br>   public <span class="hljs-type">XmlBeanFactory</span>(<span class="hljs-type">Resource</span> resource) <span class="hljs-keyword">throws</span> <span class="hljs-type">BeansException</span> &#123;<br>      <span class="hljs-keyword">this</span>(resource, <span class="hljs-literal">null</span>);<br>   &#125;<br><br>   public <span class="hljs-type">XmlBeanFactory</span>(<span class="hljs-type">Resource</span> resource, <span class="hljs-type">BeanFactory</span> parentBeanFactory) <span class="hljs-keyword">throws</span> <span class="hljs-type">BeansException</span> &#123;<br>      <span class="hljs-keyword">super</span>(parentBeanFactory);<br>      <span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(resource);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>XmlBeanDefinitionReader提供读取XML的功能，是对DefaultListableBeanFactory的增强</p><p>构造方法中需要传入Resource的类，Resource类是Spring封装IO的类</p><p><strong>Resource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Resource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputStreamSource</span> </span>&#123;<br><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">exists</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReadable</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFile</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>   &#125;<br><br>   <span class="hljs-function">URL <span class="hljs-title">getURL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>   <span class="hljs-function">URI <span class="hljs-title">getURI</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>   <span class="hljs-function">File <span class="hljs-title">getFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">default</span> ReadableByteChannel <span class="hljs-title">readableChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-keyword">return</span> Channels.newChannel(getInputStream());<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">contentLength</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">lastModified</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>   <span class="hljs-function">Resource <span class="hljs-title">createRelative</span><span class="hljs-params">(String relativePath)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-function">String <span class="hljs-title">getFilename</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-function">String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>ClassPathResource是AbstractResource的子类，AbstractResource实现了Resource接口</p><p><strong>从XML创建Bean</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">//从XML读取Bean并创建</span><br>ClassPathResource res = new ClassPathResource (<span class="hljs-string">&quot;beans.xml”);</span><br>DefaultListableBeanFactory factory=new DefaultListableBeanFactory();<br>XmlBeanDefinitionReader reader=new XmlBeanDefinitionReader(factory);<br>reader.loadBeanDefinitions(res); <br></code></pre></td></tr></table></figure><p><strong>ApplicationContext</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EnvironmentCapable</span>, <span class="hljs-title">ListableBeanFactory</span>, <span class="hljs-title">HierarchicalBeanFactory</span>,</span><br><span class="hljs-class">      <span class="hljs-title">MessageSource</span>, <span class="hljs-title">ApplicationEventPublisher</span>, <span class="hljs-title">ResourcePatternResolver</span> </span>&#123;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-function">String <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-function">String <span class="hljs-title">getApplicationName</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-function">String <span class="hljs-title">getDisplayName</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getStartupDate</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-function">ApplicationContext <span class="hljs-title">getParent</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-function">AutowireCapableBeanFactory <span class="hljs-title">getAutowireCapableBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MessageSource 处理消息</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">MessageSource</span> &#123;<br><br>   <span class="hljs-variable">@Nullable</span><br>   String getMessage(String code, <span class="hljs-variable">@Nullable</span> Object[] args, <span class="hljs-variable">@Nullable</span> String defaultMessage, Locale locale);<br><br>   <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">getMessage</span>(String code, <span class="hljs-variable">@Nullable</span> Object[] args, Locale locale) <span class="hljs-selector-tag">throws</span> <span class="hljs-selector-tag">NoSuchMessageException</span>;<br><br>   <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">getMessage</span>(MessageSourceResolvable resolvable, Locale locale) <span class="hljs-selector-tag">throws</span> <span class="hljs-selector-tag">NoSuchMessageException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ResourcePatternResolver 提供资源访问服务</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResourcePatternResolver</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">ResourceLoader</span></span> </span>&#123;<br>   <span class="hljs-keyword">String</span> CLASSPATH_ALL_URL_PREFIX = <span class="hljs-string">&quot;classpath*:&quot;</span>;<br><br>   Resource[] getResources(<span class="hljs-keyword">String</span> locationPattern) throws IOException;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ApplicationEventPublisher 提供事件服务</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationEventPublisher</span> &#123;<br><br>   <span class="hljs-function"><span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishEvent</span>(<span class="hljs-params">ApplicationEvent <span class="hljs-keyword">event</span></span>)</span> &#123;<br>      publishEvent((Object) <span class="hljs-keyword">event</span>);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">publishEvent</span>(<span class="hljs-params">Object <span class="hljs-keyword">event</span></span>)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BeanDefinition加载Bean到容器</strong></p><p>通过在容器内部维护一个HashMap</p><p><strong>DefaultListableBeanFactory</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAutowireCapableBeanFactory</span></span><br>      implements <span class="hljs-type">ConfigurableListableBeanFactory</span>, <span class="hljs-type">BeanDefinitionRegistry</span>, <span class="hljs-type">Serializable</span> &#123;<br><span class="hljs-comment">//省略其他方法</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>FileSystemXmlApplicationContext 载入入口refresh</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">FileSystemXmlApplicationContext</span> <span class="hljs-selector-tag">extends</span> <span class="hljs-selector-tag">AbstractXmlApplicationContext</span> &#123;<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">FileSystemXmlApplicationContext</span>(<br>          String[] configLocations, boolean refresh, <span class="hljs-variable">@Nullable</span>     ApplicationContext parent)<br>          <span class="hljs-selector-tag">throws</span> <span class="hljs-selector-tag">BeansException</span> &#123;<br><br>       <span class="hljs-selector-tag">super</span>(parent);<br>       <span class="hljs-selector-tag">setConfigLocations</span>(configLocations);<br>       <span class="hljs-selector-tag">if</span> (refresh) &#123;<br>          <span class="hljs-selector-tag">refresh</span>();<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>AbstractApplicationContext 实现refresh方法，使用了同步锁</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public abstract <span class="hljs-keyword">class</span> AbstractApplicationContext extends DefaultResourceLoader<br>      implements ConfigurableApplicationContext &#123;<br>   @Override<br>   public void refresh<span class="hljs-literal">()</span> throws BeansException, IllegalStateException &#123;<br>      synchronized (this.startupShutdownMonitor) &#123;<br>         <span class="hljs-comment">// Prepare this context for refreshing.</span><br>         prepare<span class="hljs-constructor">Refresh()</span>;<br>         ConfigurableListableBeanFactory beanFactory = obtain<span class="hljs-constructor">FreshBeanFactory()</span>;<br>         prepare<span class="hljs-constructor">BeanFactory(<span class="hljs-params">beanFactory</span>)</span>;<br>         <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br>            post<span class="hljs-constructor">ProcessBeanFactory(<span class="hljs-params">beanFactory</span>)</span>;<br>            invoke<span class="hljs-constructor">BeanFactoryPostProcessors(<span class="hljs-params">beanFactory</span>)</span>;<br>            register<span class="hljs-constructor">BeanPostProcessors(<span class="hljs-params">beanFactory</span>)</span>;<br>            init<span class="hljs-constructor">MessageSource()</span>;<br><br>            init<span class="hljs-constructor">ApplicationEventMulticaster()</span>;<br>            on<span class="hljs-constructor">Refresh()</span>;<br>            register<span class="hljs-constructor">Listeners()</span>;<br>            finish<span class="hljs-constructor">BeanFactoryInitialization(<span class="hljs-params">beanFactory</span>)</span>;<br>            finish<span class="hljs-constructor">Refresh()</span>;<br>         &#125; catch (BeansException ex) &#123;<br>            <span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">WarnEnabled()</span>) &#123;<br>               logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +<br>                     <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);<br>            &#125;<br><br>            destroy<span class="hljs-constructor">Beans()</span>;<br>            cancel<span class="hljs-constructor">Refresh(<span class="hljs-params">ex</span>)</span>;<br>            throw ex;<br>         &#125;finally &#123;<br>            reset<span class="hljs-constructor">CommonCaches()</span>;<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>AbstractRefreshableApplicationContext</strong></p><p>如果容器启动还有容器就干掉</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractRefreshableApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractApplicationContext</span> </span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> void refreshBeanFactory() <span class="hljs-keyword">throws</span> <span class="hljs-type">BeansException</span> &#123;<br>      <span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;<br>         destroyBeans();<br>         closeBeanFactory();<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">DefaultListableBeanFactory</span> beanFactory = createBeanFactory();<br>         beanFactory.setSerializationId(getId());<br>         customizeBeanFactory(beanFactory);<br>         loadBeanDefinitions(beanFactory);<br>         synchronized (<span class="hljs-keyword">this</span>.beanFactoryMonitor) &#123;<br>            <span class="hljs-keyword">this</span>.beanFactory = beanFactory;<br>         &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">IOException</span> ex) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ApplicationContextException</span>(<span class="hljs-string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);<br>      &#125;<br>   &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Integer与int比较的坑</title>
    <link href="/2021/11/19/Intger%E5%92%8Cint%E6%AF%94%E8%BE%83%E7%9A%84%E5%9D%91/"/>
    <url>/2021/11/19/Intger%E5%92%8Cint%E6%AF%94%E8%BE%83%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Integer和int比较的坑"><a href="#Integer和int比较的坑" class="headerlink" title="Integer和int比较的坑"></a>Integer和int比较的坑</h1><p>Integer k</p><p>如果k的值在[-128,127]的区间中可以直接用==，因为其IntegerCache产生，可以直接用==来比较</p><p>其他区间的时候，都会在堆上产生，必须要equls比较</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">Integer</span> valueOf(<span class="hljs-keyword">int</span> i) &#123;<br><br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br><br>      <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">Integer</span>(i);<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br><br>    <span class="hljs-built_in">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br><br>    <span class="hljs-built_in">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br><br>    <span class="hljs-built_in">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">Integer</span> cache[];<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO模型</title>
    <link href="/2021/11/19/IO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/11/19/IO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>首先要区分几个概念，同步，异步，阻塞，非阻塞</p><p>同步：主动去轮询查看结果</p><p>异步：不需要主动获取状态，目标对象会主动推送</p><p>阻塞：任务执行过程中不可以做其他事情</p><p>非阻塞：执行过程中可以做其他事情，然后得到通知后继续执行</p><p>1.BIO同步阻塞IO模型</p><p>    每个请求，分配一个线程处理，等到全部处理完成后结束线程</p><p>2.NIO同步非阻塞IO模型</p><p>    多路复用技术，多个请求，分配到一个线程，简历通信套接字后，继续处理其他请求</p><p>3.异步非阻塞IO模型</p><p>    </p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络传输</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Bean</title>
    <link href="/2021/11/19/Spring_Bean/"/>
    <url>/2021/11/19/Spring_Bean/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><p><strong>1.Bean的定义</strong></p><p>Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata configures these beans as &lt;bean/&gt; elements inside a top-level &lt;beans/&gt; element. Java configuration typically uses @Bean-annotated methods within a @Configuration class</p><p>These bean definitions correspond to the actual objects that make up your application. Typically, you define service layer objects, data access objects (DAOs), presentation objects such as Struts Action instances, infrastructure objects such as Hibernate SessionFactories, JMS Queues, and so forth. Typically, one does not configure fine-grained domain objects in the container, because it is usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring’s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-atconfigurable">Using AspectJ to dependency-inject domain objects with Spring</a>.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8”?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd”&gt; </span></span><br><span class="hljs-string"><span class="hljs-tag">   &lt;bean id=&quot;</span><span class="hljs-attr">petStore</span>&quot; <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl”&gt; </span></span><br><span class="hljs-string"><span class="hljs-tag">        &lt;property name=&quot;</span><span class="hljs-attr">accountDao</span>&quot; <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;accountDao&quot;</span>/&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;itemDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;itemDao&quot;</span>/&gt;</span> <br>        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span> <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br>id标识bean<br>class指定定义的java类<br></code></pre></td></tr></table></figure><p>2.ApplicationContext</p><p>    The ApplicationContext is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies. By using the method T getBean(String name, Class&lt;T&gt; requiredType), you can retrieve instances of your beans.</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代理</title>
    <link href="/2021/11/19/Java%E4%BB%A3%E7%90%86/"/>
    <url>/2021/11/19/Java%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java代理"><a href="#Java代理" class="headerlink" title="Java代理"></a>Java代理</h1><p>为其他对象提供一种代理控制这个对象的访问，创建具有现有对象的对象，提供对外接口</p><p>1.静态代理</p><p>    意义：不修改原有对象情况下，对功能可以扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Image</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Image</span></span>&#123;<br>    RealImage realImage;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProxyImage</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        realImage=<span class="hljs-keyword">new</span> RealImage();<br>        realImage.display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Image</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RealImage</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>     缺点：如果增加对象的方法，代理类也要变更</p><p>2.动态代理,JDK代理</p><p>    优点：不需要实现接口，不需要根据对象方法增加，修改代理类</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static Object <span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(ClassLoader <span class="hljs-params">loader</span>,Class&lt;?&gt;[] <span class="hljs-params">interfaces</span>,InvocationHandler <span class="hljs-params">h</span>)</span>throws IllegalArgumentException&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>require<span class="hljs-constructor">NonNull(<span class="hljs-params">h</span>)</span>;<br><br>    final Class&lt;?&gt;<span class="hljs-literal">[]</span> intfs = interfaces.clone<span class="hljs-literal">()</span>;<br>    final SecurityManager sm = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">SecurityManager()</span>;<br>    <span class="hljs-keyword">if</span> (sm != null) &#123;<br>        check<span class="hljs-constructor">ProxyAccess(Reflection.<span class="hljs-params">getCallerClass</span>()</span>, loader, intfs);<br>    &#125;<br>    <br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Look up or generate the designated proxy class.</span><br><span class="hljs-comment">     */</span><br>    Class&lt;?&gt; cl = get<span class="hljs-constructor">ProxyClass0(<span class="hljs-params">loader</span>, <span class="hljs-params">intfs</span>)</span>;<br>    <br>    <br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Invoke its constructor with the designated invocation handler.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (sm != null) &#123;<br>            check<span class="hljs-constructor">NewProxyPermission(Reflection.<span class="hljs-params">getCallerClass</span>()</span>, cl);<br>        &#125;<br><br>        final Constructor&lt;?&gt; cons = cl.get<span class="hljs-constructor">Constructor(<span class="hljs-params">constructorParams</span>)</span>;<br>        final InvocationHandler ih = h;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Public(<span class="hljs-params">cl</span>.<span class="hljs-params">getModifiers</span>()</span>)) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AccessController</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Privileged(<span class="hljs-params">new</span> PrivilegedAction&lt;Void&gt;()</span> &#123;<br>                public Void run<span class="hljs-literal">()</span> &#123;<br>                    cons.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;    <br>                    return null;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        return cons.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance(<span class="hljs-params">new</span> Object[]&#123;<span class="hljs-params">h</span>&#125;)</span>;<br>    &#125; catch (IllegalAccessException<span class="hljs-pattern-match">|<span class="hljs-constructor">InstantiationException</span> e) &#123;</span><br><span class="hljs-pattern-match">        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">InternalError(<span class="hljs-params">e</span>.<span class="hljs-params">toString</span>()</span>, e);</span><br><span class="hljs-pattern-match">    &#125; catch (<span class="hljs-constructor">InvocationTargetException</span> e) &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-constructor">Throwable</span> t = e.get<span class="hljs-constructor">Cause()</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (t instanceof <span class="hljs-constructor">RuntimeException</span>) &#123;</span><br><span class="hljs-pattern-match">            throw (<span class="hljs-constructor">RuntimeException</span>) t;</span><br><span class="hljs-pattern-match">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="hljs-pattern-match">            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">InternalError(<span class="hljs-params">t</span>.<span class="hljs-params">toString</span>()</span>, t);</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">    &#125; catch (<span class="hljs-constructor">NoSuchMethodException</span> e) &#123;</span><br><span class="hljs-pattern-match">        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">InternalError(<span class="hljs-params">e</span>.<span class="hljs-params">toString</span>()</span>, e);</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match">1.loader类加载器</span><br><span class="hljs-pattern-match">2.interfaces实现接口的类型</span><br><span class="hljs-pattern-match">3.h需要触发的事件</span><br><span class="hljs-pattern-match">public <span class="hljs-keyword">class</span> <span class="hljs-constructor">ProxyImage</span>&#123;</span><br><span class="hljs-pattern-match">    public <span class="hljs-constructor">Object</span> get<span class="hljs-constructor">Instance(Object <span class="hljs-params">object</span>)</span>&#123;</span><br><span class="hljs-pattern-match">        return <span class="hljs-constructor">Proxy</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(<span class="hljs-params">object</span>.<span class="hljs-params">getClass</span>()</span>.get<span class="hljs-constructor">ClassLoader()</span>, <span class="hljs-keyword">object</span>.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">Interfaces()</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">InvocationHandler()</span> &#123;</span><br><span class="hljs-pattern-match">            @<span class="hljs-constructor">Override</span></span><br><span class="hljs-pattern-match">            public <span class="hljs-constructor">Object</span> invoke(<span class="hljs-constructor">Object</span> proxy, <span class="hljs-constructor">Method</span> <span class="hljs-keyword">method</span>, <span class="hljs-constructor">Object</span>[] args) throws <span class="hljs-constructor">Throwable</span> &#123;</span><br><span class="hljs-pattern-match">                return <span class="hljs-keyword">method</span>.invoke(<span class="hljs-keyword">object</span>,args);</span><br><span class="hljs-pattern-match">            &#125;</span><br><span class="hljs-pattern-match">        &#125;)</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>    缺点：目标对象必须实现接口，代理类不需要实现接口</p><p>3.cglib代理</p><p>    优点：目标对象不需要实现接口</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Enhancer:能代理普通的<span class="hljs-keyword">class</span>和接口，能拦截除finaal修饰的方法<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ProxyImage&#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> test()&#123;<br>        Enhancer enhancer = <span class="hljs-built_in">new</span> Enhancer();<br>        enhancer.setSuperclass(RealImage.<span class="hljs-keyword">class</span>);<br>        enhancer.setCallback(<span class="hljs-built_in">new</span> MethodInterceptor() &#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> intercept(<span class="hljs-keyword">Object</span> obj, <span class="hljs-keyword">Method</span> <span class="hljs-keyword">method</span>, <span class="hljs-keyword">Object</span>[] args, MethodProxy proxy) throws Throwable &#123;<br>                <span class="hljs-keyword">Object</span> result = proxy.invokeSuper(obj, args);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;);<br>        RealImage realImage= (RealImage) enhancer.<span class="hljs-keyword">create</span>();<br>        <span class="hljs-keyword">return</span> realImage;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>    </p><p>    </p><p>    </p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map与flatMap</title>
    <link href="/2021/11/19/map%E4%B8%8EflatMap/"/>
    <url>/2021/11/19/map%E4%B8%8EflatMap/</url>
    
    <content type="html"><![CDATA[<h1 id="map与flatMap"><a href="#map与flatMap" class="headerlink" title="map与flatMap"></a>map与flatMap</h1><ul><li>map<ul><li>map:Returns a stream consisting of the results of applying the given function to the elements of this stream.</li><li>通俗讲对流中的元素进行转换</li></ul></li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">List&lt;<span class="hljs-built_in">String</span>&gt; listA=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>listA.stream().<span class="hljs-keyword">map</span>(res-&gt;&#123;<br>    <span class="hljs-keyword">return</span> res+<span class="hljs-string">&quot;增加&quot;</span>;<br>&#125;).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><p>![7B977B3B-DE10-4CB7-88EA-7112E1949CAA]<img src="https://gitee.com/noahBlog/img-bed/raw/master/202111291716485.png"></p><ul><li>flatMap<ul><li>flatmap:Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</li><li>通俗讲对流中数据压平，然后多个流整合在一起</li></ul></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">List&lt;String&gt; words = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;word&quot;</span>)</span>;<br>List&lt;String&gt; listB = words.stream<span class="hljs-literal">()</span><br>        .map(word -&gt; word.split(<span class="hljs-string">&quot; &quot;</span>))<br>        .flat<span class="hljs-constructor">Map(Arrays::<span class="hljs-params">stream</span>)</span><br>        .distinct<span class="hljs-literal">()</span><br>        .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<br></code></pre></td></tr></table></figure><p>                    ![-1.png]<img src="https://gitee.com/noahBlog/img-bed/raw/master/202111291716174.png"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>StringBuffer与StringBuilder与String</title>
    <link href="/2021/11/19/StringBuffer%E4%B8%8EStringBuilder%E4%B8%8EString/"/>
    <url>/2021/11/19/StringBuffer%E4%B8%8EStringBuilder%E4%B8%8EString/</url>
    
    <content type="html"><![CDATA[<h1 id="StringBuffer与StringBuilder与String"><a href="#StringBuffer与StringBuilder与String" class="headerlink" title="StringBuffer与StringBuilder与String"></a>StringBuffer与StringBuilder与String</h1><p>线程是否安全</p><p>    1.String底层是final修饰的char数据，所有String是线程安全的</p><p>    2.StringBuffer继承了AbstractStringBuilder，底层加了synchronized同步锁，所以线程安全</p><p>    3.StringBuilder继承了AbstractStringBuffer，线程不安全</p><p>源码</p><p>    </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuffer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractStringBuilder</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">CharSequence</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A cache of the last value returned by toString. Cleared</span><br><span class="hljs-comment">     * whenever the StringBuffer is modified.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">char</span>[] toStringCache;<br><br>    <span class="hljs-comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">3388685877147921107</span>L;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a string buffer with no characters in it and an</span><br><span class="hljs-comment">     * initial capacity of 16 characters.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-number">16</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a string buffer with no characters in it and</span><br><span class="hljs-comment">     * the specified initial capacity.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      capacity  the initial capacity.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span>  NegativeArraySizeException  if the &#123;<span class="hljs-doctag">@code</span> capacity&#125;</span><br><span class="hljs-comment">     *               argument is less than &#123;<span class="hljs-doctag">@code</span> 0&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(capacity);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a string buffer initialized to the contents of the</span><br><span class="hljs-comment">     * specified string. The initial capacity of the string buffer is</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> 16&#125; plus the length of the string argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   str   the initial contents of the buffer.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(str.length() + <span class="hljs-number">16</span>);<br>        append(str);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a string buffer that contains the same characters</span><br><span class="hljs-comment">     * as the specified &#123;<span class="hljs-doctag">@code</span> CharSequence&#125;. The initial capacity of</span><br><span class="hljs-comment">     * the string buffer is &#123;<span class="hljs-doctag">@code</span> 16&#125; plus the length of the</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; argument.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * If the length of the specified &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; is</span><br><span class="hljs-comment">     * less than or equal to zero, then an empty buffer of capacity</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> 16&#125; is returned.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      seq   the sequence to copy.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(CharSequence seq)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(seq.length() + <span class="hljs-number">16</span>);<br>        append(seq);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value.length;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.ensureCapacity(minimumCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.trimToSize();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #length()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newLength)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.setLength(newLength);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #length()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);<br>        <span class="hljs-keyword">return</span> value[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">codePointAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">codePointAt</span><span class="hljs-params">(index)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>     1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">codePointBefore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">codePointBefore</span><span class="hljs-params">(index)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>     1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">codePointCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">codePointCount</span><span class="hljs-params">(beginIndex, endIndex)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>     1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">offsetByCodePoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> codePointOffset)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">offsetByCodePoints</span><span class="hljs-params">(index, codePointOffset)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getChars</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcBegin, <span class="hljs-keyword">int</span> srcEnd, <span class="hljs-keyword">char</span>[] dst,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-keyword">int</span> dstBegin)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">super</span>.getChars(srcBegin, srcEnd, dst, dstBegin);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #length()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        value[index] = ch;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(String.valueOf(obj));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Appends the specified &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125; to this sequence.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * The characters of the &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125; argument are appended,</span><br><span class="hljs-comment">     * in order, to the contents of this &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125;, increasing the</span><br><span class="hljs-comment">     * length of this &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125; by the length of the argument.</span><br><span class="hljs-comment">     * If &#123;<span class="hljs-doctag">@code</span> sb&#125; is &#123;<span class="hljs-doctag">@code</span> null&#125;, then the four characters</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> &quot;null&quot;&#125; are appended to this &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125;.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Let &lt;i&gt;n&lt;/i&gt; be the length of the old character sequence, the one</span><br><span class="hljs-comment">     * contained in the &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125; just prior to execution of the</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> append&#125; method. Then the character at index &lt;i&gt;k&lt;/i&gt; in</span><br><span class="hljs-comment">     * the new character sequence is equal to the character at index &lt;i&gt;k&lt;/i&gt;</span><br><span class="hljs-comment">     * in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less than &lt;i&gt;n&lt;/i&gt;;</span><br><span class="hljs-comment">     * otherwise, it is equal to the character at index &lt;i&gt;k-n&lt;/i&gt; in the</span><br><span class="hljs-comment">     * argument &#123;<span class="hljs-doctag">@code</span> sb&#125;.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * This method synchronizes on &#123;<span class="hljs-doctag">@code</span> this&#125;, the destination</span><br><span class="hljs-comment">     * object, but does not synchronize on the source (&#123;<span class="hljs-doctag">@code</span> sb&#125;).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   sb   the &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125; to append.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  a reference to this object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(StringBuffer sb)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(sb);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(AbstractStringBuilder asb)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(asb);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Appends the specified &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; to this</span><br><span class="hljs-comment">     * sequence.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * The characters of the &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; argument are appended,</span><br><span class="hljs-comment">     * in order, increasing the length of this sequence by the length of the</span><br><span class="hljs-comment">     * argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;The result of this method is exactly the same as if it were an</span><br><span class="hljs-comment">     * invocation of this.append(s, 0, s.length());</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;This method synchronizes on &#123;<span class="hljs-doctag">@code</span> this&#125;, the destination</span><br><span class="hljs-comment">     * object, but does not synchronize on the source (&#123;<span class="hljs-doctag">@code</span> s&#125;).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;If &#123;<span class="hljs-doctag">@code</span> s&#125; is &#123;<span class="hljs-doctag">@code</span> null&#125;, then the four characters</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> &quot;null&quot;&#125; are appended.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   s the &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; to append.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  a reference to this object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(s);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(s, start, end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(str, offset, len);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">appendCodePoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> codePoint)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.appendCodePoint(codePoint);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lng)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(lng);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">float</span> f)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(f);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(d);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.delete(start, end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">deleteCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.deleteCharAt(index);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, String str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.replace(start, end, str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">substring</span><span class="hljs-params">(start, count)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">CharSequence <span class="hljs-title">subSequence</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">substring</span><span class="hljs-params">(start, end)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">substring</span><span class="hljs-params">(start, end)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(index, str, offset, len);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, Object obj)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(offset, String.valueOf(obj));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, String str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(offset, str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span>[] str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(offset, str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocations of other StringBuffer methods</span><br>        <span class="hljs-comment">// after narrowing of s to specific type</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(dstOffset, s);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(dstOffset, s, start, end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">boolean</span> b)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span><br>        <span class="hljs-comment">// after conversion of b to String by super class method</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(offset, b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(offset, c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span><br>        <span class="hljs-comment">// after conversion of i to String by super class method</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(offset, i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">long</span> l)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span><br>        <span class="hljs-comment">// after conversion of l to String by super class method</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(offset, l);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">float</span> f)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span><br>        <span class="hljs-comment">// after conversion of f to String by super class method</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(offset, f);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">double</span> d)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span><br>        <span class="hljs-comment">// after conversion of d to String by super class method</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(offset, d);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocations of other StringBuffer methods</span><br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">indexOf</span><span class="hljs-params">(str)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">indexOf</span><span class="hljs-params">(str, fromIndex)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocations of other StringBuffer methods</span><br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(str, count)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">lastIndexOf</span><span class="hljs-params">(str, fromIndex)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>   JDK1.0.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">reverse</span><span class="hljs-params">()</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.reverse();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-keyword">null</span>) &#123;<br>            toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(toStringCache, <span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Serializable fields for StringBuffer.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@serialField</span> value  char[]</span><br><span class="hljs-comment">     *              The backing character array of this StringBuffer.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@serialField</span> count int</span><br><span class="hljs-comment">     *              The number of characters in this StringBuffer.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@serialField</span> shared  boolean</span><br><span class="hljs-comment">     *              A flag indicating whether the backing array is shared.</span><br><span class="hljs-comment">     *              The value is ignored upon deserialization.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.io.ObjectStreamField[] serialPersistentFields =<br>    &#123;<br>        <span class="hljs-keyword">new</span> java.io.ObjectStreamField(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-keyword">char</span>[].class),<br>        <span class="hljs-keyword">new</span> java.io.ObjectStreamField(<span class="hljs-string">&quot;count&quot;</span>, Integer.TYPE),<br>        <span class="hljs-keyword">new</span> java.io.ObjectStreamField(<span class="hljs-string">&quot;shared&quot;</span>, Boolean.TYPE),<br>    &#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * readObject is called to restore the state of the StringBuffer from</span><br><span class="hljs-comment">     * a stream.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> writeObject(java.io.ObjectOutputStream s)<br>        <span class="hljs-keyword">throws</span> java.io.IOException &#123;<br>        java.io.ObjectOutputStream.PutField fields = s.putFields();<br>        fields.put(<span class="hljs-string">&quot;value&quot;</span>, value);<br>        fields.put(<span class="hljs-string">&quot;count&quot;</span>, count);<br>        fields.put(<span class="hljs-string">&quot;shared&quot;</span>, <span class="hljs-keyword">false</span>);<br>        s.writeFields();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * readObject is called to restore the state of the StringBuffer from</span><br><span class="hljs-comment">     * a stream.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> readObject(java.io.ObjectInputStream s)<br>        <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>        java.io.ObjectInputStream.GetField fields = s.readFields();<br>        value = (<span class="hljs-keyword">char</span>[])fields.get(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-keyword">null</span>);<br>        count = fields.get(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuffer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractStringBuilder</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">CharSequence</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A cache of the last value returned by toString. Cleared</span><br><span class="hljs-comment">     * whenever the StringBuffer is modified.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">char</span>[] toStringCache;<br><br>    <span class="hljs-comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">3388685877147921107</span>L;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a string buffer with no characters in it and an</span><br><span class="hljs-comment">     * initial capacity of 16 characters.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-number">16</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a string buffer with no characters in it and</span><br><span class="hljs-comment">     * the specified initial capacity.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      capacity  the initial capacity.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span>  NegativeArraySizeException  if the &#123;<span class="hljs-doctag">@code</span> capacity&#125;</span><br><span class="hljs-comment">     *               argument is less than &#123;<span class="hljs-doctag">@code</span> 0&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(capacity);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a string buffer initialized to the contents of the</span><br><span class="hljs-comment">     * specified string. The initial capacity of the string buffer is</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> 16&#125; plus the length of the string argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   str   the initial contents of the buffer.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(str.length() + <span class="hljs-number">16</span>);<br>        append(str);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a string buffer that contains the same characters</span><br><span class="hljs-comment">     * as the specified &#123;<span class="hljs-doctag">@code</span> CharSequence&#125;. The initial capacity of</span><br><span class="hljs-comment">     * the string buffer is &#123;<span class="hljs-doctag">@code</span> 16&#125; plus the length of the</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; argument.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * If the length of the specified &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; is</span><br><span class="hljs-comment">     * less than or equal to zero, then an empty buffer of capacity</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> 16&#125; is returned.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      seq   the sequence to copy.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(CharSequence seq)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(seq.length() + <span class="hljs-number">16</span>);<br>        append(seq);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value.length;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.ensureCapacity(minimumCapacity);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.trimToSize();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #length()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newLength)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.setLength(newLength);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #length()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);<br>        <span class="hljs-keyword">return</span> value[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">codePointAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">codePointAt</span><span class="hljs-params">(index)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>     1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">codePointBefore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">codePointBefore</span><span class="hljs-params">(index)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>     1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">codePointCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">codePointCount</span><span class="hljs-params">(beginIndex, endIndex)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>     1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">offsetByCodePoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> codePointOffset)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">offsetByCodePoints</span><span class="hljs-params">(index, codePointOffset)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getChars</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcBegin, <span class="hljs-keyword">int</span> srcEnd, <span class="hljs-keyword">char</span>[] dst,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-keyword">int</span> dstBegin)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">super</span>.getChars(srcBegin, srcEnd, dst, dstBegin);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>        #length()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((index &lt; <span class="hljs-number">0</span>) || (index &gt;= count))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(index);<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        value[index] = ch;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(String.valueOf(obj));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Appends the specified &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125; to this sequence.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * The characters of the &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125; argument are appended,</span><br><span class="hljs-comment">     * in order, to the contents of this &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125;, increasing the</span><br><span class="hljs-comment">     * length of this &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125; by the length of the argument.</span><br><span class="hljs-comment">     * If &#123;<span class="hljs-doctag">@code</span> sb&#125; is &#123;<span class="hljs-doctag">@code</span> null&#125;, then the four characters</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> &quot;null&quot;&#125; are appended to this &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125;.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Let &lt;i&gt;n&lt;/i&gt; be the length of the old character sequence, the one</span><br><span class="hljs-comment">     * contained in the &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125; just prior to execution of the</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> append&#125; method. Then the character at index &lt;i&gt;k&lt;/i&gt; in</span><br><span class="hljs-comment">     * the new character sequence is equal to the character at index &lt;i&gt;k&lt;/i&gt;</span><br><span class="hljs-comment">     * in the old character sequence, if &lt;i&gt;k&lt;/i&gt; is less than &lt;i&gt;n&lt;/i&gt;;</span><br><span class="hljs-comment">     * otherwise, it is equal to the character at index &lt;i&gt;k-n&lt;/i&gt; in the</span><br><span class="hljs-comment">     * argument &#123;<span class="hljs-doctag">@code</span> sb&#125;.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * This method synchronizes on &#123;<span class="hljs-doctag">@code</span> this&#125;, the destination</span><br><span class="hljs-comment">     * object, but does not synchronize on the source (&#123;<span class="hljs-doctag">@code</span> sb&#125;).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   sb   the &#123;<span class="hljs-doctag">@code</span> StringBuffer&#125; to append.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  a reference to this object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(StringBuffer sb)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(sb);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(AbstractStringBuilder asb)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(asb);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Appends the specified &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; to this</span><br><span class="hljs-comment">     * sequence.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * The characters of the &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; argument are appended,</span><br><span class="hljs-comment">     * in order, increasing the length of this sequence by the length of the</span><br><span class="hljs-comment">     * argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;The result of this method is exactly the same as if it were an</span><br><span class="hljs-comment">     * invocation of this.append(s, 0, s.length());</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;This method synchronizes on &#123;<span class="hljs-doctag">@code</span> this&#125;, the destination</span><br><span class="hljs-comment">     * object, but does not synchronize on the source (&#123;<span class="hljs-doctag">@code</span> s&#125;).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;If &#123;<span class="hljs-doctag">@code</span> s&#125; is &#123;<span class="hljs-doctag">@code</span> null&#125;, then the four characters</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> &quot;null&quot;&#125; are appended.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>   s the &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; to append.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  a reference to this object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(s);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(s, start, end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(str, offset, len);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">appendCodePoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> codePoint)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.appendCodePoint(codePoint);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lng)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(lng);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">float</span> f)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(f);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(d);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.delete(start, end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">deleteCharAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.deleteCharAt(index);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, String str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.replace(start, end, str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">substring</span><span class="hljs-params">(start, count)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">CharSequence <span class="hljs-title">subSequence</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">substring</span><span class="hljs-params">(start, end)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">substring</span><span class="hljs-params">(start, end)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(index, str, offset, len);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, Object obj)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(offset, String.valueOf(obj));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, String str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(offset, str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span>[] str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(offset, str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocations of other StringBuffer methods</span><br>        <span class="hljs-comment">// after narrowing of s to specific type</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(dstOffset, s);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.5</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstOffset, CharSequence s,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(dstOffset, s, start, end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">boolean</span> b)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span><br>        <span class="hljs-comment">// after conversion of b to String by super class method</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(offset, b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(offset, c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span><br>        <span class="hljs-comment">// after conversion of i to String by super class method</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(offset, i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">long</span> l)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span><br>        <span class="hljs-comment">// after conversion of l to String by super class method</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(offset, l);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">float</span> f)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span><br>        <span class="hljs-comment">// after conversion of f to String by super class method</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(offset, f);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">double</span> d)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocation of StringBuffer insert(int, String)</span><br>        <span class="hljs-comment">// after conversion of d to String by super class method</span><br>        <span class="hljs-comment">// Ditto for toStringCache clearing</span><br>        <span class="hljs-keyword">super</span>.insert(offset, d);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocations of other StringBuffer methods</span><br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">indexOf</span><span class="hljs-params">(str)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">indexOf</span><span class="hljs-params">(str, fromIndex)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-comment">// Note, synchronization achieved via invocations of other StringBuffer methods</span><br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(str, count)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.4</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> fromIndex)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">lastIndexOf</span><span class="hljs-params">(str, fromIndex)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>   JDK1.0.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">StringBuffer <span class="hljs-title">reverse</span><span class="hljs-params">()</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.reverse();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-keyword">null</span>) &#123;<br>            toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(toStringCache, <span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Serializable fields for StringBuffer.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@serialField</span> value  char[]</span><br><span class="hljs-comment">     *              The backing character array of this StringBuffer.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@serialField</span> count int</span><br><span class="hljs-comment">     *              The number of characters in this StringBuffer.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@serialField</span> shared  boolean</span><br><span class="hljs-comment">     *              A flag indicating whether the backing array is shared.</span><br><span class="hljs-comment">     *              The value is ignored upon deserialization.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.io.ObjectStreamField[] serialPersistentFields =<br>    &#123;<br>        <span class="hljs-keyword">new</span> java.io.ObjectStreamField(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-keyword">char</span>[].class),<br>        <span class="hljs-keyword">new</span> java.io.ObjectStreamField(<span class="hljs-string">&quot;count&quot;</span>, Integer.TYPE),<br>        <span class="hljs-keyword">new</span> java.io.ObjectStreamField(<span class="hljs-string">&quot;shared&quot;</span>, Boolean.TYPE),<br>    &#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * readObject is called to restore the state of the StringBuffer from</span><br><span class="hljs-comment">     * a stream.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> writeObject(java.io.ObjectOutputStream s)<br>        <span class="hljs-keyword">throws</span> java.io.IOException &#123;<br>        java.io.ObjectOutputStream.PutField fields = s.putFields();<br>        fields.put(<span class="hljs-string">&quot;value&quot;</span>, value);<br>        fields.put(<span class="hljs-string">&quot;count&quot;</span>, count);<br>        fields.put(<span class="hljs-string">&quot;shared&quot;</span>, <span class="hljs-keyword">false</span>);<br>        s.writeFields();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * readObject is called to restore the state of the StringBuffer from</span><br><span class="hljs-comment">     * a stream.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> readObject(java.io.ObjectInputStream s)<br>        <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>        java.io.ObjectInputStream.GetField fields = s.readFields();<br>        value = (<span class="hljs-keyword">char</span>[])fields.get(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-keyword">null</span>);<br>        count = fields.get(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拷贝</title>
    <link href="/2021/11/19/%E6%8B%B7%E8%B4%9D/"/>
    <url>/2021/11/19/%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><p>深拷贝，浅拷贝</p><p>1.深拷贝：对基本类型复制，引用类型创建新的对象，拷贝内容，指向新对象</p><p>2.浅拷贝：对基本类型复制，引用类型指向同一个地址</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2021/11/19/%E5%8F%8D%E5%B0%84/"/>
    <url>/2021/11/19/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射运行加载类的时候，获取完整的类，调用他的方法</p><p>反射API </p><p>    1.获取Class对象</p><p>        1.通过名称</p><p>            </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class A=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(“<span class="hljs-params">xxx</span>.<span class="hljs-params">xxx</span>.<span class="hljs-params">xxx</span>”)</span>;<br></code></pre></td></tr></table></figure><p>        2.通过class</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class A=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Apple</span>.</span></span><span class="hljs-keyword">class</span>;<br></code></pre></td></tr></table></figure><p>        3.通过getClass方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String k=<span class="hljs-keyword">new</span> <span class="hljs-constructor">String(“<span class="hljs-params">test</span>”)</span>;<br>Class A=k.get<span class="hljs-constructor">Class()</span>;<br></code></pre></td></tr></table></figure><p>  2.通过Class创建对象</p><p>    1.通过newInstance()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Apple a=（Apple)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br></code></pre></td></tr></table></figure><p>        2.通过Constructor对象创建,并可以添加构造参数```<br>Constructor constructor = A.getConstructor();<br>Apple a=（Apple)constructor.newInstance(“color”,red);</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>    3.获取反射类中的属性，方法等，不包含私有属性<br><br></code></pre></td></tr></table></figure><p>Field[] fields = A.getFields();</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>    4.获取反射类中的属性，方法等，包含私有属性<br><br></code></pre></td></tr></table></figure><p>Field[] fields = A.getDeclaredFields();</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>public final class Class<T> implements java.io.Serializable,<br>                              GenericDeclaration,<br>                              Type,<br>                              AnnotatedElement {<br>    private static final int ANNOTATION= 0x00002000;<br>    private static final int ENUM      = 0x00004000;<br>    private static final int SYNTHETIC = 0x00001000;</p><p>    private static native void registerNatives();<br>    static {<br>        registerNatives();<br>    }</p><p>    /*<br>     * Private constructor. Only the Java Virtual Machine creates Class objects.<br>     * This constructor is not used and prevents the default constructor being<br>     * generated.<br>     */<br>    private Class(ClassLoader loader) {<br>        // Initialize final field for classLoader.  The initialization value of non-null<br>        // prevents future JIT optimizations from assuming this final field is null.<br>        classLoader = loader;<br>    }</p><p>    /**<br>     * Converts the object to a string. The string representation is the<br>     * string “class” or “interface”, followed by a space, and then by the<br>     * fully qualified name of the class in the format returned by<br>     * {@code getName}.  If this {@code Class} object represents a<br>     * primitive type, this method returns the name of the primitive type.  If<br>     * this {@code Class} object represents void this method returns<br>     * “void”.<br>     *<br>     * @return a string representation of this class object.<br>     */<br>    public String toString() {<br>        return (isInterface() ? “interface “ : (isPrimitive() ? “” : “class “))<br>            + getName();<br>    }</p><p>    /**<br>     * Returns a string describing this {@code Class}, including<br>     * information about modifiers and type parameters.<br>     *<br>     * The string is formatted as a list of type modifiers, if any,<br>     * followed by the kind of type (empty string for primitive types<br>     * and {@code class}, {@code enum}, {@code interface}, or<br>     * <code>&#64;</code>{@code interface}, as appropriate), followed<br>     * by the type’s name, followed by an angle-bracketed<br>     * comma-separated list of the type’s type parameters, if any.<br>     *<br>     * A space is used to separate modifiers from one another and to<br>     * separate any modifiers from the kind of type. The modifiers<br>     * occur in canonical order. If there are no type parameters, the<br>     * type parameter list is elided.<br>     *<br>     * <p>Note that since information about the runtime representation<br>     * of a type is being generated, modifiers not present on the<br>     * originating source code or illegal on the originating source<br>     * code may be present.<br>     *<br>     * @return a string describing this {@code Class}, including<br>     * information about modifiers and type parameters<br>     *<br>     * @since 1.8<br>     */<br>    public String toGenericString() {<br>        if (isPrimitive()) {<br>            return toString();<br>        } else {<br>            StringBuilder sb = new StringBuilder();</p><p>            // Class modifiers are a superset of interface modifiers<br>            int modifiers = getModifiers() &amp; Modifier.classModifiers();<br>            if (modifiers != 0) {<br>                sb.append(Modifier.toString(modifiers));<br>                sb.append(‘ ‘);<br>            }</p><p>            if (isAnnotation()) {<br>                sb.append(‘@’);<br>            }<br>            if (isInterface()) { // Note: all annotation types are interfaces<br>                sb.append(“interface”);<br>            } else {<br>                if (isEnum())<br>                    sb.append(“enum”);<br>                else<br>                    sb.append(“class”);<br>            }<br>            sb.append(‘ ‘);<br>            sb.append(getName());</p><p>            TypeVariable<?>[] typeparms = getTypeParameters();            if (typeparms.length > 0) {                boolean first = true;                sb.append('<');                for(TypeVariable<?> typeparm: typeparms) {<br>                    if (!first)<br>                        sb.append(‘,’);<br>                    sb.append(typeparm.getTypeName());<br>                    first = false;<br>                }<br>                sb.append(‘&gt;’);<br>            }</p><p>            return sb.toString();<br>        }<br>    }</p><p>    /**<br>     * Returns the {@code Class} object associated with the class or<br>     * interface with the given string name.  Invoking this method is<br>     * equivalent to:<br>     *<br>     * <blockquote><br>     *  {@code Class.forName(className, true, currentLoader)}<br>     * </blockquote><br>     *<br>     * where {@code currentLoader} denotes the defining class loader of<br>     * the current class.<br>     *<br>     * <p> For example, the following code fragment returns the<br>     * runtime {@code Class} descriptor for the class named<br>     * {@code java.lang.Thread}:<br>     *<br>     * <blockquote><br>     *   {@code Class t = Class.forName(“java.lang.Thread”)}<br>     * </blockquote><br>     * <p><br>     * A call to {@code forName(“X”)} causes the class named<br>     * {@code X} to be initialized.<br>     *<br>     * @param      className   the fully qualified name of the desired class.<br>     * @return     the {@code Class} object for the class with the<br>     *             specified name.<br>     * @exception LinkageError if the linkage fails<br>     * @exception ExceptionInInitializerError if the initialization provoked<br>     *            by this method fails<br>     * @exception ClassNotFoundException if the class cannot be located<br>     */<br>    @CallerSensitive<br>    public static Class<?> forName(String className)                throws ClassNotFoundException {        Class<?> caller = Reflection.getCallerClass();<br>        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);<br>    }</p><p>    /**<br>     * Returns the {@code Class} object associated with the class or<br>     * interface with the given string name, using the given class loader.<br>     * Given the fully qualified name for a class or interface (in the same<br>     * format returned by {@code getName}) this method attempts to<br>     * locate, load, and link the class or interface.  The specified class<br>     * loader is used to load the class or interface.  If the parameter<br>     * {@code loader} is null, the class is loaded through the bootstrap<br>     * class loader.  The class is initialized only if the<br>     * {@code initialize} parameter is {@code true} and if it has<br>     * not been initialized earlier.<br>     *<br>     * <p> If {@code name} denotes a primitive type or void, an attempt<br>     * will be made to locate a user-defined class in the unnamed package whose<br>     * name is {@code name}. Therefore, this method cannot be used to<br>     * obtain any of the {@code Class} objects representing primitive<br>     * types or void.<br>     *<br>     * <p> If {@code name} denotes an array class, the component type of<br>     * the array class is loaded but not initialized.<br>     *<br>     * <p> For example, in an instance method the expression:<br>     *<br>     * <blockquote><br>     *  {@code Class.forName(“Foo”)}<br>     * </blockquote><br>     *<br>     * is equivalent to:<br>     *<br>     * <blockquote><br>     *  {@code Class.forName(“Foo”, true, this.getClass().getClassLoader())}<br>     * </blockquote><br>     *<br>     * Note that this method throws errors related to loading, linking or<br>     * initializing as specified in Sections 12.2, 12.3 and 12.4 of <em>The<br>     * Java Language Specification</em>.<br>     * Note that this method does not check whether the requested class<br>     * is accessible to its caller.<br>     *<br>     * <p> If the {@code loader} is {@code null}, and a security<br>     * manager is present, and the caller’s class loader is not null, then this<br>     * method calls the security manager’s {@code checkPermission} method<br>     * with a {@code RuntimePermission(“getClassLoader”)} permission to<br>     * ensure it’s ok to access the bootstrap class loader.<br>     *<br>     * @param name       fully qualified name of the desired class<br>     * @param initialize if {@code true} the class will be initialized.<br>     *                   See Section 12.4 of <em>The Java Language Specification</em>.<br>     * @param loader     class loader from which the class must be loaded<br>     * @return           class object representing the desired class<br>     *<br>     * @exception LinkageError if the linkage fails<br>     * @exception ExceptionInInitializerError if the initialization provoked<br>     *            by this method fails<br>     * @exception ClassNotFoundException if the class cannot be located by<br>     *            the specified class loader<br>     *<br>     * @see       java.lang.Class#forName(String)<br>     * @see       java.lang.ClassLoader<br>     * @since     1.2<br>     */<br>    @CallerSensitive<br>    public static Class<?> forName(String name, boolean initialize,                                   ClassLoader loader)        throws ClassNotFoundException    {        Class<?> caller = null;<br>        SecurityManager sm = System.getSecurityManager();<br>        if (sm != null) {<br>            // Reflective call to get caller class is only needed if a security manager<br>            // is present.  Avoid the overhead of making this call otherwise.<br>            caller = Reflection.getCallerClass();<br>            if (sun.misc.VM.isSystemDomainLoader(loader)) {<br>                ClassLoader ccl = ClassLoader.getClassLoader(caller);<br>                if (!sun.misc.VM.isSystemDomainLoader(ccl)) {<br>                    sm.checkPermission(<br>                        SecurityConstants.GET_CLASSLOADER_PERMISSION);<br>                }<br>            }<br>        }<br>        return forName0(name, initialize, loader, caller);<br>    }</p><p>    /** Called after security check for system loader access checks have been made. */<br>    private static native Class<?> forName0(String name, boolean initialize,                                            ClassLoader loader,                                            Class<?> caller)<br>        throws ClassNotFoundException;</p><p>    /**<br>     * Creates a new instance of the class represented by this {@code Class}<br>     * object.  The class is instantiated as if by a {@code new}<br>     * expression with an empty argument list.  The class is initialized if it<br>     * has not already been initialized.<br>     *<br>     * <p>Note that this method propagates any exception thrown by the<br>     * nullary constructor, including a checked exception.  Use of<br>     * this method effectively bypasses the compile-time exception<br>     * checking that would otherwise be performed by the compiler.<br>     * The {@link<br>     * java.lang.reflect.Constructor#newInstance(java.lang.Object…)<br>     * Constructor.newInstance} method avoids this problem by wrapping<br>     * any exception thrown by the constructor in a (checked) {@link<br>     * java.lang.reflect.InvocationTargetException}.<br>     *<br>     * @return  a newly allocated instance of the class represented by this<br>     *          object.<br>     * @throws  IllegalAccessException  if the class or its nullary<br>     *          constructor is not accessible.<br>     * @throws  InstantiationException<br>     *          if this {@code Class} represents an abstract class,<br>     *          an interface, an array class, a primitive type, or void;<br>     *          or if the class has no nullary constructor;<br>     *          or if the instantiation fails for some other reason.<br>     * @throws  ExceptionInInitializerError if the initialization<br>     *          provoked by this method fails.<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and<br>     *          the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class.<br>     */<br>    @CallerSensitive<br>    public T newInstance()<br>        throws InstantiationException, IllegalAccessException<br>    {<br>        if (System.getSecurityManager() != null) {<br>            checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);<br>        }</p><p>        // NOTE: the following code may not be strictly correct under<br>        // the current Java memory model.</p><p>        // Constructor lookup<br>        if (cachedConstructor == null) {<br>            if (this == Class.class) {<br>                throw new IllegalAccessException(<br>                    “Can not call newInstance() on the Class for java.lang.Class”<br>                );<br>            }<br>            try {<br>                Class<?>[] empty = {};                final Constructor<T> c = getConstructor0(empty, Member.DECLARED);                // Disable accessibility checks on the constructor                // since we have to do the security check here anyway                // (the stack depth is wrong for the Constructor's                // security check to work)                java.security.AccessController.doPrivileged(                    new java.security.PrivilegedAction<Void>() {                        public Void run() {                                c.setAccessible(true);                                return null;                            }                        });                cachedConstructor = c;            } catch (NoSuchMethodException e) {                throw (InstantiationException)                    new InstantiationException(getName()).initCause(e);            }        }        Constructor<T> tmpConstructor = cachedConstructor;        // Security check (same as in java.lang.reflect.Constructor)        int modifiers = tmpConstructor.getModifiers();        if (!Reflection.quickCheckMemberAccess(this, modifiers)) {            Class<?> caller = Reflection.getCallerClass();<br>            if (newInstanceCallerCache != caller) {<br>                Reflection.ensureMemberAccess(caller, this, null, modifiers);<br>                newInstanceCallerCache = caller;<br>            }<br>        }<br>        // Run constructor<br>        try {<br>            return tmpConstructor.newInstance((Object[])null);<br>        } catch (InvocationTargetException e) {<br>            Unsafe.getUnsafe().throwException(e.getTargetException());<br>            // Not reached<br>            return null;<br>        }<br>    }<br>    private volatile transient Constructor<T> cachedConstructor;<br>    private volatile transient Class&lt;?&gt;       newInstanceCallerCache;</p><p>    /**<br>     * Determines if the specified {@code Object} is assignment-compatible<br>     * with the object represented by this {@code Class}.  This method is<br>     * the dynamic equivalent of the Java language {@code instanceof}<br>     * operator. The method returns {@code true} if the specified<br>     * {@code Object} argument is non-null and can be cast to the<br>     * reference type represented by this {@code Class} object without<br>     * raising a {@code ClassCastException.} It returns {@code false}<br>     * otherwise.<br>     *<br>     * <p> Specifically, if this {@code Class} object represents a<br>     * declared class, this method returns {@code true} if the specified<br>     * {@code Object} argument is an instance of the represented class (or<br>     * of any of its subclasses); it returns {@code false} otherwise. If<br>     * this {@code Class} object represents an array class, this method<br>     * returns {@code true} if the specified {@code Object} argument<br>     * can be converted to an object of the array class by an identity<br>     * conversion or by a widening reference conversion; it returns<br>     * {@code false} otherwise. If this {@code Class} object<br>     * represents an interface, this method returns {@code true} if the<br>     * class or any superclass of the specified {@code Object} argument<br>     * implements this interface; it returns {@code false} otherwise. If<br>     * this {@code Class} object represents a primitive type, this method<br>     * returns {@code false}.<br>     *<br>     * @param   obj the object to check<br>     * @return  true if {@code obj} is an instance of this class<br>     *<br>     * @since JDK1.1<br>     */<br>    public native boolean isInstance(Object obj);</p><p>    /**<br>     * Determines if the class or interface represented by this<br>     * {@code Class} object is either the same as, or is a superclass or<br>     * superinterface of, the class or interface represented by the specified<br>     * {@code Class} parameter. It returns {@code true} if so;<br>     * otherwise it returns {@code false}. If this {@code Class}<br>     * object represents a primitive type, this method returns<br>     * {@code true} if the specified {@code Class} parameter is<br>     * exactly this {@code Class} object; otherwise it returns<br>     * {@code false}.<br>     *<br>     * <p> Specifically, this method tests whether the type represented by the<br>     * specified {@code Class} parameter can be converted to the type<br>     * represented by this {@code Class} object via an identity conversion<br>     * or via a widening reference conversion. See <em>The Java Language<br>     * Specification</em>, sections 5.1.1 and 5.1.4 , for details.<br>     *<br>     * @param cls the {@code Class} object to be checked<br>     * @return the {@code boolean} value indicating whether objects of the<br>     * type {@code cls} can be assigned to objects of this class<br>     * @exception NullPointerException if the specified Class parameter is<br>     *            null.<br>     * @since JDK1.1<br>     */<br>    public native boolean isAssignableFrom(Class&lt;?&gt; cls);</p><p>    /**<br>     * Determines if the specified {@code Class} object represents an<br>     * interface type.<br>     *<br>     * @return  {@code true} if this object represents an interface;<br>     *          {@code false} otherwise.<br>     */<br>    public native boolean isInterface();</p><p>    /**<br>     * Determines if this {@code Class} object represents an array class.<br>     *<br>     * @return  {@code true} if this object represents an array class;<br>     *          {@code false} otherwise.<br>     * @since   JDK1.1<br>     */<br>    public native boolean isArray();</p><p>    /**<br>     * Determines if the specified {@code Class} object represents a<br>     * primitive type.<br>     *<br>     * <p> There are nine predefined {@code Class} objects to represent<br>     * the eight primitive types and void.  These are created by the Java<br>     * Virtual Machine, and have the same names as the primitive types that<br>     * they represent, namely {@code boolean}, {@code byte},<br>     * {@code char}, {@code short}, {@code int},<br>     * {@code long}, {@code float}, and {@code double}.<br>     *<br>     * <p> These objects may only be accessed via the following public static<br>     * final variables, and are the only {@code Class} objects for which<br>     * this method returns {@code true}.<br>     *<br>     * @return true if and only if this class represents a primitive type<br>     *<br>     * @see     java.lang.Boolean#TYPE<br>     * @see     java.lang.Character#TYPE<br>     * @see     java.lang.Byte#TYPE<br>     * @see     java.lang.Short#TYPE<br>     * @see     java.lang.Integer#TYPE<br>     * @see     java.lang.Long#TYPE<br>     * @see     java.lang.Float#TYPE<br>     * @see     java.lang.Double#TYPE<br>     * @see     java.lang.Void#TYPE<br>     * @since JDK1.1<br>     */<br>    public native boolean isPrimitive();</p><p>    /**<br>     * Returns true if this {@code Class} object represents an annotation<br>     * type.  Note that if this method returns true, {@link #isInterface()}<br>     * would also return true, as all annotation types are also interfaces.<br>     *<br>     * @return {@code true} if this class object represents an annotation<br>     *      type; {@code false} otherwise<br>     * @since 1.5<br>     */<br>    public boolean isAnnotation() {<br>        return (getModifiers() &amp; ANNOTATION) != 0;<br>    }</p><p>    /**<br>     * Returns {@code true} if this class is a synthetic class;<br>     * returns {@code false} otherwise.<br>     * @return {@code true} if and only if this class is a synthetic class as<br>     *         defined by the Java Language Specification.<br>     * @jls 13.1 The Form of a Binary<br>     * @since 1.5<br>     */<br>    public boolean isSynthetic() {<br>        return (getModifiers() &amp; SYNTHETIC) != 0;<br>    }</p><p>    /**<br>     * Returns the  name of the entity (class, interface, array class,<br>     * primitive type, or void) represented by this {@code Class} object,<br>     * as a {@code String}.<br>     *<br>     * <p> If this class object represents a reference type that is not an<br>     * array type then the binary name of the class is returned, as specified<br>     * by<br>     * <cite>The Java&trade; Language Specification</cite>.<br>     *<br>     * <p> If this class object represents a primitive type or void, then the<br>     * name returned is a {@code String} equal to the Java language<br>     * keyword corresponding to the primitive type or void.<br>     *<br>     * <p> If this class object represents a class of arrays, then the internal<br>     * form of the name consists of the name of the element type preceded by<br>     * one or more ‘{@code [}’ characters representing the depth of the array<br>     * nesting.  The encoding of element type names is as follows:<br>     *<br>     * <blockquote><table summary="Element types and encodings"><br>     * <tr><th> Element Type <th> &nbsp;&nbsp;&nbsp; <th> Encoding<br>     * <tr><td> boolean      <td> &nbsp;&nbsp;&nbsp; <td align=center> Z<br>     * <tr><td> byte         <td> &nbsp;&nbsp;&nbsp; <td align=center> B<br>     * <tr><td> char         <td> &nbsp;&nbsp;&nbsp; <td align=center> C<br>     * <tr><td> class or interface<br>     *                       <td> &nbsp;&nbsp;&nbsp; <td align=center> L<i>classname</i>;<br>     * <tr><td> double       <td> &nbsp;&nbsp;&nbsp; <td align=center> D<br>     * <tr><td> float        <td> &nbsp;&nbsp;&nbsp; <td align=center> F<br>     * <tr><td> int          <td> &nbsp;&nbsp;&nbsp; <td align=center> I<br>     * <tr><td> long         <td> &nbsp;&nbsp;&nbsp; <td align=center> J<br>     * <tr><td> short        <td> &nbsp;&nbsp;&nbsp; <td align=center> S<br>     * </table></blockquote><br>     *<br>     * <p> The class or interface name <i>classname</i> is the binary name of<br>     * the class specified above.<br>     *<br>     * <p> Examples:<br>     * <blockquote><pre><br>     * String.class.getName()<br>     *     returns "java.lang.String"<br>     * byte.class.getName()<br>     *     returns "byte"<br>     * (new Object[3]).getClass().getName()<br>     *     returns "[Ljava.lang.Object;"<br>     * (new int[3][4][5][6][7][8][9]).getClass().getName()<br>     *     returns "[[[[[[[I"<br>     * </pre></blockquote><br>     *<br>     * @return  the name of the class or interface<br>     *          represented by this object.<br>     */<br>    public String getName() {<br>        String name = this.name;<br>        if (name == null)<br>            this.name = name = getName0();<br>        return name;<br>    }</p><p>    // cache the name to reduce the number of calls into the VM<br>    private transient String name;<br>    private native String getName0();</p><p>    /**<br>     * Returns the class loader for the class.  Some implementations may use<br>     * null to represent the bootstrap class loader. This method will return<br>     * null in such implementations if this class was loaded by the bootstrap<br>     * class loader.<br>     *<br>     * <p> If a security manager is present, and the caller’s class loader is<br>     * not null and the caller’s class loader is not the same as or an ancestor of<br>     * the class loader for the class whose class loader is requested, then<br>     * this method calls the security manager’s {@code checkPermission}<br>     * method with a {@code RuntimePermission(“getClassLoader”)}<br>     * permission to ensure it’s ok to access the class loader for the class.<br>     *<br>     * <p>If this object<br>     * represents a primitive type or void, null is returned.<br>     *<br>     * @return  the class loader that loaded the class or interface<br>     *          represented by this object.<br>     * @throws SecurityException<br>     *    if a security manager exists and its<br>     *    {@code checkPermission} method denies<br>     *    access to the class loader for the class.<br>     * @see java.lang.ClassLoader<br>     * @see SecurityManager#checkPermission<br>     * @see java.lang.RuntimePermission<br>     */<br>    @CallerSensitive<br>    public ClassLoader getClassLoader() {<br>        ClassLoader cl = getClassLoader0();<br>        if (cl == null)<br>            return null;<br>        SecurityManager sm = System.getSecurityManager();<br>        if (sm != null) {<br>            ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());<br>        }<br>        return cl;<br>    }</p><p>    // Package-private to allow ClassLoader access<br>    ClassLoader getClassLoader0() { return classLoader; }</p><p>    // Initialized in JVM not by private constructor<br>    // This field is filtered from reflection access, i.e. getDeclaredField<br>    // will throw NoSuchFieldException<br>    private final ClassLoader classLoader;</p><p>    /**<br>     * Returns an array of {@code TypeVariable} objects that represent the<br>     * type variables declared by the generic declaration represented by this<br>     * {@code GenericDeclaration} object, in declaration order.  Returns an<br>     * array of length 0 if the underlying generic declaration declares no type<br>     * variables.<br>     *<br>     * @return an array of {@code TypeVariable} objects that represent<br>     *     the type variables declared by this generic declaration<br>     * @throws java.lang.reflect.GenericSignatureFormatError if the generic<br>     *     signature of this generic declaration does not conform to<br>     *     the format specified in<br>     *     <cite>The Java&trade; Virtual Machine Specification</cite><br>     * @since 1.5<br>     */<br>    @SuppressWarnings(“unchecked”)<br>    public TypeVariable&lt;Class<T>&gt;[] getTypeParameters() {<br>        ClassRepository info = getGenericInfo();<br>        if (info != null)<br>            return (TypeVariable&lt;Class<T>&gt;[])info.getTypeParameters();<br>        else<br>            return (TypeVariable&lt;Class<T>&gt;[])new TypeVariable&lt;?&gt;[0];<br>    }</p><p>    /**<br>     * Returns the {@code Class} representing the superclass of the entity<br>     * (class, interface, primitive type or void) represented by this<br>     * {@code Class}.  If this {@code Class} represents either the<br>     * {@code Object} class, an interface, a primitive type, or void, then<br>     * null is returned.  If this object represents an array class then the<br>     * {@code Class} object representing the {@code Object} class is<br>     * returned.<br>     *<br>     * @return the superclass of the class represented by this object.<br>     */<br>    public native Class&lt;? super T&gt; getSuperclass();</p><p>    /**<br>     * Returns the {@code Type} representing the direct superclass of<br>     * the entity (class, interface, primitive type or void) represented by<br>     * this {@code Class}.<br>     *<br>     * <p>If the superclass is a parameterized type, the {@code Type}<br>     * object returned must accurately reflect the actual type<br>     * parameters used in the source code. The parameterized type<br>     * representing the superclass is created if it had not been<br>     * created before. See the declaration of {@link<br>     * java.lang.reflect.ParameterizedType ParameterizedType} for the<br>     * semantics of the creation process for parameterized types.  If<br>     * this {@code Class} represents either the {@code Object}<br>     * class, an interface, a primitive type, or void, then null is<br>     * returned.  If this object represents an array class then the<br>     * {@code Class} object representing the {@code Object} class is<br>     * returned.<br>     *<br>     * @throws java.lang.reflect.GenericSignatureFormatError if the generic<br>     *     class signature does not conform to the format specified in<br>     *     <cite>The Java&trade; Virtual Machine Specification</cite><br>     * @throws TypeNotPresentException if the generic superclass<br>     *     refers to a non-existent type declaration<br>     * @throws java.lang.reflect.MalformedParameterizedTypeException if the<br>     *     generic superclass refers to a parameterized type that cannot be<br>     *     instantiated  for any reason<br>     * @return the superclass of the class represented by this object<br>     * @since 1.5<br>     */<br>    public Type getGenericSuperclass() {<br>        ClassRepository info = getGenericInfo();<br>        if (info == null) {<br>            return getSuperclass();<br>        }</p><p>        // Historical irregularity:<br>        // Generic signature marks interfaces with superclass = Object<br>        // but this API returns null for interfaces<br>        if (isInterface()) {<br>            return null;<br>        }</p><p>        return info.getSuperclass();<br>    }</p><p>    /**<br>     * Gets the package for this class.  The class loader of this class is used<br>     * to find the package.  If the class was loaded by the bootstrap class<br>     * loader the set of packages loaded from CLASSPATH is searched to find the<br>     * package of the class. Null is returned if no package object was created<br>     * by the class loader of this class.<br>     *<br>     * <p> Packages have attributes for versions and specifications only if the<br>     * information was defined in the manifests that accompany the classes, and<br>     * if the class loader created the package instance with the attributes<br>     * from the manifest.<br>     *<br>     * @return the package of the class, or null if no package<br>     *         information is available from the archive or codebase.<br>     */<br>    public Package getPackage() {<br>        return Package.getPackage(this);<br>    }</p><p>    /**<br>     * Determines the interfaces implemented by the class or interface<br>     * represented by this object.<br>     *<br>     * <p> If this object represents a class, the return value is an array<br>     * containing objects representing all interfaces implemented by the<br>     * class. The order of the interface objects in the array corresponds to<br>     * the order of the interface names in the {@code implements} clause<br>     * of the declaration of the class represented by this object. For<br>     * example, given the declaration:<br>     * <blockquote><br>     * {@code class Shimmer implements FloorWax, DessertTopping { … }}<br>     * </blockquote><br>     * suppose the value of {@code s} is an instance of<br>     * {@code Shimmer}; the value of the expression:<br>     * <blockquote><br>     * {@code s.getClass().getInterfaces()[0]}<br>     * </blockquote><br>     * is the {@code Class} object that represents interface<br>     * {@code FloorWax}; and the value of:<br>     * <blockquote><br>     * {@code s.getClass().getInterfaces()[1]}<br>     * </blockquote><br>     * is the {@code Class} object that represents interface<br>     * {@code DessertTopping}.<br>     *<br>     * <p> If this object represents an interface, the array contains objects<br>     * representing all interfaces extended by the interface. The order of the<br>     * interface objects in the array corresponds to the order of the interface<br>     * names in the {@code extends} clause of the declaration of the<br>     * interface represented by this object.<br>     *<br>     * <p> If this object represents a class or interface that implements no<br>     * interfaces, the method returns an array of length 0.<br>     *<br>     * <p> If this object represents a primitive type or void, the method<br>     * returns an array of length 0.<br>     *<br>     * <p> If this {@code Class} object represents an array type, the<br>     * interfaces {@code Cloneable} and {@code java.io.Serializable} are<br>     * returned in that order.<br>     *<br>     * @return an array of interfaces implemented by this class.<br>     */<br>    public Class<?>[] getInterfaces() {        ReflectionData<T> rd = reflectionData();        if (rd == null) {            // no cloning required            return getInterfaces0();        } else {            Class<?>[] interfaces = rd.interfaces;<br>            if (interfaces == null) {<br>                interfaces = getInterfaces0();<br>                rd.interfaces = interfaces;<br>            }<br>            // defensively copy before handing over to user code<br>            return interfaces.clone();<br>        }<br>    }</p><p>    private native Class&lt;?&gt;[] getInterfaces0();</p><p>    /**<br>     * Returns the {@code Type}s representing the interfaces<br>     * directly implemented by the class or interface represented by<br>     * this object.<br>     *<br>     * <p>If a superinterface is a parameterized type, the<br>     * {@code Type} object returned for it must accurately reflect<br>     * the actual type parameters used in the source code. The<br>     * parameterized type representing each superinterface is created<br>     * if it had not been created before. See the declaration of<br>     * {@link java.lang.reflect.ParameterizedType ParameterizedType}<br>     * for the semantics of the creation process for parameterized<br>     * types.<br>     *<br>     * <p> If this object represents a class, the return value is an<br>     * array containing objects representing all interfaces<br>     * implemented by the class. The order of the interface objects in<br>     * the array corresponds to the order of the interface names in<br>     * the {@code implements} clause of the declaration of the class<br>     * represented by this object.  In the case of an array class, the<br>     * interfaces {@code Cloneable} and {@code Serializable} are<br>     * returned in that order.<br>     *<br>     * <p>If this object represents an interface, the array contains<br>     * objects representing all interfaces directly extended by the<br>     * interface.  The order of the interface objects in the array<br>     * corresponds to the order of the interface names in the<br>     * {@code extends} clause of the declaration of the interface<br>     * represented by this object.<br>     *<br>     * <p>If this object represents a class or interface that<br>     * implements no interfaces, the method returns an array of length<br>     * 0.<br>     *<br>     * <p>If this object represents a primitive type or void, the<br>     * method returns an array of length 0.<br>     *<br>     * @throws java.lang.reflect.GenericSignatureFormatError<br>     *     if the generic class signature does not conform to the format<br>     *     specified in<br>     *     <cite>The Java&trade; Virtual Machine Specification</cite><br>     * @throws TypeNotPresentException if any of the generic<br>     *     superinterfaces refers to a non-existent type declaration<br>     * @throws java.lang.reflect.MalformedParameterizedTypeException<br>     *     if any of the generic superinterfaces refer to a parameterized<br>     *     type that cannot be instantiated for any reason<br>     * @return an array of interfaces implemented by this class<br>     * @since 1.5<br>     */<br>    public Type[] getGenericInterfaces() {<br>        ClassRepository info = getGenericInfo();<br>        return (info == null) ?  getInterfaces() : info.getSuperInterfaces();<br>    }</p><p>    /**<br>     * Returns the {@code Class} representing the component type of an<br>     * array.  If this class does not represent an array class this method<br>     * returns null.<br>     *<br>     * @return the {@code Class} representing the component type of this<br>     * class if this class is an array<br>     * @see     java.lang.reflect.Array<br>     * @since JDK1.1<br>     */<br>    public native Class&lt;?&gt; getComponentType();</p><p>    /**<br>     * Returns the Java language modifiers for this class or interface, encoded<br>     * in an integer. The modifiers consist of the Java Virtual Machine’s<br>     * constants for {@code public}, {@code protected},<br>     * {@code private}, {@code final}, {@code static},<br>     * {@code abstract} and {@code interface}; they should be decoded<br>     * using the methods of class {@code Modifier}.<br>     *<br>     * <p> If the underlying class is an array class, then its<br>     * {@code public}, {@code private} and {@code protected}<br>     * modifiers are the same as those of its component type.  If this<br>     * {@code Class} represents a primitive type or void, its<br>     * {@code public} modifier is always {@code true}, and its<br>     * {@code protected} and {@code private} modifiers are always<br>     * {@code false}. If this object represents an array class, a<br>     * primitive type or void, then its {@code final} modifier is always<br>     * {@code true} and its interface modifier is always<br>     * {@code false}. The values of its other modifiers are not determined<br>     * by this specification.<br>     *<br>     * <p> The modifier encodings are defined in <em>The Java Virtual Machine<br>     * Specification</em>, table 4.1.<br>     *<br>     * @return the {@code int} representing the modifiers for this class<br>     * @see     java.lang.reflect.Modifier<br>     * @since JDK1.1<br>     */<br>    public native int getModifiers();</p><p>    /**<br>     * Gets the signers of this class.<br>     *<br>     * @return  the signers of this class, or null if there are no signers.  In<br>     *          particular, this method returns null if this object represents<br>     *          a primitive type or void.<br>     * @since   JDK1.1<br>     */<br>    public native Object[] getSigners();</p><p>    /**<br>     * Set the signers of this class.<br>     */<br>    native void setSigners(Object[] signers);</p><p>    /**<br>     * If this {@code Class} object represents a local or anonymous<br>     * class within a method, returns a {@link<br>     * java.lang.reflect.Method Method} object representing the<br>     * immediately enclosing method of the underlying class. Returns<br>     * {@code null} otherwise.<br>     *<br>     * In particular, this method returns {@code null} if the underlying<br>     * class is a local or anonymous class immediately enclosed by a type<br>     * declaration, instance initializer or static initializer.<br>     *<br>     * @return the immediately enclosing method of the underlying class, if<br>     *     that class is a local or anonymous class; otherwise {@code null}.<br>     *<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and any of the<br>     *         following conditions is met:<br>     *<br>     *         <ul><br>     *<br>     *         <li> the caller’s class loader is not the same as the<br>     *         class loader of the enclosing class and invocation of<br>     *         {@link SecurityManager#checkPermission<br>     *         s.checkPermission} method with<br>     *         {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *         denies access to the methods within the enclosing class<br>     *<br>     *         <li> the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the enclosing class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of the enclosing class<br>     *<br>     *         </ul><br>     * @since 1.5<br>     */<br>    @CallerSensitive<br>    public Method getEnclosingMethod() throws SecurityException {<br>        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();</p><p>        if (enclosingInfo == null)<br>            return null;<br>        else {<br>            if (!enclosingInfo.isMethod())<br>                return null;</p><p>            MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),<br>                                                              getFactory());<br>            Class<?>   returnType       = toClass(typeInfo.getReturnType());            Type []    parameterTypes   = typeInfo.getParameterTypes();            Class<?>[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];</p><p>            // Convert Types to Classes; returned types <em>should</em><br>            // be class objects since the methodDescriptor’s used<br>            // don’t have generics information<br>            for(int i = 0; i &lt; parameterClasses.length; i++)<br>                parameterClasses[i] = toClass(parameterTypes[i]);</p><p>            // Perform access check<br>            Class<?> enclosingCandidate = enclosingInfo.getEnclosingClass();            enclosingCandidate.checkMemberAccess(Member.DECLARED,                                                 Reflection.getCallerClass(), true);            /*             * Loop over all declared methods; match method name,             * number of and type of parameters, *and* return             * type.  Matching return type is also necessary             * because of covariant returns, etc.             */            for(Method m: enclosingCandidate.getDeclaredMethods()) {                if (m.getName().equals(enclosingInfo.getName()) ) {                    Class<?>[] candidateParamClasses = m.getParameterTypes();<br>                    if (candidateParamClasses.length == parameterClasses.length) {<br>                        boolean matches = true;<br>                        for(int i = 0; i &lt; candidateParamClasses.length; i++) {<br>                            if (!candidateParamClasses[i].equals(parameterClasses[i])) {<br>                                matches = false;<br>                                break;<br>                            }<br>                        }</p><p>                        if (matches) { // finally, check return type<br>                            if (m.getReturnType().equals(returnType) )<br>                                return m;<br>                        }<br>                    }<br>                }<br>            }</p><p>            throw new InternalError(“Enclosing method not found”);<br>        }<br>    }</p><p>    private native Object[] getEnclosingMethod0();</p><p>    private EnclosingMethodInfo getEnclosingMethodInfo() {<br>        Object[] enclosingInfo = getEnclosingMethod0();<br>        if (enclosingInfo == null)<br>            return null;<br>        else {<br>            return new EnclosingMethodInfo(enclosingInfo);<br>        }<br>    }</p><p>    private final static class EnclosingMethodInfo {<br>        private Class&lt;?&gt; enclosingClass;<br>        private String name;<br>        private String descriptor;</p><p>        private EnclosingMethodInfo(Object[] enclosingInfo) {<br>            if (enclosingInfo.length != 3)<br>                throw new InternalError(“Malformed enclosing method information”);<br>            try {<br>                // The array is expected to have three elements:</p><p>                // the immediately enclosing class<br>                enclosingClass = (Class&lt;?&gt;) enclosingInfo[0];<br>                assert(enclosingClass != null);</p><p>                // the immediately enclosing method or constructor’s<br>                // name (can be null).<br>                name            = (String)   enclosingInfo[1];</p><p>                // the immediately enclosing method or constructor’s<br>                // descriptor (null iff name is).<br>                descriptor      = (String)   enclosingInfo[2];<br>                assert((name != null &amp;&amp; descriptor != null) || name == descriptor);<br>            } catch (ClassCastException cce) {<br>                throw new InternalError(“Invalid type in enclosing method information”, cce);<br>            }<br>        }</p><p>        boolean isPartial() {<br>            return enclosingClass == null || name == null || descriptor == null;<br>        }</p><p>        boolean isConstructor() { return !isPartial() &amp;&amp; “<init>“.equals(name); }</p><p>        boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !”<clinit>“.equals(name); }</p><p>        Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }</p><p>        String getName() { return name; }</p><p>        String getDescriptor() { return descriptor; }</p><p>    }</p><p>    private static Class<?> toClass(Type o) {        if (o instanceof GenericArrayType)            return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),                                     0)                .getClass();        return (Class<?>)o;<br>     }</p><p>    /**<br>     * If this {@code Class} object represents a local or anonymous<br>     * class within a constructor, returns a {@link<br>     * java.lang.reflect.Constructor Constructor} object representing<br>     * the immediately enclosing constructor of the underlying<br>     * class. Returns {@code null} otherwise.  In particular, this<br>     * method returns {@code null} if the underlying class is a local<br>     * or anonymous class immediately enclosed by a type declaration,<br>     * instance initializer or static initializer.<br>     *<br>     * @return the immediately enclosing constructor of the underlying class, if<br>     *     that class is a local or anonymous class; otherwise {@code null}.<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and any of the<br>     *         following conditions is met:<br>     *<br>     *         <ul><br>     *<br>     *         <li> the caller’s class loader is not the same as the<br>     *         class loader of the enclosing class and invocation of<br>     *         {@link SecurityManager#checkPermission<br>     *         s.checkPermission} method with<br>     *         {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *         denies access to the constructors within the enclosing class<br>     *<br>     *         <li> the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the enclosing class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of the enclosing class<br>     *<br>     *         </ul><br>     * @since 1.5<br>     */<br>    @CallerSensitive<br>    public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {<br>        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();</p><p>        if (enclosingInfo == null)<br>            return null;<br>        else {<br>            if (!enclosingInfo.isConstructor())<br>                return null;</p><p>            ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),<br>                                                                        getFactory());<br>            Type []    parameterTypes   = typeInfo.getParameterTypes();<br>            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];</p><p>            // Convert Types to Classes; returned types <em>should</em><br>            // be class objects since the methodDescriptor’s used<br>            // don’t have generics information<br>            for(int i = 0; i &lt; parameterClasses.length; i++)<br>                parameterClasses[i] = toClass(parameterTypes[i]);</p><p>            // Perform access check<br>            Class<?> enclosingCandidate = enclosingInfo.getEnclosingClass();            enclosingCandidate.checkMemberAccess(Member.DECLARED,                                                 Reflection.getCallerClass(), true);            /*             * Loop over all declared constructors; match number             * of and type of parameters.             */            for(Constructor<?> c: enclosingCandidate.getDeclaredConstructors()) {<br>                Class&lt;?&gt;[] candidateParamClasses = c.getParameterTypes();<br>                if (candidateParamClasses.length == parameterClasses.length) {<br>                    boolean matches = true;<br>                    for(int i = 0; i &lt; candidateParamClasses.length; i++) {<br>                        if (!candidateParamClasses[i].equals(parameterClasses[i])) {<br>                            matches = false;<br>                            break;<br>                        }<br>                    }</p><p>                    if (matches)<br>                        return c;<br>                }<br>            }</p><p>            throw new InternalError(“Enclosing constructor not found”);<br>        }<br>    }</p><p>    /**<br>     * If the class or interface represented by this {@code Class} object<br>     * is a member of another class, returns the {@code Class} object<br>     * representing the class in which it was declared.  This method returns<br>     * null if this class or interface is not a member of any other class.  If<br>     * this {@code Class} object represents an array class, a primitive<br>     * type, or void,then this method returns null.<br>     *<br>     * @return the declaring class for this class<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and the caller’s<br>     *         class loader is not the same as or an ancestor of the class<br>     *         loader for the declaring class and invocation of {@link<br>     *         SecurityManager#checkPackageAccess s.checkPackageAccess()}<br>     *         denies access to the package of the declaring class<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Class<?> getDeclaringClass() throws SecurityException {        final Class<?> candidate = getDeclaringClass0();</p><p>        if (candidate != null)<br>            candidate.checkPackageAccess(<br>                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);<br>        return candidate;<br>    }</p><p>    private native Class&lt;?&gt; getDeclaringClass0();</p><p>    /**<br>     * Returns the immediately enclosing class of the underlying<br>     * class.  If the underlying class is a top level class this<br>     * method returns {@code null}.<br>     * @return the immediately enclosing class of the underlying class<br>     * @exception  SecurityException<br>     *             If a security manager, <i>s</i>, is present and the caller’s<br>     *             class loader is not the same as or an ancestor of the class<br>     *             loader for the enclosing class and invocation of {@link<br>     *             SecurityManager#checkPackageAccess s.checkPackageAccess()}<br>     *             denies access to the package of the enclosing class<br>     * @since 1.5<br>     */<br>    @CallerSensitive<br>    public Class&lt;?&gt; getEnclosingClass() throws SecurityException {<br>        // There are five kinds of classes (or interfaces):<br>        // a) Top level classes<br>        // b) Nested classes (static member classes)<br>        // c) Inner classes (non-static member classes)<br>        // d) Local classes (named classes declared within a method)<br>        // e) Anonymous classes</p><p>        // JVM Spec 4.8.6: A class must have an EnclosingMethod<br>        // attribute if and only if it is a local class or an<br>        // anonymous class.<br>        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();<br>        Class&lt;?&gt; enclosingCandidate;</p><p>        if (enclosingInfo == null) {<br>            // This is a top level or a nested class or an inner class (a, b, or c)<br>            enclosingCandidate = getDeclaringClass();<br>        } else {<br>            Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();<br>            // This is a local class or an anonymous class (d or e)<br>            if (enclosingClass == this || enclosingClass == null)<br>                throw new InternalError(“Malformed enclosing method information”);<br>            else<br>                enclosingCandidate = enclosingClass;<br>        }</p><p>        if (enclosingCandidate != null)<br>            enclosingCandidate.checkPackageAccess(<br>                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);<br>        return enclosingCandidate;<br>    }</p><p>    /**<br>     * Returns the simple name of the underlying class as given in the<br>     * source code. Returns an empty string if the underlying class is<br>     * anonymous.<br>     *<br>     * <p>The simple name of an array is the simple name of the<br>     * component type with “[]” appended.  In particular the simple<br>     * name of an array whose component type is anonymous is “[]”.<br>     *<br>     * @return the simple name of the underlying class<br>     * @since 1.5<br>     */<br>    public String getSimpleName() {<br>        if (isArray())<br>            return getComponentType().getSimpleName()+”[]”;</p><p>        String simpleName = getSimpleBinaryName();<br>        if (simpleName == null) { // top level class<br>            simpleName = getName();<br>            return simpleName.substring(simpleName.lastIndexOf(“.”)+1); // strip the package name<br>        }<br>        // According to JLS3 “Binary Compatibility” (13.1) the binary<br>        // name of non-package classes (not top level) is the binary<br>        // name of the immediately enclosing class followed by a ‘$’ followed by:<br>        // (for nested and inner classes): the simple name.<br>        // (for local classes): 1 or more digits followed by the simple name.<br>        // (for anonymous classes): 1 or more digits.</p><p>        // Since getSimpleBinaryName() will strip the binary name of<br>        // the immediatly enclosing class, we are now looking at a<br>        // string that matches the regular expression “$[0-9]*”<br>        // followed by a simple name (considering the simple of an<br>        // anonymous class to be the empty string).</p><p>        // Remove leading “$[0-9]*” from the name<br>        int length = simpleName.length();<br>        if (length &lt; 1 || simpleName.charAt(0) != ‘$’)<br>            throw new InternalError(“Malformed class name”);<br>        int index = 1;<br>        while (index &lt; length &amp;&amp; isAsciiDigit(simpleName.charAt(index)))<br>            index++;<br>        // Eventually, this is the empty string iff this is an anonymous class<br>        return simpleName.substring(index);<br>    }</p><p>    /**<br>     * Return an informative string for the name of this type.<br>     *<br>     * @return an informative string for the name of this type<br>     * @since 1.8<br>     */<br>    public String getTypeName() {<br>        if (isArray()) {<br>            try {<br>                Class&lt;?&gt; cl = this;<br>                int dimensions = 0;<br>                while (cl.isArray()) {<br>                    dimensions++;<br>                    cl = cl.getComponentType();<br>                }<br>                StringBuilder sb = new StringBuilder();<br>                sb.append(cl.getName());<br>                for (int i = 0; i &lt; dimensions; i++) {<br>                    sb.append(“[]”);<br>                }<br>                return sb.toString();<br>            } catch (Throwable e) { /<em>FALLTHRU</em>/ }<br>        }<br>        return getName();<br>    }</p><p>    /**<br>     * Character.isDigit answers {@code true} to some non-ascii<br>     * digits.  This one does not.<br>     */<br>    private static boolean isAsciiDigit(char c) {<br>        return ‘0’ &lt;= c &amp;&amp; c &lt;= ‘9’;<br>    }</p><p>    /**<br>     * Returns the canonical name of the underlying class as<br>     * defined by the Java Language Specification.  Returns null if<br>     * the underlying class does not have a canonical name (i.e., if<br>     * it is a local or anonymous class or an array whose component<br>     * type does not have a canonical name).<br>     * @return the canonical name of the underlying class if it exists, and<br>     * {@code null} otherwise.<br>     * @since 1.5<br>     */<br>    public String getCanonicalName() {<br>        if (isArray()) {<br>            String canonicalName = getComponentType().getCanonicalName();<br>            if (canonicalName != null)<br>                return canonicalName + “[]”;<br>            else<br>                return null;<br>        }<br>        if (isLocalOrAnonymousClass())<br>            return null;<br>        Class&lt;?&gt; enclosingClass = getEnclosingClass();<br>        if (enclosingClass == null) { // top level class<br>            return getName();<br>        } else {<br>            String enclosingName = enclosingClass.getCanonicalName();<br>            if (enclosingName == null)<br>                return null;<br>            return enclosingName + “.” + getSimpleName();<br>        }<br>    }</p><p>    /**<br>     * Returns {@code true} if and only if the underlying class<br>     * is an anonymous class.<br>     *<br>     * @return {@code true} if and only if this class is an anonymous class.<br>     * @since 1.5<br>     */<br>    public boolean isAnonymousClass() {<br>        return “”.equals(getSimpleName());<br>    }</p><p>    /**<br>     * Returns {@code true} if and only if the underlying class<br>     * is a local class.<br>     *<br>     * @return {@code true} if and only if this class is a local class.<br>     * @since 1.5<br>     */<br>    public boolean isLocalClass() {<br>        return isLocalOrAnonymousClass() &amp;&amp; !isAnonymousClass();<br>    }</p><p>    /**<br>     * Returns {@code true} if and only if the underlying class<br>     * is a member class.<br>     *<br>     * @return {@code true} if and only if this class is a member class.<br>     * @since 1.5<br>     */<br>    public boolean isMemberClass() {<br>        return getSimpleBinaryName() != null &amp;&amp; !isLocalOrAnonymousClass();<br>    }</p><p>    /**<br>     * Returns the “simple binary name” of the underlying class, i.e.,<br>     * the binary name without the leading enclosing class name.<br>     * Returns {@code null} if the underlying class is a top level<br>     * class.<br>     */<br>    private String getSimpleBinaryName() {<br>        Class&lt;?&gt; enclosingClass = getEnclosingClass();<br>        if (enclosingClass == null) // top level class<br>            return null;<br>        // Otherwise, strip the enclosing class’ name<br>        try {<br>            return getName().substring(enclosingClass.getName().length());<br>        } catch (IndexOutOfBoundsException ex) {<br>            throw new InternalError(“Malformed class name”, ex);<br>        }<br>    }</p><p>    /**<br>     * Returns {@code true} if this is a local class or an anonymous<br>     * class.  Returns {@code false} otherwise.<br>     */<br>    private boolean isLocalOrAnonymousClass() {<br>        // JVM Spec 4.8.6: A class must have an EnclosingMethod<br>        // attribute if and only if it is a local class or an<br>        // anonymous class.<br>        return getEnclosingMethodInfo() != null;<br>    }</p><p>    /**<br>     * Returns an array containing {@code Class} objects representing all<br>     * the public classes and interfaces that are members of the class<br>     * represented by this {@code Class} object.  This includes public<br>     * class and interface members inherited from superclasses and public class<br>     * and interface members declared by the class.  This method returns an<br>     * array of length 0 if this {@code Class} object has no public member<br>     * classes or interfaces.  This method also returns an array of length 0 if<br>     * this {@code Class} object represents a primitive type, an array<br>     * class, or void.<br>     *<br>     * @return the array of {@code Class} objects representing the public<br>     *         members of this class<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Class&lt;?&gt;[] getClasses() {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);</p><p>        // Privileged so this implementation can look at DECLARED classes,<br>        // something the caller might not have privilege to do.  The code here<br>        // is allowed to look at DECLARED classes because (1) it does not hand<br>        // out anything other than public members and (2) public member access<br>        // has already been ok’d by the SecurityManager.</p><p>        return java.security.AccessController.doPrivileged(<br>            new java.security.PrivilegedAction&lt;Class<?>[]>() {                public Class<?>[] run() {<br>                    List&lt;Class<?>> list = new ArrayList<>();                    Class<?> currentClass = Class.this;<br>                    while (currentClass != null) {<br>                        Class<?>[] members = currentClass.getDeclaredClasses();                        for (int i = 0; i < members.length; i++) {                            if (Modifier.isPublic(members[i].getModifiers())) {                                list.add(members[i]);                            }                        }                        currentClass = currentClass.getSuperclass();                    }                    return list.toArray(new Class<?>[0]);<br>                }<br>            });<br>    }</p><p>    /**<br>     * Returns an array containing {@code Field} objects reflecting all<br>     * the accessible public fields of the class or interface represented by<br>     * this {@code Class} object.<br>     *<br>     * <p> If this {@code Class} object represents a class or interface with no<br>     * no accessible public fields, then this method returns an array of length<br>     * 0.<br>     *<br>     * <p> If this {@code Class} object represents a class, then this method<br>     * returns the public fields of the class and of all its superclasses.<br>     *<br>     * <p> If this {@code Class} object represents an interface, then this<br>     * method returns the fields of the interface and of all its<br>     * superinterfaces.<br>     *<br>     * <p> If this {@code Class} object represents an array type, a primitive<br>     * type, or void, then this method returns an array of length 0.<br>     *<br>     * <p> The elements in the returned array are not sorted and are not in any<br>     * particular order.<br>     *<br>     * @return the array of {@code Field} objects representing the<br>     *         public fields<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @since JDK1.1<br>     * @jls 8.2 Class Members<br>     * @jls 8.3 Field Declarations<br>     */<br>    @CallerSensitive<br>    public Field[] getFields() throws SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        return copyFields(privateGetPublicFields(null));<br>    }</p><p>    /**<br>     * Returns an array containing {@code Method} objects reflecting all the<br>     * public methods of the class or interface represented by this {@code<br>     * Class} object, including those declared by the class or interface and<br>     * those inherited from superclasses and superinterfaces.<br>     *<br>     * <p> If this {@code Class} object represents a type that has multiple<br>     * public methods with the same name and parameter types, but different<br>     * return types, then the returned array has a {@code Method} object for<br>     * each such method.<br>     *<br>     * <p> If this {@code Class} object represents a type with a class<br>     * initialization method {@code <clinit>}, then the returned array does<br>     * <em>not</em> have a corresponding {@code Method} object.<br>     *<br>     * <p> If this {@code Class} object represents an array type, then the<br>     * returned array has a {@code Method} object for each of the public<br>     * methods inherited by the array type from {@code Object}. It does not<br>     * contain a {@code Method} object for {@code clone()}.<br>     *<br>     * <p> If this {@code Class} object represents an interface then the<br>     * returned array does not contain any implicitly declared methods from<br>     * {@code Object}. Therefore, if no methods are explicitly declared in<br>     * this interface or any of its superinterfaces then the returned array<br>     * has length 0. (Note that a {@code Class} object which represents a class<br>     * always has public methods, inherited from {@code Object}.)<br>     *<br>     * <p> If this {@code Class} object represents a primitive type or void,<br>     * then the returned array has length 0.<br>     *<br>     * <p> Static methods declared in superinterfaces of the class or interface<br>     * represented by this {@code Class} object are not considered members of<br>     * the class or interface.<br>     *<br>     * <p> The elements in the returned array are not sorted and are not in any<br>     * particular order.<br>     *<br>     * @return the array of {@code Method} objects representing the<br>     *         public methods of this class<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @jls 8.2 Class Members<br>     * @jls 8.4 Method Declarations<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Method[] getMethods() throws SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        return copyMethods(privateGetPublicMethods());<br>    }</p><p>    /**<br>     * Returns an array containing {@code Constructor} objects reflecting<br>     * all the public constructors of the class represented by this<br>     * {@code Class} object.  An array of length 0 is returned if the<br>     * class has no public constructors, or if the class is an array class, or<br>     * if the class reflects a primitive type or void.<br>     *<br>     * Note that while this method returns an array of {@code<br>     * Constructor<T>} objects (that is an array of constructors from<br>     * this class), the return type of this method is {@code<br>     * Constructor<?>[]} and <em>not</em> {@code Constructor<T>[]} as     * might be expected.  This less informative return type is     * necessary since after being returned from this method, the     * array could be modified to hold {@code Constructor} objects for     * different classes, which would violate the type guarantees of     * {@code Constructor<T>[]}.     *     * @return the array of {@code Constructor} objects representing the     *         public constructors of this class     * @throws SecurityException     *         If a security manager, <i>s</i>, is present and     *         the caller's class loader is not the same as or an     *         ancestor of the class loader for the current class and     *         invocation of {@link SecurityManager#checkPackageAccess     *         s.checkPackageAccess()} denies access to the package     *         of this class.     *     * @since JDK1.1     */    @CallerSensitive    public Constructor<?>[] getConstructors() throws SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        return copyConstructors(privateGetDeclaredConstructors(true));<br>    }</p><p>    /**<br>     * Returns a {@code Field} object that reflects the specified public member<br>     * field of the class or interface represented by this {@code Class}<br>     * object. The {@code name} parameter is a {@code String} specifying the<br>     * simple name of the desired field.<br>     *<br>     * <p> The field to be reflected is determined by the algorithm that<br>     * follows.  Let C be the class or interface represented by this object:<br>     *<br>     * <OL><br>     * <LI> If C declares a public field with the name specified, that is the<br>     *      field to be reflected.</LI><br>     * <LI> If no field was found in step 1 above, this algorithm is applied<br>     *      recursively to each direct superinterface of C. The direct<br>     *      superinterfaces are searched in the order they were declared.</LI><br>     * <LI> If no field was found in steps 1 and 2 above, and C has a<br>     *      superclass S, then this algorithm is invoked recursively upon S.<br>     *      If C has no superclass, then a {@code NoSuchFieldException}<br>     *      is thrown.</LI><br>     * </OL><br>     *<br>     * <p> If this {@code Class} object represents an array type, then this<br>     * method does not find the {@code length} field of the array type.<br>     *<br>     * @param name the field name<br>     * @return the {@code Field} object of this class specified by<br>     *         {@code name}<br>     * @throws NoSuchFieldException if a field with the specified name is<br>     *         not found.<br>     * @throws NullPointerException if {@code name} is {@code null}<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @since JDK1.1<br>     * @jls 8.2 Class Members<br>     * @jls 8.3 Field Declarations<br>     */<br>    @CallerSensitive<br>    public Field getField(String name)<br>        throws NoSuchFieldException, SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        Field field = getField0(name);<br>        if (field == null) {<br>            throw new NoSuchFieldException(name);<br>        }<br>        return field;<br>    }</p><p>    /**<br>     * Returns a {@code Method} object that reflects the specified public<br>     * member method of the class or interface represented by this<br>     * {@code Class} object. The {@code name} parameter is a<br>     * {@code String} specifying the simple name of the desired method. The<br>     * {@code parameterTypes} parameter is an array of {@code Class}<br>     * objects that identify the method’s formal parameter types, in declared<br>     * order. If {@code parameterTypes} is {@code null}, it is<br>     * treated as if it were an empty array.<br>     *<br>     * <p> If the {@code name} is “{@code <init>}” or “{@code <clinit>}” a<br>     * {@code NoSuchMethodException} is raised. Otherwise, the method to<br>     * be reflected is determined by the algorithm that follows.  Let C be the<br>     * class or interface represented by this object:<br>     * <OL><br>     * <LI> C is searched for a <I>matching method</I>, as defined below. If a<br>     *      matching method is found, it is reflected.</LI><br>     * <LI> If no matching method is found by step 1 then:<br>     *   <OL TYPE="a"><br>     *   <LI> If C is a class other than {@code Object}, then this algorithm is<br>     *        invoked recursively on the superclass of C.</LI><br>     *   <LI> If C is the class {@code Object}, or if C is an interface, then<br>     *        the superinterfaces of C (if any) are searched for a matching<br>     *        method. If any such method is found, it is reflected.</LI><br>     *   </OL></LI><br>     * </OL><br>     *<br>     * <p> To find a matching method in a class or interface C:&nbsp; If C<br>     * declares exactly one public method with the specified name and exactly<br>     * the same formal parameter types, that is the method reflected. If more<br>     * than one such method is found in C, and one of these methods has a<br>     * return type that is more specific than any of the others, that method is<br>     * reflected; otherwise one of the methods is chosen arbitrarily.<br>     *<br>     * <p>Note that there may be more than one matching method in a<br>     * class because while the Java language forbids a class to<br>     * declare multiple methods with the same signature but different<br>     * return types, the Java virtual machine does not.  This<br>     * increased flexibility in the virtual machine can be used to<br>     * implement various language features.  For example, covariant<br>     * returns can be implemented with {@linkplain<br>     * java.lang.reflect.Method#isBridge bridge methods}; the bridge<br>     * method and the method being overridden would have the same<br>     * signature but different return types.<br>     *<br>     * <p> If this {@code Class} object represents an array type, then this<br>     * method does not find the {@code clone()} method.<br>     *<br>     * <p> Static methods declared in superinterfaces of the class or interface<br>     * represented by this {@code Class} object are not considered members of<br>     * the class or interface.<br>     *<br>     * @param name the name of the method<br>     * @param parameterTypes the list of parameters<br>     * @return the {@code Method} object that matches the specified<br>     *         {@code name} and {@code parameterTypes}<br>     * @throws NoSuchMethodException if a matching method is not found<br>     *         or if the name is “&lt;init&gt;”or “&lt;clinit&gt;”.<br>     * @throws NullPointerException if {@code name} is {@code null}<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @jls 8.2 Class Members<br>     * @jls 8.4 Method Declarations<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<br>        throws NoSuchMethodException, SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        Method method = getMethod0(name, parameterTypes, true);<br>        if (method == null) {<br>            throw new NoSuchMethodException(getName() + “.” + name + argumentTypesToString(parameterTypes));<br>        }<br>        return method;<br>    }</p><p>    /**<br>     * Returns a {@code Constructor} object that reflects the specified<br>     * public constructor of the class represented by this {@code Class}<br>     * object. The {@code parameterTypes} parameter is an array of<br>     * {@code Class} objects that identify the constructor’s formal<br>     * parameter types, in declared order.<br>     *<br>     * If this {@code Class} object represents an inner class<br>     * declared in a non-static context, the formal parameter types<br>     * include the explicit enclosing instance as the first parameter.<br>     *<br>     * <p> The constructor to reflect is the public constructor of the class<br>     * represented by this {@code Class} object whose formal parameter<br>     * types match those specified by {@code parameterTypes}.<br>     *<br>     * @param parameterTypes the parameter array<br>     * @return the {@code Constructor} object of the public constructor that<br>     *         matches the specified {@code parameterTypes}<br>     * @throws NoSuchMethodException if a matching method is not found.<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)<br>        throws NoSuchMethodException, SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        return getConstructor0(parameterTypes, Member.PUBLIC);<br>    }</p><p>    /**<br>     * Returns an array of {@code Class} objects reflecting all the<br>     * classes and interfaces declared as members of the class represented by<br>     * this {@code Class} object. This includes public, protected, default<br>     * (package) access, and private classes and interfaces declared by the<br>     * class, but excludes inherited classes and interfaces.  This method<br>     * returns an array of length 0 if the class declares no classes or<br>     * interfaces as members, or if this {@code Class} object represents a<br>     * primitive type, an array class, or void.<br>     *<br>     * @return the array of {@code Class} objects representing all the<br>     *         declared members of this class<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and any of the<br>     *         following conditions is met:<br>     *<br>     *         <ul><br>     *<br>     *         <li> the caller’s class loader is not the same as the<br>     *         class loader of this class and invocation of<br>     *         {@link SecurityManager#checkPermission<br>     *         s.checkPermission} method with<br>     *         {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *         denies access to the declared classes within this class<br>     *<br>     *         <li> the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class<br>     *<br>     *         </ul><br>     *<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), false);<br>        return getDeclaredClasses0();<br>    }</p><p>    /**<br>     * Returns an array of {@code Field} objects reflecting all the fields<br>     * declared by the class or interface represented by this<br>     * {@code Class} object. This includes public, protected, default<br>     * (package) access, and private fields, but excludes inherited fields.<br>     *<br>     * <p> If this {@code Class} object represents a class or interface with no<br>     * declared fields, then this method returns an array of length 0.<br>     *<br>     * <p> If this {@code Class} object represents an array type, a primitive<br>     * type, or void, then this method returns an array of length 0.<br>     *<br>     * <p> The elements in the returned array are not sorted and are not in any<br>     * particular order.<br>     *<br>     * @return  the array of {@code Field} objects representing all the<br>     *          declared fields of this class<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared fields within this class<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @since JDK1.1<br>     * @jls 8.2 Class Members<br>     * @jls 8.3 Field Declarations<br>     */<br>    @CallerSensitive<br>    public Field[] getDeclaredFields() throws SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        return copyFields(privateGetDeclaredFields(false));<br>    }</p><p>    /**<br>     *<br>     * Returns an array containing {@code Method} objects reflecting all the<br>     * declared methods of the class or interface represented by this {@code<br>     * Class} object, including public, protected, default (package)<br>     * access, and private methods, but excluding inherited methods.<br>     *<br>     * <p> If this {@code Class} object represents a type that has multiple<br>     * declared methods with the same name and parameter types, but different<br>     * return types, then the returned array has a {@code Method} object for<br>     * each such method.<br>     *<br>     * <p> If this {@code Class} object represents a type that has a class<br>     * initialization method {@code <clinit>}, then the returned array does<br>     * <em>not</em> have a corresponding {@code Method} object.<br>     *<br>     * <p> If this {@code Class} object represents a class or interface with no<br>     * declared methods, then the returned array has length 0.<br>     *<br>     * <p> If this {@code Class} object represents an array type, a primitive<br>     * type, or void, then the returned array has length 0.<br>     *<br>     * <p> The elements in the returned array are not sorted and are not in any<br>     * particular order.<br>     *<br>     * @return  the array of {@code Method} objects representing all the<br>     *          declared methods of this class<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared methods within this class<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @jls 8.2 Class Members<br>     * @jls 8.4 Method Declarations<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Method[] getDeclaredMethods() throws SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        return copyMethods(privateGetDeclaredMethods(false));<br>    }</p><p>    /**<br>     * Returns an array of {@code Constructor} objects reflecting all the<br>     * constructors declared by the class represented by this<br>     * {@code Class} object. These are public, protected, default<br>     * (package) access, and private constructors.  The elements in the array<br>     * returned are not sorted and are not in any particular order.  If the<br>     * class has a default constructor, it is included in the returned array.<br>     * This method returns an array of length 0 if this {@code Class}<br>     * object represents an interface, a primitive type, an array class, or<br>     * void.<br>     *<br>     * <p> See <em>The Java Language Specification</em>, section 8.2.<br>     *<br>     * @return  the array of {@code Constructor} objects representing all the<br>     *          declared constructors of this class<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared constructors within this class<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        return copyConstructors(privateGetDeclaredConstructors(false));<br>    }</p><p>    /**<br>     * Returns a {@code Field} object that reflects the specified declared<br>     * field of the class or interface represented by this {@code Class}<br>     * object. The {@code name} parameter is a {@code String} that specifies<br>     * the simple name of the desired field.<br>     *<br>     * <p> If this {@code Class} object represents an array type, then this<br>     * method does not find the {@code length} field of the array type.<br>     *<br>     * @param name the name of the field<br>     * @return  the {@code Field} object for the specified field in this<br>     *          class<br>     * @throws  NoSuchFieldException if a field with the specified name is<br>     *          not found.<br>     * @throws  NullPointerException if {@code name} is {@code null}<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared field<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @since JDK1.1<br>     * @jls 8.2 Class Members<br>     * @jls 8.3 Field Declarations<br>     */<br>    @CallerSensitive<br>    public Field getDeclaredField(String name)<br>        throws NoSuchFieldException, SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        Field field = searchFields(privateGetDeclaredFields(false), name);<br>        if (field == null) {<br>            throw new NoSuchFieldException(name);<br>        }<br>        return field;<br>    }</p><p>    /**<br>     * Returns a {@code Method} object that reflects the specified<br>     * declared method of the class or interface represented by this<br>     * {@code Class} object. The {@code name} parameter is a<br>     * {@code String} that specifies the simple name of the desired<br>     * method, and the {@code parameterTypes} parameter is an array of<br>     * {@code Class} objects that identify the method’s formal parameter<br>     * types, in declared order.  If more than one method with the same<br>     * parameter types is declared in a class, and one of these methods has a<br>     * return type that is more specific than any of the others, that method is<br>     * returned; otherwise one of the methods is chosen arbitrarily.  If the<br>     * name is “&lt;init&gt;”or “&lt;clinit&gt;” a {@code NoSuchMethodException}<br>     * is raised.<br>     *<br>     * <p> If this {@code Class} object represents an array type, then this<br>     * method does not find the {@code clone()} method.<br>     *<br>     * @param name the name of the method<br>     * @param parameterTypes the parameter array<br>     * @return  the {@code Method} object for the method of this class<br>     *          matching the specified name and parameters<br>     * @throws  NoSuchMethodException if a matching method is not found.<br>     * @throws  NullPointerException if {@code name} is {@code null}<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared method<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @jls 8.2 Class Members<br>     * @jls 8.4 Method Declarations<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)<br>        throws NoSuchMethodException, SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);<br>        if (method == null) {<br>            throw new NoSuchMethodException(getName() + “.” + name + argumentTypesToString(parameterTypes));<br>        }<br>        return method;<br>    }</p><p>    /**<br>     * Returns a {@code Constructor} object that reflects the specified<br>     * constructor of the class or interface represented by this<br>     * {@code Class} object.  The {@code parameterTypes} parameter is<br>     * an array of {@code Class} objects that identify the constructor’s<br>     * formal parameter types, in declared order.<br>     *<br>     * If this {@code Class} object represents an inner class<br>     * declared in a non-static context, the formal parameter types<br>     * include the explicit enclosing instance as the first parameter.<br>     *<br>     * @param parameterTypes the parameter array<br>     * @return  The {@code Constructor} object for the constructor with the<br>     *          specified parameter list<br>     * @throws  NoSuchMethodException if a matching method is not found.<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared constructor<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)<br>        throws NoSuchMethodException, SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        return getConstructor0(parameterTypes, Member.DECLARED);<br>    }</p><p>    /**<br>     * Finds a resource with a given name.  The rules for searching resources<br>     * associated with a given class are implemented by the defining<br>     * {@linkplain ClassLoader class loader} of the class.  This method<br>     * delegates to this object’s class loader.  If this object was loaded by<br>     * the bootstrap class loader, the method delegates to {@link<br>     * ClassLoader#getSystemResourceAsStream}.<br>     *<br>     * <p> Before delegation, an absolute resource name is constructed from the<br>     * given resource name using this algorithm:<br>     *<br>     * <ul><br>     *<br>     * <li> If the {@code name} begins with a {@code ‘/‘}<br>     * (<tt>‘&#92;u002f’</tt>), then the absolute name of the resource is the<br>     * portion of the {@code name} following the {@code ‘/‘}.<br>     *<br>     * <li> Otherwise, the absolute name is of the following form:<br>     *<br>     * <blockquote><br>     *   {@code modified_package_name/name}<br>     * </blockquote><br>     *<br>     * <p> Where the {@code modified_package_name} is the package name of this<br>     * object with {@code ‘/‘} substituted for {@code ‘.’}<br>     * (<tt>‘&#92;u002e’</tt>).<br>     *<br>     * </ul><br>     *<br>     * @param  name name of the desired resource<br>     * @return      A {@link java.io.InputStream} object or {@code null} if<br>     *              no resource with this name is found<br>     * @throws  NullPointerException If {@code name} is {@code null}<br>     * @since  JDK1.1<br>     */<br>     public InputStream getResourceAsStream(String name) {<br>        name = resolveName(name);<br>        ClassLoader cl = getClassLoader0();<br>        if (cl==null) {<br>            // A system class.<br>            return ClassLoader.getSystemResourceAsStream(name);<br>        }<br>        return cl.getResourceAsStream(name);<br>    }</p><p>    /**<br>     * Finds a resource with a given name.  The rules for searching resources<br>     * associated with a given class are implemented by the defining<br>     * {@linkplain ClassLoader class loader} of the class.  This method<br>     * delegates to this object’s class loader.  If this object was loaded by<br>     * the bootstrap class loader, the method delegates to {@link<br>     * ClassLoader#getSystemResource}.<br>     *<br>     * <p> Before delegation, an absolute resource name is constructed from the<br>     * given resource name using this algorithm:<br>     *<br>     * <ul><br>     *<br>     * <li> If the {@code name} begins with a {@code ‘/‘}<br>     * (<tt>‘&#92;u002f’</tt>), then the absolute name of the resource is the<br>     * portion of the {@code name} following the {@code ‘/‘}.<br>     *<br>     * <li> Otherwise, the absolute name is of the following form:<br>     *<br>     * <blockquote><br>     *   {@code modified_package_name/name}<br>     * </blockquote><br>     *<br>     * <p> Where the {@code modified_package_name} is the package name of this<br>     * object with {@code ‘/‘} substituted for {@code ‘.’}<br>     * (<tt>‘&#92;u002e’</tt>).<br>     *<br>     * </ul><br>     *<br>     * @param  name name of the desired resource<br>     * @return      A  {@link java.net.URL} object or {@code null} if no<br>     *              resource with this name is found<br>     * @since  JDK1.1<br>     */<br>    public java.net.URL getResource(String name) {<br>        name = resolveName(name);<br>        ClassLoader cl = getClassLoader0();<br>        if (cl==null) {<br>            // A system class.<br>            return ClassLoader.getSystemResource(name);<br>        }<br>        return cl.getResource(name);<br>    }</p><p>    /** protection domain returned when the internal domain is null */<br>    private static java.security.ProtectionDomain allPermDomain;</p><p>    /**<br>     * Returns the {@code ProtectionDomain} of this class.  If there is a<br>     * security manager installed, this method first calls the security<br>     * manager’s {@code checkPermission} method with a<br>     * {@code RuntimePermission(“getProtectionDomain”)} permission to<br>     * ensure it’s ok to get the<br>     * {@code ProtectionDomain}.<br>     *<br>     * @return the ProtectionDomain of this class<br>     *<br>     * @throws SecurityException<br>     *        if a security manager exists and its<br>     *        {@code checkPermission} method doesn’t allow<br>     *        getting the ProtectionDomain.<br>     *<br>     * @see java.security.ProtectionDomain<br>     * @see SecurityManager#checkPermission<br>     * @see java.lang.RuntimePermission<br>     * @since 1.2<br>     */<br>    public java.security.ProtectionDomain getProtectionDomain() {<br>        SecurityManager sm = System.getSecurityManager();<br>        if (sm != null) {<br>            sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);<br>        }<br>        java.security.ProtectionDomain pd = getProtectionDomain0();<br>        if (pd == null) {<br>            if (allPermDomain == null) {<br>                java.security.Permissions perms =<br>                    new java.security.Permissions();<br>                perms.add(SecurityConstants.ALL_PERMISSION);<br>                allPermDomain =<br>                    new java.security.ProtectionDomain(null, perms);<br>            }<br>            pd = allPermDomain;<br>        }<br>        return pd;<br>    }</p><p>    /**<br>     * Returns the ProtectionDomain of this class.<br>     */<br>    private native java.security.ProtectionDomain getProtectionDomain0();</p><p>    /*<br>     * Return the Virtual Machine’s Class object for the named<br>     * primitive type.<br>     */<br>    static native Class&lt;?&gt; getPrimitiveClass(String name);</p><p>    /*<br>     * Check if client is allowed to access members.  If access is denied,<br>     * throw a SecurityException.<br>     *<br>     * This method also enforces package access.<br>     *<br>     * <p> Default policy: allow all clients access with normal Java access<br>     * control.<br>     <em>/<br>    private void checkMemberAccess(int which, Class&lt;?&gt; caller, boolean checkProxyInterfaces) {<br>        final SecurityManager s = System.getSecurityManager();<br>        if (s != null) {<br>            /</em> Default policy allows access to all {@link Member#PUBLIC} members,<br>             * as well as access to classes that have the same class loader as the caller.<br>             * In all other cases, it requires RuntimePermission(“accessDeclaredMembers”)<br>             * permission.<br>             */<br>            final ClassLoader ccl = ClassLoader.getClassLoader(caller);<br>            final ClassLoader cl = getClassLoader0();<br>            if (which != Member.PUBLIC) {<br>                if (ccl != cl) {<br>                    s.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);<br>                }<br>            }<br>            this.checkPackageAccess(ccl, checkProxyInterfaces);<br>        }<br>    }</p><p>    /*<br>     * Checks if a client loaded in ClassLoader ccl is allowed to access this<br>     * class under the current package access policy. If access is denied,<br>     * throw a SecurityException.<br>     */<br>    private void checkPackageAccess(final ClassLoader ccl, boolean checkProxyInterfaces) {<br>        final SecurityManager s = System.getSecurityManager();<br>        if (s != null) {<br>            final ClassLoader cl = getClassLoader0();</p><p>            if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {<br>                String name = this.getName();<br>                int i = name.lastIndexOf(‘.’);<br>                if (i != -1) {<br>                    // skip the package access check on a proxy class in default proxy package<br>                    String pkg = name.substring(0, i);<br>                    if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {<br>                        s.checkPackageAccess(pkg);<br>                    }<br>                }<br>            }<br>            // check package access on the proxy interfaces<br>            if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {<br>                ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());<br>            }<br>        }<br>    }</p><p>    /**<br>     * Add a package name prefix if the name is not absolute Remove leading “/“<br>     * if name is absolute<br>     */<br>    private String resolveName(String name) {<br>        if (name == null) {<br>            return name;<br>        }<br>        if (!name.startsWith(“/“)) {<br>            Class&lt;?&gt; c = this;<br>            while (c.isArray()) {<br>                c = c.getComponentType();<br>            }<br>            String baseName = c.getName();<br>            int index = baseName.lastIndexOf(‘.’);<br>            if (index != -1) {<br>                name = baseName.substring(0, index).replace(‘.’, ‘/‘)<br>                    +”/“+name;<br>            }<br>        } else {<br>            name = name.substring(1);<br>        }<br>        return name;<br>    }</p><p>    /**<br>     * Atomic operations support.<br>     */<br>    private static class Atomic {<br>        // initialize Unsafe machinery here, since we need to call Class.class instance method<br>        // and have to avoid calling it in the static initializer of the Class class…<br>        private static final Unsafe unsafe = Unsafe.getUnsafe();<br>        // offset of Class.reflectionData instance field<br>        private static final long reflectionDataOffset;<br>        // offset of Class.annotationType instance field<br>        private static final long annotationTypeOffset;<br>        // offset of Class.annotationData instance field<br>        private static final long annotationDataOffset;</p><p>        static {<br>            Field[] fields = Class.class.getDeclaredFields0(false); // bypass caches<br>            reflectionDataOffset = objectFieldOffset(fields, “reflectionData”);<br>            annotationTypeOffset = objectFieldOffset(fields, “annotationType”);<br>            annotationDataOffset = objectFieldOffset(fields, “annotationData”);<br>        }</p><p>        private static long objectFieldOffset(Field[] fields, String fieldName) {<br>            Field field = searchFields(fields, fieldName);<br>            if (field == null) {<br>                throw new Error(“No “ + fieldName + “ field found in java.lang.Class”);<br>            }<br>            return unsafe.objectFieldOffset(field);<br>        }</p><p>        static <T> boolean casReflectionData(Class&lt;?&gt; clazz,<br>                                             SoftReference&lt;ReflectionData<T>&gt; oldData,<br>                                             SoftReference&lt;ReflectionData<T>&gt; newData) {<br>            return unsafe.compareAndSwapObject(clazz, reflectionDataOffset, oldData, newData);<br>        }</p><p>        static <T> boolean casAnnotationType(Class&lt;?&gt; clazz,<br>                                             AnnotationType oldType,<br>                                             AnnotationType newType) {<br>            return unsafe.compareAndSwapObject(clazz, annotationTypeOffset, oldType, newType);<br>        }</p><p>        static <T> boolean casAnnotationData(Class&lt;?&gt; clazz,<br>                                             AnnotationData oldData,<br>                                             AnnotationData newData) {<br>            return unsafe.compareAndSwapObject(clazz, annotationDataOffset, oldData, newData);<br>        }<br>    }</p><p>    /**<br>     * Reflection support.<br>     */</p><p>    // Caches for certain reflective results<br>    private static boolean useCaches = true;</p><p>    // reflection data that might get invalidated when JVM TI RedefineClasses() is called<br>    private static class ReflectionData<T> {<br>        volatile Field[] declaredFields;<br>        volatile Field[] publicFields;<br>        volatile Method[] declaredMethods;<br>        volatile Method[] publicMethods;<br>        volatile Constructor<T>[] declaredConstructors;<br>        volatile Constructor<T>[] publicConstructors;<br>        // Intermediate results for getFields and getMethods<br>        volatile Field[] declaredPublicFields;<br>        volatile Method[] declaredPublicMethods;<br>        volatile Class&lt;?&gt;[] interfaces;</p><p>        // Value of classRedefinedCount when we created this ReflectionData instance<br>        final int redefinedCount;</p><p>        ReflectionData(int redefinedCount) {<br>            this.redefinedCount = redefinedCount;<br>        }<br>    }</p><p>    private volatile transient SoftReference&lt;ReflectionData<T>&gt; reflectionData;</p><p>    // Incremented by the VM on each call to JVM TI RedefineClasses()<br>    // that redefines this class or a superclass.<br>    private volatile transient int classRedefinedCount = 0;</p><p>    // Lazily create and cache ReflectionData<br>    private ReflectionData<T> reflectionData() {<br>        SoftReference&lt;ReflectionData<T>&gt; reflectionData = this.reflectionData;<br>        int classRedefinedCount = this.classRedefinedCount;<br>        ReflectionData<T> rd;<br>        if (useCaches &amp;&amp;<br>            reflectionData != null &amp;&amp;<br>            (rd = reflectionData.get()) != null &amp;&amp;<br>            rd.redefinedCount == classRedefinedCount) {<br>            return rd;<br>        }<br>        // else no SoftReference or cleared SoftReference or stale ReflectionData<br>        // -&gt; create and replace new instance<br>        return newReflectionData(reflectionData, classRedefinedCount);<br>    }</p><p>    private ReflectionData<T> newReflectionData(SoftReference&lt;ReflectionData<T>&gt; oldReflectionData,<br>                                                int classRedefinedCount) {<br>        if (!useCaches) return null;</p><p>        while (true) {<br>            ReflectionData<T> rd = new ReflectionData&lt;&gt;(classRedefinedCount);<br>            // try to CAS it…<br>            if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {<br>                return rd;<br>            }<br>            // else retry<br>            oldReflectionData = this.reflectionData;<br>            classRedefinedCount = this.classRedefinedCount;<br>            if (oldReflectionData != null &amp;&amp;<br>                (rd = oldReflectionData.get()) != null &amp;&amp;<br>                rd.redefinedCount == classRedefinedCount) {<br>                return rd;<br>            }<br>        }<br>    }</p><p>    // Generic signature handling<br>    private native String getGenericSignature0();</p><p>    // Generic info repository; lazily initialized<br>    private volatile transient ClassRepository genericInfo;</p><p>    // accessor for factory<br>    private GenericsFactory getFactory() {<br>        // create scope and factory<br>        return CoreReflectionFactory.make(this, ClassScope.make(this));<br>    }</p><p>    // accessor for generic info repository;<br>    // generic info is lazily initialized<br>    private ClassRepository getGenericInfo() {<br>        ClassRepository genericInfo = this.genericInfo;<br>        if (genericInfo == null) {<br>            String signature = getGenericSignature0();<br>            if (signature == null) {<br>                genericInfo = ClassRepository.NONE;<br>            } else {<br>                genericInfo = ClassRepository.make(signature, getFactory());<br>            }<br>            this.genericInfo = genericInfo;<br>        }<br>        return (genericInfo != ClassRepository.NONE) ? genericInfo : null;<br>    }</p><p>    // Annotations handling<br>    native byte[] getRawAnnotations();<br>    // Since 1.8<br>    native byte[] getRawTypeAnnotations();<br>    static byte[] getExecutableTypeAnnotationBytes(Executable ex) {<br>        return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);<br>    }</p><p>    native ConstantPool getConstantPool();</p><p>    //<br>    //<br>    // java.lang.reflect.Field handling<br>    //<br>    //</p><p>    // Returns an array of “root” fields. These Field objects must NOT<br>    // be propagated to the outside world, but must instead be copied<br>    // via ReflectionFactory.copyField.<br>    private Field[] privateGetDeclaredFields(boolean publicOnly) {<br>        checkInitted();<br>        Field[] res;<br>        ReflectionData<T> rd = reflectionData();<br>        if (rd != null) {<br>            res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;<br>            if (res != null) return res;<br>        }<br>        // No cached value available; request value from VM<br>        res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));<br>        if (rd != null) {<br>            if (publicOnly) {<br>                rd.declaredPublicFields = res;<br>            } else {<br>                rd.declaredFields = res;<br>            }<br>        }<br>        return res;<br>    }</p><p>    // Returns an array of “root” fields. These Field objects must NOT<br>    // be propagated to the outside world, but must instead be copied<br>    // via ReflectionFactory.copyField.<br>    private Field[] privateGetPublicFields(Set&lt;Class&lt;?&gt;&gt; traversedInterfaces) {<br>        checkInitted();<br>        Field[] res;<br>        ReflectionData<T> rd = reflectionData();<br>        if (rd != null) {<br>            res = rd.publicFields;<br>            if (res != null) return res;<br>        }</p><p>        // No cached value available; compute value recursively.<br>        // Traverse in correct order for getField().<br>        List<Field> fields = new ArrayList&lt;&gt;();<br>        if (traversedInterfaces == null) {<br>            traversedInterfaces = new HashSet&lt;&gt;();<br>        }</p><p>        // Local fields<br>        Field[] tmp = privateGetDeclaredFields(true);<br>        addAll(fields, tmp);</p><p>        // Direct superinterfaces, recursively<br>        for (Class&lt;?&gt; c : getInterfaces()) {<br>            if (!traversedInterfaces.contains(c)) {<br>                traversedInterfaces.add(c);<br>                addAll(fields, c.privateGetPublicFields(traversedInterfaces));<br>            }<br>        }</p><p>        // Direct superclass, recursively<br>        if (!isInterface()) {<br>            Class&lt;?&gt; c = getSuperclass();<br>            if (c != null) {<br>                addAll(fields, c.privateGetPublicFields(traversedInterfaces));<br>            }<br>        }</p><p>        res = new Field[fields.size()];<br>        fields.toArray(res);<br>        if (rd != null) {<br>            rd.publicFields = res;<br>        }<br>        return res;<br>    }</p><p>    private static void addAll(Collection<Field> c, Field[] o) {<br>        for (int i = 0; i &lt; o.length; i++) {<br>            c.add(o[i]);<br>        }<br>    }</p><p>    //<br>    //<br>    // java.lang.reflect.Constructor handling<br>    //<br>    //</p><p>    // Returns an array of “root” constructors. These Constructor<br>    // objects must NOT be propagated to the outside world, but must<br>    // instead be copied via ReflectionFactory.copyConstructor.<br>    private Constructor<T>[] privateGetDeclaredConstructors(boolean publicOnly) {<br>        checkInitted();<br>        Constructor<T>[] res;<br>        ReflectionData<T> rd = reflectionData();<br>        if (rd != null) {<br>            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;<br>            if (res != null) return res;<br>        }<br>        // No cached value available; request value from VM<br>        if (isInterface()) {<br>            @SuppressWarnings(“unchecked”)<br>            Constructor<T>[] temporaryRes = (Constructor<T>[]) new Constructor&lt;?&gt;[0];<br>            res = temporaryRes;<br>        } else {<br>            res = getDeclaredConstructors0(publicOnly);<br>        }<br>        if (rd != null) {<br>            if (publicOnly) {<br>                rd.publicConstructors = res;<br>            } else {<br>                rd.declaredConstructors = res;<br>            }<br>        }<br>        return res;<br>    }</p><p>    //<br>    //<br>    // java.lang.reflect.Method handling<br>    //<br>    //</p><p>    // Returns an array of “root” methods. These Method objects must NOT<br>    // be propagated to the outside world, but must instead be copied<br>    // via ReflectionFactory.copyMethod.<br>    private Method[] privateGetDeclaredMethods(boolean publicOnly) {<br>        checkInitted();<br>        Method[] res;<br>        ReflectionData<T> rd = reflectionData();<br>        if (rd != null) {<br>            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;<br>            if (res != null) return res;<br>        }<br>        // No cached value available; request value from VM<br>        res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));<br>        if (rd != null) {<br>            if (publicOnly) {<br>                rd.declaredPublicMethods = res;<br>            } else {<br>                rd.declaredMethods = res;<br>            }<br>        }<br>        return res;<br>    }</p><p>    static class MethodArray {<br>        // Don’t add or remove methods except by add() or remove() calls.<br>        private Method[] methods;<br>        private int length;<br>        private int defaults;</p><p>        MethodArray() {<br>            this(20);<br>        }</p><p>        MethodArray(int initialSize) {<br>            if (initialSize &lt; 2)<br>                throw new IllegalArgumentException(“Size should be 2 or more”);</p><p>            methods = new Method[initialSize];<br>            length = 0;<br>            defaults = 0;<br>        }</p><p>        boolean hasDefaults() {<br>            return defaults != 0;<br>        }</p><p>        void add(Method m) {<br>            if (length == methods.length) {<br>                methods = Arrays.copyOf(methods, 2 * methods.length);<br>            }<br>            methods[length++] = m;</p><p>            if (m != null &amp;&amp; m.isDefault())<br>                defaults++;<br>        }</p><p>        void addAll(Method[] ma) {<br>            for (int i = 0; i &lt; ma.length; i++) {<br>                add(ma[i]);<br>            }<br>        }</p><p>        void addAll(MethodArray ma) {<br>            for (int i = 0; i &lt; ma.length(); i++) {<br>                add(ma.get(i));<br>            }<br>        }</p><p>        void addIfNotPresent(Method newMethod) {<br>            for (int i = 0; i &lt; length; i++) {<br>                Method m = methods[i];<br>                if (m == newMethod || (m != null &amp;&amp; m.equals(newMethod))) {<br>                    return;<br>                }<br>            }<br>            add(newMethod);<br>        }</p><p>        void addAllIfNotPresent(MethodArray newMethods) {<br>            for (int i = 0; i &lt; newMethods.length(); i++) {<br>                Method m = newMethods.get(i);<br>                if (m != null) {<br>                    addIfNotPresent(m);<br>                }<br>            }<br>        }</p><p>        /* Add Methods declared in an interface to this MethodArray.<br>         * Static methods declared in interfaces are not inherited.<br>         */<br>        void addInterfaceMethods(Method[] methods) {<br>            for (Method candidate : methods) {<br>                if (!Modifier.isStatic(candidate.getModifiers())) {<br>                    add(candidate);<br>                }<br>            }<br>        }</p><p>        int length() {<br>            return length;<br>        }</p><p>        Method get(int i) {<br>            return methods[i];<br>        }</p><p>        Method getFirst() {<br>            for (Method m : methods)<br>                if (m != null)<br>                    return m;<br>            return null;<br>        }</p><p>        void removeByNameAndDescriptor(Method toRemove) {<br>            for (int i = 0; i &lt; length; i++) {<br>                Method m = methods[i];<br>                if (m != null &amp;&amp; matchesNameAndDescriptor(m, toRemove)) {<br>                    remove(i);<br>                }<br>            }<br>        }</p><p>        private void remove(int i) {<br>            if (methods[i] != null &amp;&amp; methods[i].isDefault())<br>                defaults–;<br>            methods[i] = null;<br>        }</p><p>        private boolean matchesNameAndDescriptor(Method m1, Method m2) {<br>            return m1.getReturnType() == m2.getReturnType() &amp;&amp;<br>                   m1.getName() == m2.getName() &amp;&amp; // name is guaranteed to be interned<br>                   arrayContentsEq(m1.getParameterTypes(),<br>                           m2.getParameterTypes());<br>        }</p><p>        void compactAndTrim() {<br>            int newPos = 0;<br>            // Get rid of null slots<br>            for (int pos = 0; pos &lt; length; pos++) {<br>                Method m = methods[pos];<br>                if (m != null) {<br>                    if (pos != newPos) {<br>                        methods[newPos] = m;<br>                    }<br>                    newPos++;<br>                }<br>            }<br>            if (newPos != methods.length) {<br>                methods = Arrays.copyOf(methods, newPos);<br>            }<br>        }</p><p>        /* Removes all Methods from this MethodArray that have a more specific<br>         * default Method in this MethodArray.<br>         *<br>         * Users of MethodArray are responsible for pruning Methods that have<br>         * a more specific <em>concrete</em> Method.<br>         */<br>        void removeLessSpecifics() {<br>            if (!hasDefaults())<br>                return;</p><p>            for (int i = 0; i &lt; length; i++) {<br>                Method m = get(i);<br>                if  (m == null || !m.isDefault())<br>                    continue;</p><p>                for (int j  = 0; j &lt; length; j++) {<br>                    if (i == j)<br>                        continue;</p><p>                    Method candidate = get(j);<br>                    if (candidate == null)<br>                        continue;</p><p>                    if (!matchesNameAndDescriptor(m, candidate))<br>                        continue;</p><p>                    if (hasMoreSpecificClass(m, candidate))<br>                        remove(j);<br>                }<br>            }<br>        }</p><p>        Method[] getArray() {<br>            return methods;<br>        }</p><p>        // Returns true if m1 is more specific than m2<br>        static boolean hasMoreSpecificClass(Method m1, Method m2) {<br>            Class<?> m1Class = m1.getDeclaringClass();            Class<?> m2Class = m2.getDeclaringClass();<br>            return m1Class != m2Class &amp;&amp; m2Class.isAssignableFrom(m1Class);<br>        }<br>    }</p><p>    // Returns an array of “root” methods. These Method objects must NOT<br>    // be propagated to the outside world, but must instead be copied<br>    // via ReflectionFactory.copyMethod.<br>    private Method[] privateGetPublicMethods() {<br>        checkInitted();<br>        Method[] res;<br>        ReflectionData<T> rd = reflectionData();<br>        if (rd != null) {<br>            res = rd.publicMethods;<br>            if (res != null) return res;<br>        }</p><p>        // No cached value available; compute value recursively.<br>        // Start by fetching public declared methods<br>        MethodArray methods = new MethodArray();<br>        {<br>            Method[] tmp = privateGetDeclaredMethods(true);<br>            methods.addAll(tmp);<br>        }<br>        // Now recur over superclass and direct superinterfaces.<br>        // Go over superinterfaces first so we can more easily filter<br>        // out concrete implementations inherited from superclasses at<br>        // the end.<br>        MethodArray inheritedMethods = new MethodArray();<br>        for (Class<?> i : getInterfaces()) {            inheritedMethods.addInterfaceMethods(i.privateGetPublicMethods());        }        if (!isInterface()) {            Class<?> c = getSuperclass();<br>            if (c != null) {<br>                MethodArray supers = new MethodArray();<br>                supers.addAll(c.privateGetPublicMethods());<br>                // Filter out concrete implementations of any<br>                // interface methods<br>                for (int i = 0; i &lt; supers.length(); i++) {<br>                    Method m = supers.get(i);<br>                    if (m != null &amp;&amp;<br>                            !Modifier.isAbstract(m.getModifiers()) &amp;&amp;<br>                            !m.isDefault()) {<br>                        inheritedMethods.removeByNameAndDescriptor(m);<br>                    }<br>                }<br>                // Insert superclass’s inherited methods before<br>                // superinterfaces’ to satisfy getMethod’s search<br>                // order<br>                supers.addAll(inheritedMethods);<br>                inheritedMethods = supers;<br>            }<br>        }<br>        // Filter out all local methods from inherited ones<br>        for (int i = 0; i &lt; methods.length(); i++) {<br>            Method m = methods.get(i);<br>            inheritedMethods.removeByNameAndDescriptor(m);<br>        }<br>        methods.addAllIfNotPresent(inheritedMethods);<br>        methods.removeLessSpecifics();<br>        methods.compactAndTrim();<br>        res = methods.getArray();<br>        if (rd != null) {<br>            rd.publicMethods = res;<br>        }<br>        return res;<br>    }</p><p>    //<br>    // Helpers for fetchers of one field, method, or constructor<br>    //</p><p>    private static Field searchFields(Field[] fields, String name) {<br>        String internedName = name.intern();<br>        for (int i = 0; i &lt; fields.length; i++) {<br>            if (fields[i].getName() == internedName) {<br>                return getReflectionFactory().copyField(fields[i]);<br>            }<br>        }<br>        return null;<br>    }</p><p>    private Field getField0(String name) throws NoSuchFieldException {<br>        // Note: the intent is that the search algorithm this routine<br>        // uses be equivalent to the ordering imposed by<br>        // privateGetPublicFields(). It fetches only the declared<br>        // public fields for each class, however, to reduce the number<br>        // of Field objects which have to be created for the common<br>        // case where the field being requested is declared in the<br>        // class which is being queried.<br>        Field res;<br>        // Search declared public fields<br>        if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {<br>            return res;<br>        }<br>        // Direct superinterfaces, recursively<br>        Class<?>[] interfaces = getInterfaces();        for (int i = 0; i < interfaces.length; i++) {            Class<?> c = interfaces[i];<br>            if ((res = c.getField0(name)) != null) {<br>                return res;<br>            }<br>        }<br>        // Direct superclass, recursively<br>        if (!isInterface()) {<br>            Class&lt;?&gt; c = getSuperclass();<br>            if (c != null) {<br>                if ((res = c.getField0(name)) != null) {<br>                    return res;<br>                }<br>            }<br>        }<br>        return null;<br>    }</p><p>    private static Method searchMethods(Method[] methods,<br>                                        String name,<br>                                        Class&lt;?&gt;[] parameterTypes)<br>    {<br>        Method res = null;<br>        String internedName = name.intern();<br>        for (int i = 0; i &lt; methods.length; i++) {<br>            Method m = methods[i];<br>            if (m.getName() == internedName<br>                &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())<br>                &amp;&amp; (res == null<br>                    || res.getReturnType().isAssignableFrom(m.getReturnType())))<br>                res = m;<br>        }</p><p>        return (res == null ? res : getReflectionFactory().copyMethod(res));<br>    }</p><p>    private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes, boolean includeStaticMethods) {<br>        MethodArray interfaceCandidates = new MethodArray(2);<br>        Method res =  privateGetMethodRecursive(name, parameterTypes, includeStaticMethods, interfaceCandidates);<br>        if (res != null)<br>            return res;</p><p>        // Not found on class or superclass directly<br>        interfaceCandidates.removeLessSpecifics();<br>        return interfaceCandidates.getFirst(); // may be null<br>    }</p><p>    private Method privateGetMethodRecursive(String name,<br>            Class&lt;?&gt;[] parameterTypes,<br>            boolean includeStaticMethods,<br>            MethodArray allInterfaceCandidates) {<br>        // Note: the intent is that the search algorithm this routine<br>        // uses be equivalent to the ordering imposed by<br>        // privateGetPublicMethods(). It fetches only the declared<br>        // public methods for each class, however, to reduce the<br>        // number of Method objects which have to be created for the<br>        // common case where the method being requested is declared in<br>        // the class which is being queried.<br>        //<br>        // Due to default methods, unless a method is found on a superclass,<br>        // methods declared in any superinterface needs to be considered.<br>        // Collect all candidates declared in superinterfaces in {@code<br>        // allInterfaceCandidates} and select the most specific if no match on<br>        // a superclass is found.</p><p>        // Must <em>not</em> return root methods<br>        Method res;<br>        // Search declared public methods<br>        if ((res = searchMethods(privateGetDeclaredMethods(true),<br>                                 name,<br>                                 parameterTypes)) != null) {<br>            if (includeStaticMethods || !Modifier.isStatic(res.getModifiers()))<br>                return res;<br>        }<br>        // Search superclass’s methods<br>        if (!isInterface()) {<br>            Class<? super T> c = getSuperclass();            if (c != null) {                if ((res = c.getMethod0(name, parameterTypes, true)) != null) {                    return res;                }            }        }        // Search superinterfaces' methods        Class<?>[] interfaces = getInterfaces();<br>        for (Class&lt;?&gt; c : interfaces)<br>            if ((res = c.getMethod0(name, parameterTypes, false)) != null)<br>                allInterfaceCandidates.add(res);<br>        // Not found<br>        return null;<br>    }</p><p>    private Constructor<T> getConstructor0(Class&lt;?&gt;[] parameterTypes,<br>                                        int which) throws NoSuchMethodException<br>    {<br>        Constructor<T>[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));<br>        for (Constructor<T> constructor : constructors) {<br>            if (arrayContentsEq(parameterTypes,<br>                                constructor.getParameterTypes())) {<br>                return getReflectionFactory().copyConstructor(constructor);<br>            }<br>        }<br>        throw new NoSuchMethodException(getName() + “.<init>“ + argumentTypesToString(parameterTypes));<br>    }</p><p>    //<br>    // Other helpers and base implementation<br>    //</p><p>    private static boolean arrayContentsEq(Object[] a1, Object[] a2) {<br>        if (a1 == null) {<br>            return a2 == null || a2.length == 0;<br>        }</p><p>        if (a2 == null) {<br>            return a1.length == 0;<br>        }</p><p>        if (a1.length != a2.length) {<br>            return false;<br>        }</p><p>        for (int i = 0; i &lt; a1.length; i++) {<br>            if (a1[i] != a2[i]) {<br>                return false;<br>            }<br>        }</p><p>        return true;<br>    }</p><p>    private static Field[] copyFields(Field[] arg) {<br>        Field[] out = new Field[arg.length];<br>        ReflectionFactory fact = getReflectionFactory();<br>        for (int i = 0; i &lt; arg.length; i++) {<br>            out[i] = fact.copyField(arg[i]);<br>        }<br>        return out;<br>    }</p><p>    private static Method[] copyMethods(Method[] arg) {<br>        Method[] out = new Method[arg.length];<br>        ReflectionFactory fact = getReflectionFactory();<br>        for (int i = 0; i &lt; arg.length; i++) {<br>            out[i] = fact.copyMethod(arg[i]);<br>        }<br>        return out;<br>    }</p><p>    private static <U> Constructor<U>[] copyConstructors(Constructor<U>[] arg) {<br>        Constructor<U>[] out = arg.clone();<br>        ReflectionFactory fact = getReflectionFactory();<br>        for (int i = 0; i &lt; out.length; i++) {<br>            out[i] = fact.copyConstructor(out[i]);<br>        }<br>        return out;<br>    }</p><p>    private native Field[]       getDeclaredFields0(boolean publicOnly);<br>    private native Method[]      getDeclaredMethods0(boolean publicOnly);<br>    private native Constructor<T>[] getDeclaredConstructors0(boolean publicOnly);<br>    private native Class&lt;?&gt;[]   getDeclaredClasses0();</p><p>    private static String        argumentTypesToString(Class<?>[] argTypes) {        StringBuilder buf = new StringBuilder();        buf.append("(");        if (argTypes != null) {            for (int i = 0; i < argTypes.length; i++) {                if (i > 0) {                    buf.append(", ");                }                Class<?> c = argTypes[i];<br>                buf.append((c == null) ? “null” : c.getName());<br>            }<br>        }<br>        buf.append(“)”);<br>        return buf.toString();<br>    }</p><p>    /** use serialVersionUID from JDK 1.1 for interoperability */<br>    private static final long serialVersionUID = 3206093459760846163L;</p><p>    /**<br>     * Class Class is special cased within the Serialization Stream Protocol.<br>     *<br>     * A Class instance is written initially into an ObjectOutputStream in the<br>     * following format:<br>     * <pre><br>     *      {@code TC_CLASS} ClassDescriptor<br>     *      A ClassDescriptor is a special cased serialization of<br>     *      a {@code java.io.ObjectStreamClass} instance.<br>     * </pre><br>     * A new handle is generated for the initial time the class descriptor<br>     * is written into the stream. Future references to the class descriptor<br>     * are written as references to the initial class descriptor instance.<br>     *<br>     * @see java.io.ObjectStreamClass<br>     */<br>    private static final ObjectStreamField[] serialPersistentFields =<br>        new ObjectStreamField[0];</p><p>    /**<br>     * Returns the assertion status that would be assigned to this<br>     * class if it were to be initialized at the time this method is invoked.<br>     * If this class has had its assertion status set, the most recent<br>     * setting will be returned; otherwise, if any package default assertion<br>     * status pertains to this class, the most recent setting for the most<br>     * specific pertinent package default assertion status is returned;<br>     * otherwise, if this class is not a system class (i.e., it has a<br>     * class loader) its class loader’s default assertion status is returned;<br>     * otherwise, the system class default assertion status is returned.<br>     * <p><br>     * Few programmers will have any need for this method; it is provided<br>     * for the benefit of the JRE itself.  (It allows a class to determine at<br>     * the time that it is initialized whether assertions should be enabled.)<br>     * Note that this method is not guaranteed to return the actual<br>     * assertion status that was (or will be) associated with the specified<br>     * class when it was (or will be) initialized.<br>     *<br>     * @return the desired assertion status of the specified class.<br>     * @see    java.lang.ClassLoader#setClassAssertionStatus<br>     * @see    java.lang.ClassLoader#setPackageAssertionStatus<br>     * @see    java.lang.ClassLoader#setDefaultAssertionStatus<br>     * @since  1.4<br>     */<br>    public boolean desiredAssertionStatus() {<br>        ClassLoader loader = getClassLoader();<br>        // If the loader is null this is a system class, so ask the VM<br>        if (loader == null)<br>            return desiredAssertionStatus0(this);</p><p>        // If the classloader has been initialized with the assertion<br>        // directives, ask it. Otherwise, ask the VM.<br>        synchronized(loader.assertionLock) {<br>            if (loader.classAssertionStatus != null) {<br>                return loader.desiredAssertionStatus(getName());<br>            }<br>        }<br>        return desiredAssertionStatus0(this);<br>    }</p><p>    // Retrieves the desired assertion status of this class from the VM<br>    private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);</p><p>    /**<br>     * Returns true if and only if this class was declared as an enum in the<br>     * source code.<br>     *<br>     * @return true if and only if this class was declared as an enum in the<br>     *     source code<br>     * @since 1.5<br>     */<br>    public boolean isEnum() {<br>        // An enum must both directly extend java.lang.Enum and have<br>        // the ENUM bit set; classes for specialized enum constants<br>        // don’t do the former.<br>        return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;<br>        this.getSuperclass() == java.lang.Enum.class;<br>    }</p><p>    // Fetches the factory for reflective objects<br>    private static ReflectionFactory getReflectionFactory() {<br>        if (reflectionFactory == null) {<br>            reflectionFactory =<br>                java.security.AccessController.doPrivileged<br>                    (new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());<br>        }<br>        return reflectionFactory;<br>    }<br>    private static ReflectionFactory reflectionFactory;</p><p>    // To be able to query system properties as soon as they’re available<br>    private static boolean initted = false;<br>    private static void checkInitted() {<br>        if (initted) return;<br>        AccessController.doPrivileged(new PrivilegedAction<Void>() {<br>                public Void run() {<br>                    // Tests to ensure the system properties table is fully<br>                    // initialized. This is needed because reflection code is<br>                    // called very early in the initialization process (before<br>                    // command-line arguments have been parsed and therefore<br>                    // these user-settable properties installed.) We assume that<br>                    // if System.out is non-null then the System class has been<br>                    // fully initialized and that the bulk of the startup code<br>                    // has been run.</p><p>                    if (System.out == null) {<br>                        // java.lang.System not yet fully initialized<br>                        return null;<br>                    }</p><p>                    // Doesn’t use Boolean.getBoolean to avoid class init.<br>                    String val =<br>                        System.getProperty(“sun.reflect.noCaches”);<br>                    if (val != null &amp;&amp; val.equals(“true”)) {<br>                        useCaches = false;<br>                    }</p><p>                    initted = true;<br>                    return null;<br>                }<br>            });<br>    }</p><p>    /**<br>     * Returns the elements of this enum class or null if this<br>     * Class object does not represent an enum type.<br>     *<br>     * @return an array containing the values comprising the enum class<br>     *     represented by this Class object in the order they’re<br>     *     declared, or null if this Class object does not<br>     *     represent an enum type<br>     * @since 1.5<br>     */<br>    public T[] getEnumConstants() {<br>        T[] values = getEnumConstantsShared();<br>        return (values != null) ? values.clone() : null;<br>    }</p><p>    /**<br>     * Returns the elements of this enum class or null if this<br>     * Class object does not represent an enum type;<br>     * identical to getEnumConstants except that the result is<br>     * uncloned, cached, and shared by all callers.<br>     */<br>    T[] getEnumConstantsShared() {<br>        if (enumConstants == null) {<br>            if (!isEnum()) return null;<br>            try {<br>                final Method values = getMethod(“values”);<br>                java.security.AccessController.doPrivileged(<br>                    new java.security.PrivilegedAction<Void>() {<br>                        public Void run() {<br>                                values.setAccessible(true);<br>                                return null;<br>                            }<br>                        });<br>                @SuppressWarnings(“unchecked”)<br>                T[] temporaryConstants = (T[])values.invoke(null);<br>                enumConstants = temporaryConstants;<br>            }<br>            // These can happen when users concoct enum-like classes<br>            // that don’t comply with the enum spec.<br>            catch (InvocationTargetException | NoSuchMethodException |<br>                   IllegalAccessException ex) { return null; }<br>        }<br>        return enumConstants;<br>    }<br>    private volatile transient T[] enumConstants = null;</p><p>    /**<br>     * Returns a map from simple name to enum constant.  This package-private<br>     * method is used internally by Enum to implement<br>     * {@code public static &lt;T extends Enum<T>&gt; T valueOf(Class<T>, String)}<br>     * efficiently.  Note that the map is returned by this method is<br>     * created lazily on first use.  Typically it won’t ever get created.<br>     */<br>    Map&lt;String, T&gt; enumConstantDirectory() {<br>        if (enumConstantDirectory == null) {<br>            T[] universe = getEnumConstantsShared();<br>            if (universe == null)<br>                throw new IllegalArgumentException(<br>                    getName() + “ is not an enum type”);<br>            Map&lt;String, T&gt; m = new HashMap&lt;&gt;(2 * universe.length);<br>            for (T constant : universe)<br>                m.put(((Enum&lt;?&gt;)constant).name(), constant);<br>            enumConstantDirectory = m;<br>        }<br>        return enumConstantDirectory;<br>    }<br>    private volatile transient Map&lt;String, T&gt; enumConstantDirectory = null;</p><p>    /**<br>     * Casts an object to the class or interface represented<br>     * by this {@code Class} object.<br>     *<br>     * @param obj the object to be cast<br>     * @return the object after casting, or null if obj is null<br>     *<br>     * @throws ClassCastException if the object is not<br>     * null and is not assignable to the type T.<br>     *<br>     * @since 1.5<br>     */<br>    @SuppressWarnings(“unchecked”)<br>    public T cast(Object obj) {<br>        if (obj != null &amp;&amp; !isInstance(obj))<br>            throw new ClassCastException(cannotCastMsg(obj));<br>        return (T) obj;<br>    }</p><p>    private String cannotCastMsg(Object obj) {<br>        return “Cannot cast “ + obj.getClass().getName() + “ to “ + getName();<br>    }</p><p>    /**<br>     * Casts this {@code Class} object to represent a subclass of the class<br>     * represented by the specified class object.  Checks that the cast<br>     * is valid, and throws a {@code ClassCastException} if it is not.  If<br>     * this method succeeds, it always returns a reference to this class object.<br>     *<br>     * <p>This method is useful when a client needs to “narrow” the type of<br>     * a {@code Class} object to pass it to an API that restricts the<br>     * {@code Class} objects that it is willing to accept.  A cast would<br>     * generate a compile-time warning, as the correctness of the cast<br>     * could not be checked at runtime (because generic types are implemented<br>     * by erasure).<br>     *<br>     * @param <U> the type to cast this class object to<br>     * @param clazz the class of the type to cast this class object to<br>     * @return this {@code Class} object, cast to represent a subclass of<br>     *    the specified class object.<br>     * @throws ClassCastException if this {@code Class} object does not<br>     *    represent a subclass of the specified class (here “subclass” includes<br>     *    the class itself).<br>     * @since 1.5<br>     */<br>    @SuppressWarnings(“unchecked”)<br>    public <U> Class&lt;? extends U&gt; asSubclass(Class<U> clazz) {<br>        if (clazz.isAssignableFrom(this))<br>            return (Class&lt;? extends U&gt;) this;<br>        else<br>            throw new ClassCastException(this.toString());<br>    }</p><p>    /**<br>     * @throws NullPointerException {@inheritDoc}<br>     * @since 1.5<br>     */<br>    @SuppressWarnings(“unchecked”)<br>    public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {<br>        Objects.requireNonNull(annotationClass);</p><p>        return (A) annotationData().annotations.get(annotationClass);<br>    }</p><p>    /**<br>     * {@inheritDoc}<br>     * @throws NullPointerException {@inheritDoc}<br>     * @since 1.5<br>     */<br>    @Override<br>    public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {<br>        return GenericDeclaration.super.isAnnotationPresent(annotationClass);<br>    }</p><p>    /**<br>     * @throws NullPointerException {@inheritDoc}<br>     * @since 1.8<br>     */<br>    @Override<br>    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationClass) {<br>        Objects.requireNonNull(annotationClass);</p><p>        AnnotationData annotationData = annotationData();<br>        return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,<br>                                                          this,<br>                                                          annotationClass);<br>    }</p><p>    /**<br>     * @since 1.5<br>     */<br>    public Annotation[] getAnnotations() {<br>        return AnnotationParser.toArray(annotationData().annotations);<br>    }</p><p>    /**<br>     * @throws NullPointerException {@inheritDoc}<br>     * @since 1.8<br>     */<br>    @Override<br>    @SuppressWarnings(“unchecked”)<br>    public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass) {<br>        Objects.requireNonNull(annotationClass);</p><p>        return (A) annotationData().declaredAnnotations.get(annotationClass);<br>    }</p><p>    /**<br>     * @throws NullPointerException {@inheritDoc}<br>     * @since 1.8<br>     */<br>    @Override<br>    public <A extends Annotation> A[] getDeclaredAnnotationsByType(Class<A> annotationClass) {<br>        Objects.requireNonNull(annotationClass);</p><p>        return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,<br>                                                                 annotationClass);<br>    }</p><p>    /**<br>     * @since 1.5<br>     */<br>    public Annotation[] getDeclaredAnnotations()  {<br>        return AnnotationParser.toArray(annotationData().declaredAnnotations);<br>    }</p><p>    // annotation data that might get invalidated when JVM TI RedefineClasses() is called<br>    private static class AnnotationData {<br>        final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;<br>        final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;</p><p>        // Value of classRedefinedCount when we created this AnnotationData instance<br>        final int redefinedCount;</p><p>        AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,<br>                       Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,<br>                       int redefinedCount) {<br>            this.annotations = annotations;<br>            this.declaredAnnotations = declaredAnnotations;<br>            this.redefinedCount = redefinedCount;<br>        }<br>    }</p><p>    // Annotations cache<br>    @SuppressWarnings(“UnusedDeclaration”)<br>    private volatile transient AnnotationData annotationData;</p><p>    private AnnotationData annotationData() {<br>        while (true) { // retry loop<br>            AnnotationData annotationData = this.annotationData;<br>            int classRedefinedCount = this.classRedefinedCount;<br>            if (annotationData != null &amp;&amp;<br>                annotationData.redefinedCount == classRedefinedCount) {<br>                return annotationData;<br>            }<br>            // null or stale annotationData -&gt; optimistically create new instance<br>            AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);<br>            // try to install it<br>            if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {<br>                // successfully installed new AnnotationData<br>                return newAnnotationData;<br>            }<br>        }<br>    }</p><p>    private AnnotationData createAnnotationData(int classRedefinedCount) {<br>        Map&lt;Class<? extends Annotation>, Annotation> declaredAnnotations =            AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);        Class<?> superClass = getSuperclass();<br>        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;<br>        if (superClass != null) {<br>            Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =<br>                superClass.annotationData().annotations;<br>            for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {<br>                Class&lt;? extends Annotation&gt; annotationClass = e.getKey();<br>                if (AnnotationType.getInstance(annotationClass).isInherited()) {<br>                    if (annotations == null) { // lazy construction<br>                        annotations = new LinkedHashMap&lt;&gt;((Math.max(<br>                                declaredAnnotations.size(),<br>                                Math.min(12, declaredAnnotations.size() + superAnnotations.size())<br>                            ) * 4 + 2) / 3<br>                        );<br>                    }<br>                    annotations.put(annotationClass, e.getValue());<br>                }<br>            }<br>        }<br>        if (annotations == null) {<br>            // no inherited annotations -&gt; share the Map with declaredAnnotations<br>            annotations = declaredAnnotations;<br>        } else {<br>            // at least one inherited annotation -&gt; declared may override inherited<br>            annotations.putAll(declaredAnnotations);<br>        }<br>        return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);<br>    }</p><p>    // Annotation types cache their internal (AnnotationType) form</p><p>    @SuppressWarnings(“UnusedDeclaration”)<br>    private volatile transient AnnotationType annotationType;</p><p>    boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {<br>        return Atomic.casAnnotationType(this, oldType, newType);<br>    }</p><p>    AnnotationType getAnnotationType() {<br>        return annotationType;<br>    }</p><p>    Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {<br>        return annotationData().declaredAnnotations;<br>    }</p><p>    /* Backing store of user-defined values pertaining to this class.<br>     * Maintained by the ClassValue class.<br>     */<br>    transient ClassValue.ClassValueMap classValueMap;</p><p>    /**<br>     * Returns an {@code AnnotatedType} object that represents the use of a<br>     * type to specify the superclass of the entity represented by this {@code<br>     * Class} object. (The <em>use</em> of type Foo to specify the superclass<br>     * in ‘…  extends Foo’ is distinct from the <em>declaration</em> of type<br>     * Foo.)<br>     *<br>     * <p> If this {@code Class} object represents a type whose declaration<br>     * does not explicitly indicate an annotated superclass, then the return<br>     * value is an {@code AnnotatedType} object representing an element with no<br>     * annotations.<br>     *<br>     * <p> If this {@code Class} represents either the {@code Object} class, an<br>     * interface type, an array type, a primitive type, or void, the return<br>     * value is {@code null}.<br>     *<br>     * @return an object representing the superclass<br>     * @since 1.8<br>     */<br>    public AnnotatedType getAnnotatedSuperclass() {<br>        if (this == Object.class ||<br>                isInterface() ||<br>                isArray() ||<br>                isPrimitive() ||<br>                this == Void.TYPE) {<br>            return null;<br>        }</p><p>        return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);<br>    }</p><p>    /**<br>     * Returns an array of {@code AnnotatedType} objects that represent the use<br>     * of types to specify superinterfaces of the entity represented by this<br>     * {@code Class} object. (The <em>use</em> of type Foo to specify a<br>     * superinterface in ‘… implements Foo’ is distinct from the<br>     * <em>declaration</em> of type Foo.)<br>     *<br>     * <p> If this {@code Class} object represents a class, the return value is<br>     * an array containing objects representing the uses of interface types to<br>     * specify interfaces implemented by the class. The order of the objects in<br>     * the array corresponds to the order of the interface types used in the<br>     * ‘implements’ clause of the declaration of this {@code Class} object.<br>     *<br>     * <p> If this {@code Class} object represents an interface, the return<br>     * value is an array containing objects representing the uses of interface<br>     * types to specify interfaces directly extended by the interface. The<br>     * order of the objects in the array corresponds to the order of the<br>     * interface types used in the ‘extends’ clause of the declaration of this<br>     * {@code Class} object./*</p><ul><li>Copyright (c) 1994, 2014, Oracle and/or its affiliates. All rights reserved.</li><li>ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li>/</li></ul><p>package java.lang;</p><p>import java.lang.reflect.AnnotatedElement;<br>import java.lang.reflect.Array;<br>import java.lang.reflect.GenericArrayType;<br>import java.lang.reflect.GenericDeclaration;<br>import java.lang.reflect.Member;<br>import java.lang.reflect.Field;<br>import java.lang.reflect.Executable;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Constructor;<br>import java.lang.reflect.Modifier;<br>import java.lang.reflect.Type;<br>import java.lang.reflect.TypeVariable;<br>import java.lang.reflect.InvocationTargetException;<br>import java.lang.reflect.AnnotatedType;<br>import java.lang.ref.SoftReference;<br>import java.io.InputStream;<br>import java.io.ObjectStreamField;<br>import java.security.AccessController;<br>import java.security.PrivilegedAction;<br>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.Collection;<br>import java.util.HashSet;<br>import java.util.LinkedHashMap;<br>import java.util.List;<br>import java.util.Set;<br>import java.util.Map;<br>import java.util.HashMap;<br>import java.util.Objects;<br>import sun.misc.Unsafe;<br>import sun.reflect.CallerSensitive;<br>import sun.reflect.ConstantPool;<br>import sun.reflect.Reflection;<br>import sun.reflect.ReflectionFactory;<br>import sun.reflect.generics.factory.CoreReflectionFactory;<br>import sun.reflect.generics.factory.GenericsFactory;<br>import sun.reflect.generics.repository.ClassRepository;<br>import sun.reflect.generics.repository.MethodRepository;<br>import sun.reflect.generics.repository.ConstructorRepository;<br>import sun.reflect.generics.scope.ClassScope;<br>import sun.security.util.SecurityConstants;<br>import java.lang.annotation.Annotation;<br>import java.lang.reflect.Proxy;<br>import sun.reflect.annotation.*;<br>import sun.reflect.misc.ReflectUtil;</p><p>/**</p><ul><li>Instances of the class {@code Class} represent classes and</li><li>interfaces in a running Java application.  An enum is a kind of</li><li>class and an annotation is a kind of interface.  Every array also</li><li>belongs to a class that is reflected as a {@code Class} object</li><li>that is shared by all arrays with the same element type and number</li><li>of dimensions.  The primitive Java types ({@code boolean},</li><li>{@code byte}, {@code char}, {@code short},</li><li>{@code int}, {@code long}, {@code float}, and</li><li>{@code double}), and the keyword {@code void} are also</li><li>represented as {@code Class} objects.</li><li></li><li><p> {@code Class} has no public constructor. Instead {@code Class}</li><li>objects are constructed automatically by the Java Virtual Machine as classes</li><li>are loaded and by calls to the {@code defineClass} method in the class</li><li>loader.</li><li></li><li><p> The following example uses a {@code Class} object to print the</li><li>class name of an object:</li><li></li><li><blockquote><pre></li><li>     void printClassName(Object obj) {</li><li>         System.out.println(“The class of “ + obj +</li><li>                            “ is “ + obj.getClass().getName());</li><li>     }</li><li></pre></blockquote></li><li></li><li><p> It is also possible to get the {@code Class} object for a named</li><li>type (or for void) using a class literal.  See Section 15.8.2 of</li><li><cite>The Java&trade; Language Specification</cite>.</li><li>For example:</li><li></li><li><blockquote></li><li>     {@code System.out.println(“The name of class Foo is: “+Foo.class.getName());}</li><li></blockquote></li><li></li><li>@param <T> the type of the class modeled by this {@code Class}</li><li>object.  For example, the type of {@code String.class} is {@code</li><li>Class<String>}.  Use {@code Class&lt;?&gt;} if the class being modeled is</li><li>unknown.</li><li></li><li>@author  unascribed</li><li>@see     java.lang.ClassLoader#defineClass(byte[], int, int)</li><li>@since   JDK1.0</li><li>/<br>public final class Class<T> implements java.io.Serializable,<br>                              GenericDeclaration,<br>                              Type,<br>                              AnnotatedElement {<br>    private static final int ANNOTATION= 0x00002000;<br>    private static final int ENUM      = 0x00004000;<br>    private static final int SYNTHETIC = 0x00001000;</li></ul><p>    private static native void registerNatives();<br>    static {<br>        registerNatives();<br>    }</p><p>    /*<br>     * Private constructor. Only the Java Virtual Machine creates Class objects.<br>     * This constructor is not used and prevents the default constructor being<br>     * generated.<br>     */<br>    private Class(ClassLoader loader) {<br>        // Initialize final field for classLoader.  The initialization value of non-null<br>        // prevents future JIT optimizations from assuming this final field is null.<br>        classLoader = loader;<br>    }</p><p>    /**<br>     * Converts the object to a string. The string representation is the<br>     * string “class” or “interface”, followed by a space, and then by the<br>     * fully qualified name of the class in the format returned by<br>     * {@code getName}.  If this {@code Class} object represents a<br>     * primitive type, this method returns the name of the primitive type.  If<br>     * this {@code Class} object represents void this method returns<br>     * “void”.<br>     *<br>     * @return a string representation of this class object.<br>     */<br>    public String toString() {<br>        return (isInterface() ? “interface “ : (isPrimitive() ? “” : “class “))<br>            + getName();<br>    }</p><p>    /**<br>     * Returns a string describing this {@code Class}, including<br>     * information about modifiers and type parameters.<br>     *<br>     * The string is formatted as a list of type modifiers, if any,<br>     * followed by the kind of type (empty string for primitive types<br>     * and {@code class}, {@code enum}, {@code interface}, or<br>     * <code>&#64;</code>{@code interface}, as appropriate), followed<br>     * by the type’s name, followed by an angle-bracketed<br>     * comma-separated list of the type’s type parameters, if any.<br>     *<br>     * A space is used to separate modifiers from one another and to<br>     * separate any modifiers from the kind of type. The modifiers<br>     * occur in canonical order. If there are no type parameters, the<br>     * type parameter list is elided.<br>     *<br>     * <p>Note that since information about the runtime representation<br>     * of a type is being generated, modifiers not present on the<br>     * originating source code or illegal on the originating source<br>     * code may be present.<br>     *<br>     * @return a string describing this {@code Class}, including<br>     * information about modifiers and type parameters<br>     *<br>     * @since 1.8<br>     */<br>    public String toGenericString() {<br>        if (isPrimitive()) {<br>            return toString();<br>        } else {<br>            StringBuilder sb = new StringBuilder();</p><p>            // Class modifiers are a superset of interface modifiers<br>            int modifiers = getModifiers() &amp; Modifier.classModifiers();<br>            if (modifiers != 0) {<br>                sb.append(Modifier.toString(modifiers));<br>                sb.append(‘ ‘);<br>            }</p><p>            if (isAnnotation()) {<br>                sb.append(‘@’);<br>            }<br>            if (isInterface()) { // Note: all annotation types are interfaces<br>                sb.append(“interface”);<br>            } else {<br>                if (isEnum())<br>                    sb.append(“enum”);<br>                else<br>                    sb.append(“class”);<br>            }<br>            sb.append(‘ ‘);<br>            sb.append(getName());</p><p>            TypeVariable<?>[] typeparms = getTypeParameters();            if (typeparms.length > 0) {                boolean first = true;                sb.append('<');                for(TypeVariable<?> typeparm: typeparms) {<br>                    if (!first)<br>                        sb.append(‘,’);<br>                    sb.append(typeparm.getTypeName());<br>                    first = false;<br>                }<br>                sb.append(‘&gt;’);<br>            }</p><p>            return sb.toString();<br>        }<br>    }</p><p>    /**<br>     * Returns the {@code Class} object associated with the class or<br>     * interface with the given string name.  Invoking this method is<br>     * equivalent to:<br>     *<br>     * <blockquote><br>     *  {@code Class.forName(className, true, currentLoader)}<br>     * </blockquote><br>     *<br>     * where {@code currentLoader} denotes the defining class loader of<br>     * the current class.<br>     *<br>     * <p> For example, the following code fragment returns the<br>     * runtime {@code Class} descriptor for the class named<br>     * {@code java.lang.Thread}:<br>     *<br>     * <blockquote><br>     *   {@code Class t = Class.forName(“java.lang.Thread”)}<br>     * </blockquote><br>     * <p><br>     * A call to {@code forName(“X”)} causes the class named<br>     * {@code X} to be initialized.<br>     *<br>     * @param      className   the fully qualified name of the desired class.<br>     * @return     the {@code Class} object for the class with the<br>     *             specified name.<br>     * @exception LinkageError if the linkage fails<br>     * @exception ExceptionInInitializerError if the initialization provoked<br>     *            by this method fails<br>     * @exception ClassNotFoundException if the class cannot be located<br>     */<br>    @CallerSensitive<br>    public static Class<?> forName(String className)                throws ClassNotFoundException {        Class<?> caller = Reflection.getCallerClass();<br>        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);<br>    }</p><p>    /**<br>     * Returns the {@code Class} object associated with the class or<br>     * interface with the given string name, using the given class loader.<br>     * Given the fully qualified name for a class or interface (in the same<br>     * format returned by {@code getName}) this method attempts to<br>     * locate, load, and link the class or interface.  The specified class<br>     * loader is used to load the class or interface.  If the parameter<br>     * {@code loader} is null, the class is loaded through the bootstrap<br>     * class loader.  The class is initialized only if the<br>     * {@code initialize} parameter is {@code true} and if it has<br>     * not been initialized earlier.<br>     *<br>     * <p> If {@code name} denotes a primitive type or void, an attempt<br>     * will be made to locate a user-defined class in the unnamed package whose<br>     * name is {@code name}. Therefore, this method cannot be used to<br>     * obtain any of the {@code Class} objects representing primitive<br>     * types or void.<br>     *<br>     * <p> If {@code name} denotes an array class, the component type of<br>     * the array class is loaded but not initialized.<br>     *<br>     * <p> For example, in an instance method the expression:<br>     *<br>     * <blockquote><br>     *  {@code Class.forName(“Foo”)}<br>     * </blockquote><br>     *<br>     * is equivalent to:<br>     *<br>     * <blockquote><br>     *  {@code Class.forName(“Foo”, true, this.getClass().getClassLoader())}<br>     * </blockquote><br>     *<br>     * Note that this method throws errors related to loading, linking or<br>     * initializing as specified in Sections 12.2, 12.3 and 12.4 of <em>The<br>     * Java Language Specification</em>.<br>     * Note that this method does not check whether the requested class<br>     * is accessible to its caller.<br>     *<br>     * <p> If the {@code loader} is {@code null}, and a security<br>     * manager is present, and the caller’s class loader is not null, then this<br>     * method calls the security manager’s {@code checkPermission} method<br>     * with a {@code RuntimePermission(“getClassLoader”)} permission to<br>     * ensure it’s ok to access the bootstrap class loader.<br>     *<br>     * @param name       fully qualified name of the desired class<br>     * @param initialize if {@code true} the class will be initialized.<br>     *                   See Section 12.4 of <em>The Java Language Specification</em>.<br>     * @param loader     class loader from which the class must be loaded<br>     * @return           class object representing the desired class<br>     *<br>     * @exception LinkageError if the linkage fails<br>     * @exception ExceptionInInitializerError if the initialization provoked<br>     *            by this method fails<br>     * @exception ClassNotFoundException if the class cannot be located by<br>     *            the specified class loader<br>     *<br>     * @see       java.lang.Class#forName(String)<br>     * @see       java.lang.ClassLoader<br>     * @since     1.2<br>     */<br>    @CallerSensitive<br>    public static Class<?> forName(String name, boolean initialize,                                   ClassLoader loader)        throws ClassNotFoundException    {        Class<?> caller = null;<br>        SecurityManager sm = System.getSecurityManager();<br>        if (sm != null) {<br>            // Reflective call to get caller class is only needed if a security manager<br>            // is present.  Avoid the overhead of making this call otherwise.<br>            caller = Reflection.getCallerClass();<br>            if (sun.misc.VM.isSystemDomainLoader(loader)) {<br>                ClassLoader ccl = ClassLoader.getClassLoader(caller);<br>                if (!sun.misc.VM.isSystemDomainLoader(ccl)) {<br>                    sm.checkPermission(<br>                        SecurityConstants.GET_CLASSLOADER_PERMISSION);<br>                }<br>            }<br>        }<br>        return forName0(name, initialize, loader, caller);<br>    }</p><p>    /** Called after security check for system loader access checks have been made. */<br>    private static native Class<?> forName0(String name, boolean initialize,                                            ClassLoader loader,                                            Class<?> caller)<br>        throws ClassNotFoundException;</p><p>    /**<br>     * Creates a new instance of the class represented by this {@code Class}<br>     * object.  The class is instantiated as if by a {@code new}<br>     * expression with an empty argument list.  The class is initialized if it<br>     * has not already been initialized.<br>     *<br>     * <p>Note that this method propagates any exception thrown by the<br>     * nullary constructor, including a checked exception.  Use of<br>     * this method effectively bypasses the compile-time exception<br>     * checking that would otherwise be performed by the compiler.<br>     * The {@link<br>     * java.lang.reflect.Constructor#newInstance(java.lang.Object…)<br>     * Constructor.newInstance} method avoids this problem by wrapping<br>     * any exception thrown by the constructor in a (checked) {@link<br>     * java.lang.reflect.InvocationTargetException}.<br>     *<br>     * @return  a newly allocated instance of the class represented by this<br>     *          object.<br>     * @throws  IllegalAccessException  if the class or its nullary<br>     *          constructor is not accessible.<br>     * @throws  InstantiationException<br>     *          if this {@code Class} represents an abstract class,<br>     *          an interface, an array class, a primitive type, or void;<br>     *          or if the class has no nullary constructor;<br>     *          or if the instantiation fails for some other reason.<br>     * @throws  ExceptionInInitializerError if the initialization<br>     *          provoked by this method fails.<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and<br>     *          the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class.<br>     */<br>    @CallerSensitive<br>    public T newInstance()<br>        throws InstantiationException, IllegalAccessException<br>    {<br>        if (System.getSecurityManager() != null) {<br>            checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);<br>        }</p><p>        // NOTE: the following code may not be strictly correct under<br>        // the current Java memory model.</p><p>        // Constructor lookup<br>        if (cachedConstructor == null) {<br>            if (this == Class.class) {<br>                throw new IllegalAccessException(<br>                    “Can not call newInstance() on the Class for java.lang.Class”<br>                );<br>            }<br>            try {<br>                Class<?>[] empty = {};                final Constructor<T> c = getConstructor0(empty, Member.DECLARED);                // Disable accessibility checks on the constructor                // since we have to do the security check here anyway                // (the stack depth is wrong for the Constructor's                // security check to work)                java.security.AccessController.doPrivileged(                    new java.security.PrivilegedAction<Void>() {                        public Void run() {                                c.setAccessible(true);                                return null;                            }                        });                cachedConstructor = c;            } catch (NoSuchMethodException e) {                throw (InstantiationException)                    new InstantiationException(getName()).initCause(e);            }        }        Constructor<T> tmpConstructor = cachedConstructor;        // Security check (same as in java.lang.reflect.Constructor)        int modifiers = tmpConstructor.getModifiers();        if (!Reflection.quickCheckMemberAccess(this, modifiers)) {            Class<?> caller = Reflection.getCallerClass();<br>            if (newInstanceCallerCache != caller) {<br>                Reflection.ensureMemberAccess(caller, this, null, modifiers);<br>                newInstanceCallerCache = caller;<br>            }<br>        }<br>        // Run constructor<br>        try {<br>            return tmpConstructor.newInstance((Object[])null);<br>        } catch (InvocationTargetException e) {<br>            Unsafe.getUnsafe().throwException(e.getTargetException());<br>            // Not reached<br>            return null;<br>        }<br>    }<br>    private volatile transient Constructor<T> cachedConstructor;<br>    private volatile transient Class&lt;?&gt;       newInstanceCallerCache;</p><p>    /**<br>     * Determines if the specified {@code Object} is assignment-compatible<br>     * with the object represented by this {@code Class}.  This method is<br>     * the dynamic equivalent of the Java language {@code instanceof}<br>     * operator. The method returns {@code true} if the specified<br>     * {@code Object} argument is non-null and can be cast to the<br>     * reference type represented by this {@code Class} object without<br>     * raising a {@code ClassCastException.} It returns {@code false}<br>     * otherwise.<br>     *<br>     * <p> Specifically, if this {@code Class} object represents a<br>     * declared class, this method returns {@code true} if the specified<br>     * {@code Object} argument is an instance of the represented class (or<br>     * of any of its subclasses); it returns {@code false} otherwise. If<br>     * this {@code Class} object represents an array class, this method<br>     * returns {@code true} if the specified {@code Object} argument<br>     * can be converted to an object of the array class by an identity<br>     * conversion or by a widening reference conversion; it returns<br>     * {@code false} otherwise. If this {@code Class} object<br>     * represents an interface, this method returns {@code true} if the<br>     * class or any superclass of the specified {@code Object} argument<br>     * implements this interface; it returns {@code false} otherwise. If<br>     * this {@code Class} object represents a primitive type, this method<br>     * returns {@code false}.<br>     *<br>     * @param   obj the object to check<br>     * @return  true if {@code obj} is an instance of this class<br>     *<br>     * @since JDK1.1<br>     */<br>    public native boolean isInstance(Object obj);</p><p>    /**<br>     * Determines if the class or interface represented by this<br>     * {@code Class} object is either the same as, or is a superclass or<br>     * superinterface of, the class or interface represented by the specified<br>     * {@code Class} parameter. It returns {@code true} if so;<br>     * otherwise it returns {@code false}. If this {@code Class}<br>     * object represents a primitive type, this method returns<br>     * {@code true} if the specified {@code Class} parameter is<br>     * exactly this {@code Class} object; otherwise it returns<br>     * {@code false}.<br>     *<br>     * <p> Specifically, this method tests whether the type represented by the<br>     * specified {@code Class} parameter can be converted to the type<br>     * represented by this {@code Class} object via an identity conversion<br>     * or via a widening reference conversion. See <em>The Java Language<br>     * Specification</em>, sections 5.1.1 and 5.1.4 , for details.<br>     *<br>     * @param cls the {@code Class} object to be checked<br>     * @return the {@code boolean} value indicating whether objects of the<br>     * type {@code cls} can be assigned to objects of this class<br>     * @exception NullPointerException if the specified Class parameter is<br>     *            null.<br>     * @since JDK1.1<br>     */<br>    public native boolean isAssignableFrom(Class&lt;?&gt; cls);</p><p>    /**<br>     * Determines if the specified {@code Class} object represents an<br>     * interface type.<br>     *<br>     * @return  {@code true} if this object represents an interface;<br>     *          {@code false} otherwise.<br>     */<br>    public native boolean isInterface();</p><p>    /**<br>     * Determines if this {@code Class} object represents an array class.<br>     *<br>     * @return  {@code true} if this object represents an array class;<br>     *          {@code false} otherwise.<br>     * @since   JDK1.1<br>     */<br>    public native boolean isArray();</p><p>    /**<br>     * Determines if the specified {@code Class} object represents a<br>     * primitive type.<br>     *<br>     * <p> There are nine predefined {@code Class} objects to represent<br>     * the eight primitive types and void.  These are created by the Java<br>     * Virtual Machine, and have the same names as the primitive types that<br>     * they represent, namely {@code boolean}, {@code byte},<br>     * {@code char}, {@code short}, {@code int},<br>     * {@code long}, {@code float}, and {@code double}.<br>     *<br>     * <p> These objects may only be accessed via the following public static<br>     * final variables, and are the only {@code Class} objects for which<br>     * this method returns {@code true}.<br>     *<br>     * @return true if and only if this class represents a primitive type<br>     *<br>     * @see     java.lang.Boolean#TYPE<br>     * @see     java.lang.Character#TYPE<br>     * @see     java.lang.Byte#TYPE<br>     * @see     java.lang.Short#TYPE<br>     * @see     java.lang.Integer#TYPE<br>     * @see     java.lang.Long#TYPE<br>     * @see     java.lang.Float#TYPE<br>     * @see     java.lang.Double#TYPE<br>     * @see     java.lang.Void#TYPE<br>     * @since JDK1.1<br>     */<br>    public native boolean isPrimitive();</p><p>    /**<br>     * Returns true if this {@code Class} object represents an annotation<br>     * type.  Note that if this method returns true, {@link #isInterface()}<br>     * would also return true, as all annotation types are also interfaces.<br>     *<br>     * @return {@code true} if this class object represents an annotation<br>     *      type; {@code false} otherwise<br>     * @since 1.5<br>     */<br>    public boolean isAnnotation() {<br>        return (getModifiers() &amp; ANNOTATION) != 0;<br>    }</p><p>    /**<br>     * Returns {@code true} if this class is a synthetic class;<br>     * returns {@code false} otherwise.<br>     * @return {@code true} if and only if this class is a synthetic class as<br>     *         defined by the Java Language Specification.<br>     * @jls 13.1 The Form of a Binary<br>     * @since 1.5<br>     */<br>    public boolean isSynthetic() {<br>        return (getModifiers() &amp; SYNTHETIC) != 0;<br>    }</p><p>    /**<br>     * Returns the  name of the entity (class, interface, array class,<br>     * primitive type, or void) represented by this {@code Class} object,<br>     * as a {@code String}.<br>     *<br>     * <p> If this class object represents a reference type that is not an<br>     * array type then the binary name of the class is returned, as specified<br>     * by<br>     * <cite>The Java&trade; Language Specification</cite>.<br>     *<br>     * <p> If this class object represents a primitive type or void, then the<br>     * name returned is a {@code String} equal to the Java language<br>     * keyword corresponding to the primitive type or void.<br>     *<br>     * <p> If this class object represents a class of arrays, then the internal<br>     * form of the name consists of the name of the element type preceded by<br>     * one or more ‘{@code [}’ characters representing the depth of the array<br>     * nesting.  The encoding of element type names is as follows:<br>     *<br>     * <blockquote><table summary="Element types and encodings"><br>     * <tr><th> Element Type <th> &nbsp;&nbsp;&nbsp; <th> Encoding<br>     * <tr><td> boolean      <td> &nbsp;&nbsp;&nbsp; <td align=center> Z<br>     * <tr><td> byte         <td> &nbsp;&nbsp;&nbsp; <td align=center> B<br>     * <tr><td> char         <td> &nbsp;&nbsp;&nbsp; <td align=center> C<br>     * <tr><td> class or interface<br>     *                       <td> &nbsp;&nbsp;&nbsp; <td align=center> L<i>classname</i>;<br>     * <tr><td> double       <td> &nbsp;&nbsp;&nbsp; <td align=center> D<br>     * <tr><td> float        <td> &nbsp;&nbsp;&nbsp; <td align=center> F<br>     * <tr><td> int          <td> &nbsp;&nbsp;&nbsp; <td align=center> I<br>     * <tr><td> long         <td> &nbsp;&nbsp;&nbsp; <td align=center> J<br>     * <tr><td> short        <td> &nbsp;&nbsp;&nbsp; <td align=center> S<br>     * </table></blockquote><br>     *<br>     * <p> The class or interface name <i>classname</i> is the binary name of<br>     * the class specified above.<br>     *<br>     * <p> Examples:<br>     * <blockquote><pre><br>     * String.class.getName()<br>     *     returns "java.lang.String"<br>     * byte.class.getName()<br>     *     returns "byte"<br>     * (new Object[3]).getClass().getName()<br>     *     returns "[Ljava.lang.Object;"<br>     * (new int[3][4][5][6][7][8][9]).getClass().getName()<br>     *     returns "[[[[[[[I"<br>     * </pre></blockquote><br>     *<br>     * @return  the name of the class or interface<br>     *          represented by this object.<br>     */<br>    public String getName() {<br>        String name = this.name;<br>        if (name == null)<br>            this.name = name = getName0();<br>        return name;<br>    }</p><p>    // cache the name to reduce the number of calls into the VM<br>    private transient String name;<br>    private native String getName0();</p><p>    /**<br>     * Returns the class loader for the class.  Some implementations may use<br>     * null to represent the bootstrap class loader. This method will return<br>     * null in such implementations if this class was loaded by the bootstrap<br>     * class loader.<br>     *<br>     * <p> If a security manager is present, and the caller’s class loader is<br>     * not null and the caller’s class loader is not the same as or an ancestor of<br>     * the class loader for the class whose class loader is requested, then<br>     * this method calls the security manager’s {@code checkPermission}<br>     * method with a {@code RuntimePermission(“getClassLoader”)}<br>     * permission to ensure it’s ok to access the class loader for the class.<br>     *<br>     * <p>If this object<br>     * represents a primitive type or void, null is returned.<br>     *<br>     * @return  the class loader that loaded the class or interface<br>     *          represented by this object.<br>     * @throws SecurityException<br>     *    if a security manager exists and its<br>     *    {@code checkPermission} method denies<br>     *    access to the class loader for the class.<br>     * @see java.lang.ClassLoader<br>     * @see SecurityManager#checkPermission<br>     * @see java.lang.RuntimePermission<br>     */<br>    @CallerSensitive<br>    public ClassLoader getClassLoader() {<br>        ClassLoader cl = getClassLoader0();<br>        if (cl == null)<br>            return null;<br>        SecurityManager sm = System.getSecurityManager();<br>        if (sm != null) {<br>            ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());<br>        }<br>        return cl;<br>    }</p><p>    // Package-private to allow ClassLoader access<br>    ClassLoader getClassLoader0() { return classLoader; }</p><p>    // Initialized in JVM not by private constructor<br>    // This field is filtered from reflection access, i.e. getDeclaredField<br>    // will throw NoSuchFieldException<br>    private final ClassLoader classLoader;</p><p>    /**<br>     * Returns an array of {@code TypeVariable} objects that represent the<br>     * type variables declared by the generic declaration represented by this<br>     * {@code GenericDeclaration} object, in declaration order.  Returns an<br>     * array of length 0 if the underlying generic declaration declares no type<br>     * variables.<br>     *<br>     * @return an array of {@code TypeVariable} objects that represent<br>     *     the type variables declared by this generic declaration<br>     * @throws java.lang.reflect.GenericSignatureFormatError if the generic<br>     *     signature of this generic declaration does not conform to<br>     *     the format specified in<br>     *     <cite>The Java&trade; Virtual Machine Specification</cite><br>     * @since 1.5<br>     */<br>    @SuppressWarnings(“unchecked”)<br>    public TypeVariable&lt;Class<T>&gt;[] getTypeParameters() {<br>        ClassRepository info = getGenericInfo();<br>        if (info != null)<br>            return (TypeVariable&lt;Class<T>&gt;[])info.getTypeParameters();<br>        else<br>            return (TypeVariable&lt;Class<T>&gt;[])new TypeVariable&lt;?&gt;[0];<br>    }</p><p>    /**<br>     * Returns the {@code Class} representing the superclass of the entity<br>     * (class, interface, primitive type or void) represented by this<br>     * {@code Class}.  If this {@code Class} represents either the<br>     * {@code Object} class, an interface, a primitive type, or void, then<br>     * null is returned.  If this object represents an array class then the<br>     * {@code Class} object representing the {@code Object} class is<br>     * returned.<br>     *<br>     * @return the superclass of the class represented by this object.<br>     */<br>    public native Class&lt;? super T&gt; getSuperclass();</p><p>    /**<br>     * Returns the {@code Type} representing the direct superclass of<br>     * the entity (class, interface, primitive type or void) represented by<br>     * this {@code Class}.<br>     *<br>     * <p>If the superclass is a parameterized type, the {@code Type}<br>     * object returned must accurately reflect the actual type<br>     * parameters used in the source code. The parameterized type<br>     * representing the superclass is created if it had not been<br>     * created before. See the declaration of {@link<br>     * java.lang.reflect.ParameterizedType ParameterizedType} for the<br>     * semantics of the creation process for parameterized types.  If<br>     * this {@code Class} represents either the {@code Object}<br>     * class, an interface, a primitive type, or void, then null is<br>     * returned.  If this object represents an array class then the<br>     * {@code Class} object representing the {@code Object} class is<br>     * returned.<br>     *<br>     * @throws java.lang.reflect.GenericSignatureFormatError if the generic<br>     *     class signature does not conform to the format specified in<br>     *     <cite>The Java&trade; Virtual Machine Specification</cite><br>     * @throws TypeNotPresentException if the generic superclass<br>     *     refers to a non-existent type declaration<br>     * @throws java.lang.reflect.MalformedParameterizedTypeException if the<br>     *     generic superclass refers to a parameterized type that cannot be<br>     *     instantiated  for any reason<br>     * @return the superclass of the class represented by this object<br>     * @since 1.5<br>     */<br>    public Type getGenericSuperclass() {<br>        ClassRepository info = getGenericInfo();<br>        if (info == null) {<br>            return getSuperclass();<br>        }</p><p>        // Historical irregularity:<br>        // Generic signature marks interfaces with superclass = Object<br>        // but this API returns null for interfaces<br>        if (isInterface()) {<br>            return null;<br>        }</p><p>        return info.getSuperclass();<br>    }</p><p>    /**<br>     * Gets the package for this class.  The class loader of this class is used<br>     * to find the package.  If the class was loaded by the bootstrap class<br>     * loader the set of packages loaded from CLASSPATH is searched to find the<br>     * package of the class. Null is returned if no package object was created<br>     * by the class loader of this class.<br>     *<br>     * <p> Packages have attributes for versions and specifications only if the<br>     * information was defined in the manifests that accompany the classes, and<br>     * if the class loader created the package instance with the attributes<br>     * from the manifest.<br>     *<br>     * @return the package of the class, or null if no package<br>     *         information is available from the archive or codebase.<br>     */<br>    public Package getPackage() {<br>        return Package.getPackage(this);<br>    }</p><p>    /**<br>     * Determines the interfaces implemented by the class or interface<br>     * represented by this object.<br>     *<br>     * <p> If this object represents a class, the return value is an array<br>     * containing objects representing all interfaces implemented by the<br>     * class. The order of the interface objects in the array corresponds to<br>     * the order of the interface names in the {@code implements} clause<br>     * of the declaration of the class represented by this object. For<br>     * example, given the declaration:<br>     * <blockquote><br>     * {@code class Shimmer implements FloorWax, DessertTopping { … }}<br>     * </blockquote><br>     * suppose the value of {@code s} is an instance of<br>     * {@code Shimmer}; the value of the expression:<br>     * <blockquote><br>     * {@code s.getClass().getInterfaces()[0]}<br>     * </blockquote><br>     * is the {@code Class} object that represents interface<br>     * {@code FloorWax}; and the value of:<br>     * <blockquote><br>     * {@code s.getClass().getInterfaces()[1]}<br>     * </blockquote><br>     * is the {@code Class} object that represents interface<br>     * {@code DessertTopping}.<br>     *<br>     * <p> If this object represents an interface, the array contains objects<br>     * representing all interfaces extended by the interface. The order of the<br>     * interface objects in the array corresponds to the order of the interface<br>     * names in the {@code extends} clause of the declaration of the<br>     * interface represented by this object.<br>     *<br>     * <p> If this object represents a class or interface that implements no<br>     * interfaces, the method returns an array of length 0.<br>     *<br>     * <p> If this object represents a primitive type or void, the method<br>     * returns an array of length 0.<br>     *<br>     * <p> If this {@code Class} object represents an array type, the<br>     * interfaces {@code Cloneable} and {@code java.io.Serializable} are<br>     * returned in that order.<br>     *<br>     * @return an array of interfaces implemented by this class.<br>     */<br>    public Class<?>[] getInterfaces() {        ReflectionData<T> rd = reflectionData();        if (rd == null) {            // no cloning required            return getInterfaces0();        } else {            Class<?>[] interfaces = rd.interfaces;<br>            if (interfaces == null) {<br>                interfaces = getInterfaces0();<br>                rd.interfaces = interfaces;<br>            }<br>            // defensively copy before handing over to user code<br>            return interfaces.clone();<br>        }<br>    }</p><p>    private native Class&lt;?&gt;[] getInterfaces0();</p><p>    /**<br>     * Returns the {@code Type}s representing the interfaces<br>     * directly implemented by the class or interface represented by<br>     * this object.<br>     *<br>     * <p>If a superinterface is a parameterized type, the<br>     * {@code Type} object returned for it must accurately reflect<br>     * the actual type parameters used in the source code. The<br>     * parameterized type representing each superinterface is created<br>     * if it had not been created before. See the declaration of<br>     * {@link java.lang.reflect.ParameterizedType ParameterizedType}<br>     * for the semantics of the creation process for parameterized<br>     * types.<br>     *<br>     * <p> If this object represents a class, the return value is an<br>     * array containing objects representing all interfaces<br>     * implemented by the class. The order of the interface objects in<br>     * the array corresponds to the order of the interface names in<br>     * the {@code implements} clause of the declaration of the class<br>     * represented by this object.  In the case of an array class, the<br>     * interfaces {@code Cloneable} and {@code Serializable} are<br>     * returned in that order.<br>     *<br>     * <p>If this object represents an interface, the array contains<br>     * objects representing all interfaces directly extended by the<br>     * interface.  The order of the interface objects in the array<br>     * corresponds to the order of the interface names in the<br>     * {@code extends} clause of the declaration of the interface<br>     * represented by this object.<br>     *<br>     * <p>If this object represents a class or interface that<br>     * implements no interfaces, the method returns an array of length<br>     * 0.<br>     *<br>     * <p>If this object represents a primitive type or void, the<br>     * method returns an array of length 0.<br>     *<br>     * @throws java.lang.reflect.GenericSignatureFormatError<br>     *     if the generic class signature does not conform to the format<br>     *     specified in<br>     *     <cite>The Java&trade; Virtual Machine Specification</cite><br>     * @throws TypeNotPresentException if any of the generic<br>     *     superinterfaces refers to a non-existent type declaration<br>     * @throws java.lang.reflect.MalformedParameterizedTypeException<br>     *     if any of the generic superinterfaces refer to a parameterized<br>     *     type that cannot be instantiated for any reason<br>     * @return an array of interfaces implemented by this class<br>     * @since 1.5<br>     */<br>    public Type[] getGenericInterfaces() {<br>        ClassRepository info = getGenericInfo();<br>        return (info == null) ?  getInterfaces() : info.getSuperInterfaces();<br>    }</p><p>    /**<br>     * Returns the {@code Class} representing the component type of an<br>     * array.  If this class does not represent an array class this method<br>     * returns null.<br>     *<br>     * @return the {@code Class} representing the component type of this<br>     * class if this class is an array<br>     * @see     java.lang.reflect.Array<br>     * @since JDK1.1<br>     */<br>    public native Class&lt;?&gt; getComponentType();</p><p>    /**<br>     * Returns the Java language modifiers for this class or interface, encoded<br>     * in an integer. The modifiers consist of the Java Virtual Machine’s<br>     * constants for {@code public}, {@code protected},<br>     * {@code private}, {@code final}, {@code static},<br>     * {@code abstract} and {@code interface}; they should be decoded<br>     * using the methods of class {@code Modifier}.<br>     *<br>     * <p> If the underlying class is an array class, then its<br>     * {@code public}, {@code private} and {@code protected}<br>     * modifiers are the same as those of its component type.  If this<br>     * {@code Class} represents a primitive type or void, its<br>     * {@code public} modifier is always {@code true}, and its<br>     * {@code protected} and {@code private} modifiers are always<br>     * {@code false}. If this object represents an array class, a<br>     * primitive type or void, then its {@code final} modifier is always<br>     * {@code true} and its interface modifier is always<br>     * {@code false}. The values of its other modifiers are not determined<br>     * by this specification.<br>     *<br>     * <p> The modifier encodings are defined in <em>The Java Virtual Machine<br>     * Specification</em>, table 4.1.<br>     *<br>     * @return the {@code int} representing the modifiers for this class<br>     * @see     java.lang.reflect.Modifier<br>     * @since JDK1.1<br>     */<br>    public native int getModifiers();</p><p>    /**<br>     * Gets the signers of this class.<br>     *<br>     * @return  the signers of this class, or null if there are no signers.  In<br>     *          particular, this method returns null if this object represents<br>     *          a primitive type or void.<br>     * @since   JDK1.1<br>     */<br>    public native Object[] getSigners();</p><p>    /**<br>     * Set the signers of this class.<br>     */<br>    native void setSigners(Object[] signers);</p><p>    /**<br>     * If this {@code Class} object represents a local or anonymous<br>     * class within a method, returns a {@link<br>     * java.lang.reflect.Method Method} object representing the<br>     * immediately enclosing method of the underlying class. Returns<br>     * {@code null} otherwise.<br>     *<br>     * In particular, this method returns {@code null} if the underlying<br>     * class is a local or anonymous class immediately enclosed by a type<br>     * declaration, instance initializer or static initializer.<br>     *<br>     * @return the immediately enclosing method of the underlying class, if<br>     *     that class is a local or anonymous class; otherwise {@code null}.<br>     *<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and any of the<br>     *         following conditions is met:<br>     *<br>     *         <ul><br>     *<br>     *         <li> the caller’s class loader is not the same as the<br>     *         class loader of the enclosing class and invocation of<br>     *         {@link SecurityManager#checkPermission<br>     *         s.checkPermission} method with<br>     *         {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *         denies access to the methods within the enclosing class<br>     *<br>     *         <li> the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the enclosing class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of the enclosing class<br>     *<br>     *         </ul><br>     * @since 1.5<br>     */<br>    @CallerSensitive<br>    public Method getEnclosingMethod() throws SecurityException {<br>        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();</p><p>        if (enclosingInfo == null)<br>            return null;<br>        else {<br>            if (!enclosingInfo.isMethod())<br>                return null;</p><p>            MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),<br>                                                              getFactory());<br>            Class<?>   returnType       = toClass(typeInfo.getReturnType());            Type []    parameterTypes   = typeInfo.getParameterTypes();            Class<?>[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];</p><p>            // Convert Types to Classes; returned types <em>should</em><br>            // be class objects since the methodDescriptor’s used<br>            // don’t have generics information<br>            for(int i = 0; i &lt; parameterClasses.length; i++)<br>                parameterClasses[i] = toClass(parameterTypes[i]);</p><p>            // Perform access check<br>            Class<?> enclosingCandidate = enclosingInfo.getEnclosingClass();            enclosingCandidate.checkMemberAccess(Member.DECLARED,                                                 Reflection.getCallerClass(), true);            /*             * Loop over all declared methods; match method name,             * number of and type of parameters, *and* return             * type.  Matching return type is also necessary             * because of covariant returns, etc.             */            for(Method m: enclosingCandidate.getDeclaredMethods()) {                if (m.getName().equals(enclosingInfo.getName()) ) {                    Class<?>[] candidateParamClasses = m.getParameterTypes();<br>                    if (candidateParamClasses.length == parameterClasses.length) {<br>                        boolean matches = true;<br>                        for(int i = 0; i &lt; candidateParamClasses.length; i++) {<br>                            if (!candidateParamClasses[i].equals(parameterClasses[i])) {<br>                                matches = false;<br>                                break;<br>                            }<br>                        }</p><p>                        if (matches) { // finally, check return type<br>                            if (m.getReturnType().equals(returnType) )<br>                                return m;<br>                        }<br>                    }<br>                }<br>            }</p><p>            throw new InternalError(“Enclosing method not found”);<br>        }<br>    }</p><p>    private native Object[] getEnclosingMethod0();</p><p>    private EnclosingMethodInfo getEnclosingMethodInfo() {<br>        Object[] enclosingInfo = getEnclosingMethod0();<br>        if (enclosingInfo == null)<br>            return null;<br>        else {<br>            return new EnclosingMethodInfo(enclosingInfo);<br>        }<br>    }</p><p>    private final static class EnclosingMethodInfo {<br>        private Class&lt;?&gt; enclosingClass;<br>        private String name;<br>        private String descriptor;</p><p>        private EnclosingMethodInfo(Object[] enclosingInfo) {<br>            if (enclosingInfo.length != 3)<br>                throw new InternalError(“Malformed enclosing method information”);<br>            try {<br>                // The array is expected to have three elements:</p><p>                // the immediately enclosing class<br>                enclosingClass = (Class&lt;?&gt;) enclosingInfo[0];<br>                assert(enclosingClass != null);</p><p>                // the immediately enclosing method or constructor’s<br>                // name (can be null).<br>                name            = (String)   enclosingInfo[1];</p><p>                // the immediately enclosing method or constructor’s<br>                // descriptor (null iff name is).<br>                descriptor      = (String)   enclosingInfo[2];<br>                assert((name != null &amp;&amp; descriptor != null) || name == descriptor);<br>            } catch (ClassCastException cce) {<br>                throw new InternalError(“Invalid type in enclosing method information”, cce);<br>            }<br>        }</p><p>        boolean isPartial() {<br>            return enclosingClass == null || name == null || descriptor == null;<br>        }</p><p>        boolean isConstructor() { return !isPartial() &amp;&amp; “<init>“.equals(name); }</p><p>        boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !”<clinit>“.equals(name); }</p><p>        Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }</p><p>        String getName() { return name; }</p><p>        String getDescriptor() { return descriptor; }</p><p>    }</p><p>    private static Class<?> toClass(Type o) {        if (o instanceof GenericArrayType)            return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),                                     0)                .getClass();        return (Class<?>)o;<br>     }</p><p>    /**<br>     * If this {@code Class} object represents a local or anonymous<br>     * class within a constructor, returns a {@link<br>     * java.lang.reflect.Constructor Constructor} object representing<br>     * the immediately enclosing constructor of the underlying<br>     * class. Returns {@code null} otherwise.  In particular, this<br>     * method returns {@code null} if the underlying class is a local<br>     * or anonymous class immediately enclosed by a type declaration,<br>     * instance initializer or static initializer.<br>     *<br>     * @return the immediately enclosing constructor of the underlying class, if<br>     *     that class is a local or anonymous class; otherwise {@code null}.<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and any of the<br>     *         following conditions is met:<br>     *<br>     *         <ul><br>     *<br>     *         <li> the caller’s class loader is not the same as the<br>     *         class loader of the enclosing class and invocation of<br>     *         {@link SecurityManager#checkPermission<br>     *         s.checkPermission} method with<br>     *         {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *         denies access to the constructors within the enclosing class<br>     *<br>     *         <li> the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the enclosing class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of the enclosing class<br>     *<br>     *         </ul><br>     * @since 1.5<br>     */<br>    @CallerSensitive<br>    public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {<br>        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();</p><p>        if (enclosingInfo == null)<br>            return null;<br>        else {<br>            if (!enclosingInfo.isConstructor())<br>                return null;</p><p>            ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),<br>                                                                        getFactory());<br>            Type []    parameterTypes   = typeInfo.getParameterTypes();<br>            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];</p><p>            // Convert Types to Classes; returned types <em>should</em><br>            // be class objects since the methodDescriptor’s used<br>            // don’t have generics information<br>            for(int i = 0; i &lt; parameterClasses.length; i++)<br>                parameterClasses[i] = toClass(parameterTypes[i]);</p><p>            // Perform access check<br>            Class<?> enclosingCandidate = enclosingInfo.getEnclosingClass();            enclosingCandidate.checkMemberAccess(Member.DECLARED,                                                 Reflection.getCallerClass(), true);            /*             * Loop over all declared constructors; match number             * of and type of parameters.             */            for(Constructor<?> c: enclosingCandidate.getDeclaredConstructors()) {<br>                Class&lt;?&gt;[] candidateParamClasses = c.getParameterTypes();<br>                if (candidateParamClasses.length == parameterClasses.length) {<br>                    boolean matches = true;<br>                    for(int i = 0; i &lt; candidateParamClasses.length; i++) {<br>                        if (!candidateParamClasses[i].equals(parameterClasses[i])) {<br>                            matches = false;<br>                            break;<br>                        }<br>                    }</p><p>                    if (matches)<br>                        return c;<br>                }<br>            }</p><p>            throw new InternalError(“Enclosing constructor not found”);<br>        }<br>    }</p><p>    /**<br>     * If the class or interface represented by this {@code Class} object<br>     * is a member of another class, returns the {@code Class} object<br>     * representing the class in which it was declared.  This method returns<br>     * null if this class or interface is not a member of any other class.  If<br>     * this {@code Class} object represents an array class, a primitive<br>     * type, or void,then this method returns null.<br>     *<br>     * @return the declaring class for this class<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and the caller’s<br>     *         class loader is not the same as or an ancestor of the class<br>     *         loader for the declaring class and invocation of {@link<br>     *         SecurityManager#checkPackageAccess s.checkPackageAccess()}<br>     *         denies access to the package of the declaring class<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Class<?> getDeclaringClass() throws SecurityException {        final Class<?> candidate = getDeclaringClass0();</p><p>        if (candidate != null)<br>            candidate.checkPackageAccess(<br>                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);<br>        return candidate;<br>    }</p><p>    private native Class&lt;?&gt; getDeclaringClass0();</p><p>    /**<br>     * Returns the immediately enclosing class of the underlying<br>     * class.  If the underlying class is a top level class this<br>     * method returns {@code null}.<br>     * @return the immediately enclosing class of the underlying class<br>     * @exception  SecurityException<br>     *             If a security manager, <i>s</i>, is present and the caller’s<br>     *             class loader is not the same as or an ancestor of the class<br>     *             loader for the enclosing class and invocation of {@link<br>     *             SecurityManager#checkPackageAccess s.checkPackageAccess()}<br>     *             denies access to the package of the enclosing class<br>     * @since 1.5<br>     */<br>    @CallerSensitive<br>    public Class&lt;?&gt; getEnclosingClass() throws SecurityException {<br>        // There are five kinds of classes (or interfaces):<br>        // a) Top level classes<br>        // b) Nested classes (static member classes)<br>        // c) Inner classes (non-static member classes)<br>        // d) Local classes (named classes declared within a method)<br>        // e) Anonymous classes</p><p>        // JVM Spec 4.8.6: A class must have an EnclosingMethod<br>        // attribute if and only if it is a local class or an<br>        // anonymous class.<br>        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();<br>        Class&lt;?&gt; enclosingCandidate;</p><p>        if (enclosingInfo == null) {<br>            // This is a top level or a nested class or an inner class (a, b, or c)<br>            enclosingCandidate = getDeclaringClass();<br>        } else {<br>            Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();<br>            // This is a local class or an anonymous class (d or e)<br>            if (enclosingClass == this || enclosingClass == null)<br>                throw new InternalError(“Malformed enclosing method information”);<br>            else<br>                enclosingCandidate = enclosingClass;<br>        }</p><p>        if (enclosingCandidate != null)<br>            enclosingCandidate.checkPackageAccess(<br>                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);<br>        return enclosingCandidate;<br>    }</p><p>    /**<br>     * Returns the simple name of the underlying class as given in the<br>     * source code. Returns an empty string if the underlying class is<br>     * anonymous.<br>     *<br>     * <p>The simple name of an array is the simple name of the<br>     * component type with “[]” appended.  In particular the simple<br>     * name of an array whose component type is anonymous is “[]”.<br>     *<br>     * @return the simple name of the underlying class<br>     * @since 1.5<br>     */<br>    public String getSimpleName() {<br>        if (isArray())<br>            return getComponentType().getSimpleName()+”[]”;</p><p>        String simpleName = getSimpleBinaryName();<br>        if (simpleName == null) { // top level class<br>            simpleName = getName();<br>            return simpleName.substring(simpleName.lastIndexOf(“.”)+1); // strip the package name<br>        }<br>        // According to JLS3 “Binary Compatibility” (13.1) the binary<br>        // name of non-package classes (not top level) is the binary<br>        // name of the immediately enclosing class followed by a ‘$’ followed by:<br>        // (for nested and inner classes): the simple name.<br>        // (for local classes): 1 or more digits followed by the simple name.<br>        // (for anonymous classes): 1 or more digits.</p><p>        // Since getSimpleBinaryName() will strip the binary name of<br>        // the immediatly enclosing class, we are now looking at a<br>        // string that matches the regular expression “$[0-9]*”<br>        // followed by a simple name (considering the simple of an<br>        // anonymous class to be the empty string).</p><p>        // Remove leading “$[0-9]*” from the name<br>        int length = simpleName.length();<br>        if (length &lt; 1 || simpleName.charAt(0) != ‘$’)<br>            throw new InternalError(“Malformed class name”);<br>        int index = 1;<br>        while (index &lt; length &amp;&amp; isAsciiDigit(simpleName.charAt(index)))<br>            index++;<br>        // Eventually, this is the empty string iff this is an anonymous class<br>        return simpleName.substring(index);<br>    }</p><p>    /**<br>     * Return an informative string for the name of this type.<br>     *<br>     * @return an informative string for the name of this type<br>     * @since 1.8<br>     */<br>    public String getTypeName() {<br>        if (isArray()) {<br>            try {<br>                Class&lt;?&gt; cl = this;<br>                int dimensions = 0;<br>                while (cl.isArray()) {<br>                    dimensions++;<br>                    cl = cl.getComponentType();<br>                }<br>                StringBuilder sb = new StringBuilder();<br>                sb.append(cl.getName());<br>                for (int i = 0; i &lt; dimensions; i++) {<br>                    sb.append(“[]”);<br>                }<br>                return sb.toString();<br>            } catch (Throwable e) { /<em>FALLTHRU</em>/ }<br>        }<br>        return getName();<br>    }</p><p>    /**<br>     * Character.isDigit answers {@code true} to some non-ascii<br>     * digits.  This one does not.<br>     */<br>    private static boolean isAsciiDigit(char c) {<br>        return ‘0’ &lt;= c &amp;&amp; c &lt;= ‘9’;<br>    }</p><p>    /**<br>     * Returns the canonical name of the underlying class as<br>     * defined by the Java Language Specification.  Returns null if<br>     * the underlying class does not have a canonical name (i.e., if<br>     * it is a local or anonymous class or an array whose component<br>     * type does not have a canonical name).<br>     * @return the canonical name of the underlying class if it exists, and<br>     * {@code null} otherwise.<br>     * @since 1.5<br>     */<br>    public String getCanonicalName() {<br>        if (isArray()) {<br>            String canonicalName = getComponentType().getCanonicalName();<br>            if (canonicalName != null)<br>                return canonicalName + “[]”;<br>            else<br>                return null;<br>        }<br>        if (isLocalOrAnonymousClass())<br>            return null;<br>        Class&lt;?&gt; enclosingClass = getEnclosingClass();<br>        if (enclosingClass == null) { // top level class<br>            return getName();<br>        } else {<br>            String enclosingName = enclosingClass.getCanonicalName();<br>            if (enclosingName == null)<br>                return null;<br>            return enclosingName + “.” + getSimpleName();<br>        }<br>    }</p><p>    /**<br>     * Returns {@code true} if and only if the underlying class<br>     * is an anonymous class.<br>     *<br>     * @return {@code true} if and only if this class is an anonymous class.<br>     * @since 1.5<br>     */<br>    public boolean isAnonymousClass() {<br>        return “”.equals(getSimpleName());<br>    }</p><p>    /**<br>     * Returns {@code true} if and only if the underlying class<br>     * is a local class.<br>     *<br>     * @return {@code true} if and only if this class is a local class.<br>     * @since 1.5<br>     */<br>    public boolean isLocalClass() {<br>        return isLocalOrAnonymousClass() &amp;&amp; !isAnonymousClass();<br>    }</p><p>    /**<br>     * Returns {@code true} if and only if the underlying class<br>     * is a member class.<br>     *<br>     * @return {@code true} if and only if this class is a member class.<br>     * @since 1.5<br>     */<br>    public boolean isMemberClass() {<br>        return getSimpleBinaryName() != null &amp;&amp; !isLocalOrAnonymousClass();<br>    }</p><p>    /**<br>     * Returns the “simple binary name” of the underlying class, i.e.,<br>     * the binary name without the leading enclosing class name.<br>     * Returns {@code null} if the underlying class is a top level<br>     * class.<br>     */<br>    private String getSimpleBinaryName() {<br>        Class&lt;?&gt; enclosingClass = getEnclosingClass();<br>        if (enclosingClass == null) // top level class<br>            return null;<br>        // Otherwise, strip the enclosing class’ name<br>        try {<br>            return getName().substring(enclosingClass.getName().length());<br>        } catch (IndexOutOfBoundsException ex) {<br>            throw new InternalError(“Malformed class name”, ex);<br>        }<br>    }</p><p>    /**<br>     * Returns {@code true} if this is a local class or an anonymous<br>     * class.  Returns {@code false} otherwise.<br>     */<br>    private boolean isLocalOrAnonymousClass() {<br>        // JVM Spec 4.8.6: A class must have an EnclosingMethod<br>        // attribute if and only if it is a local class or an<br>        // anonymous class.<br>        return getEnclosingMethodInfo() != null;<br>    }</p><p>    /**<br>     * Returns an array containing {@code Class} objects representing all<br>     * the public classes and interfaces that are members of the class<br>     * represented by this {@code Class} object.  This includes public<br>     * class and interface members inherited from superclasses and public class<br>     * and interface members declared by the class.  This method returns an<br>     * array of length 0 if this {@code Class} object has no public member<br>     * classes or interfaces.  This method also returns an array of length 0 if<br>     * this {@code Class} object represents a primitive type, an array<br>     * class, or void.<br>     *<br>     * @return the array of {@code Class} objects representing the public<br>     *         members of this class<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Class&lt;?&gt;[] getClasses() {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);</p><p>        // Privileged so this implementation can look at DECLARED classes,<br>        // something the caller might not have privilege to do.  The code here<br>        // is allowed to look at DECLARED classes because (1) it does not hand<br>        // out anything other than public members and (2) public member access<br>        // has already been ok’d by the SecurityManager.</p><p>        return java.security.AccessController.doPrivileged(<br>            new java.security.PrivilegedAction&lt;Class<?>[]>() {                public Class<?>[] run() {<br>                    List&lt;Class<?>> list = new ArrayList<>();                    Class<?> currentClass = Class.this;<br>                    while (currentClass != null) {<br>                        Class<?>[] members = currentClass.getDeclaredClasses();                        for (int i = 0; i < members.length; i++) {                            if (Modifier.isPublic(members[i].getModifiers())) {                                list.add(members[i]);                            }                        }                        currentClass = currentClass.getSuperclass();                    }                    return list.toArray(new Class<?>[0]);<br>                }<br>            });<br>    }</p><p>    /**<br>     * Returns an array containing {@code Field} objects reflecting all<br>     * the accessible public fields of the class or interface represented by<br>     * this {@code Class} object.<br>     *<br>     * <p> If this {@code Class} object represents a class or interface with no<br>     * no accessible public fields, then this method returns an array of length<br>     * 0.<br>     *<br>     * <p> If this {@code Class} object represents a class, then this method<br>     * returns the public fields of the class and of all its superclasses.<br>     *<br>     * <p> If this {@code Class} object represents an interface, then this<br>     * method returns the fields of the interface and of all its<br>     * superinterfaces.<br>     *<br>     * <p> If this {@code Class} object represents an array type, a primitive<br>     * type, or void, then this method returns an array of length 0.<br>     *<br>     * <p> The elements in the returned array are not sorted and are not in any<br>     * particular order.<br>     *<br>     * @return the array of {@code Field} objects representing the<br>     *         public fields<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @since JDK1.1<br>     * @jls 8.2 Class Members<br>     * @jls 8.3 Field Declarations<br>     */<br>    @CallerSensitive<br>    public Field[] getFields() throws SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        return copyFields(privateGetPublicFields(null));<br>    }</p><p>    /**<br>     * Returns an array containing {@code Method} objects reflecting all the<br>     * public methods of the class or interface represented by this {@code<br>     * Class} object, including those declared by the class or interface and<br>     * those inherited from superclasses and superinterfaces.<br>     *<br>     * <p> If this {@code Class} object represents a type that has multiple<br>     * public methods with the same name and parameter types, but different<br>     * return types, then the returned array has a {@code Method} object for<br>     * each such method.<br>     *<br>     * <p> If this {@code Class} object represents a type with a class<br>     * initialization method {@code <clinit>}, then the returned array does<br>     * <em>not</em> have a corresponding {@code Method} object.<br>     *<br>     * <p> If this {@code Class} object represents an array type, then the<br>     * returned array has a {@code Method} object for each of the public<br>     * methods inherited by the array type from {@code Object}. It does not<br>     * contain a {@code Method} object for {@code clone()}.<br>     *<br>     * <p> If this {@code Class} object represents an interface then the<br>     * returned array does not contain any implicitly declared methods from<br>     * {@code Object}. Therefore, if no methods are explicitly declared in<br>     * this interface or any of its superinterfaces then the returned array<br>     * has length 0. (Note that a {@code Class} object which represents a class<br>     * always has public methods, inherited from {@code Object}.)<br>     *<br>     * <p> If this {@code Class} object represents a primitive type or void,<br>     * then the returned array has length 0.<br>     *<br>     * <p> Static methods declared in superinterfaces of the class or interface<br>     * represented by this {@code Class} object are not considered members of<br>     * the class or interface.<br>     *<br>     * <p> The elements in the returned array are not sorted and are not in any<br>     * particular order.<br>     *<br>     * @return the array of {@code Method} objects representing the<br>     *         public methods of this class<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @jls 8.2 Class Members<br>     * @jls 8.4 Method Declarations<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Method[] getMethods() throws SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        return copyMethods(privateGetPublicMethods());<br>    }</p><p>    /**<br>     * Returns an array containing {@code Constructor} objects reflecting<br>     * all the public constructors of the class represented by this<br>     * {@code Class} object.  An array of length 0 is returned if the<br>     * class has no public constructors, or if the class is an array class, or<br>     * if the class reflects a primitive type or void.<br>     *<br>     * Note that while this method returns an array of {@code<br>     * Constructor<T>} objects (that is an array of constructors from<br>     * this class), the return type of this method is {@code<br>     * Constructor<?>[]} and <em>not</em> {@code Constructor<T>[]} as     * might be expected.  This less informative return type is     * necessary since after being returned from this method, the     * array could be modified to hold {@code Constructor} objects for     * different classes, which would violate the type guarantees of     * {@code Constructor<T>[]}.     *     * @return the array of {@code Constructor} objects representing the     *         public constructors of this class     * @throws SecurityException     *         If a security manager, <i>s</i>, is present and     *         the caller's class loader is not the same as or an     *         ancestor of the class loader for the current class and     *         invocation of {@link SecurityManager#checkPackageAccess     *         s.checkPackageAccess()} denies access to the package     *         of this class.     *     * @since JDK1.1     */    @CallerSensitive    public Constructor<?>[] getConstructors() throws SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        return copyConstructors(privateGetDeclaredConstructors(true));<br>    }</p><p>    /**<br>     * Returns a {@code Field} object that reflects the specified public member<br>     * field of the class or interface represented by this {@code Class}<br>     * object. The {@code name} parameter is a {@code String} specifying the<br>     * simple name of the desired field.<br>     *<br>     * <p> The field to be reflected is determined by the algorithm that<br>     * follows.  Let C be the class or interface represented by this object:<br>     *<br>     * <OL><br>     * <LI> If C declares a public field with the name specified, that is the<br>     *      field to be reflected.</LI><br>     * <LI> If no field was found in step 1 above, this algorithm is applied<br>     *      recursively to each direct superinterface of C. The direct<br>     *      superinterfaces are searched in the order they were declared.</LI><br>     * <LI> If no field was found in steps 1 and 2 above, and C has a<br>     *      superclass S, then this algorithm is invoked recursively upon S.<br>     *      If C has no superclass, then a {@code NoSuchFieldException}<br>     *      is thrown.</LI><br>     * </OL><br>     *<br>     * <p> If this {@code Class} object represents an array type, then this<br>     * method does not find the {@code length} field of the array type.<br>     *<br>     * @param name the field name<br>     * @return the {@code Field} object of this class specified by<br>     *         {@code name}<br>     * @throws NoSuchFieldException if a field with the specified name is<br>     *         not found.<br>     * @throws NullPointerException if {@code name} is {@code null}<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @since JDK1.1<br>     * @jls 8.2 Class Members<br>     * @jls 8.3 Field Declarations<br>     */<br>    @CallerSensitive<br>    public Field getField(String name)<br>        throws NoSuchFieldException, SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        Field field = getField0(name);<br>        if (field == null) {<br>            throw new NoSuchFieldException(name);<br>        }<br>        return field;<br>    }</p><p>    /**<br>     * Returns a {@code Method} object that reflects the specified public<br>     * member method of the class or interface represented by this<br>     * {@code Class} object. The {@code name} parameter is a<br>     * {@code String} specifying the simple name of the desired method. The<br>     * {@code parameterTypes} parameter is an array of {@code Class}<br>     * objects that identify the method’s formal parameter types, in declared<br>     * order. If {@code parameterTypes} is {@code null}, it is<br>     * treated as if it were an empty array.<br>     *<br>     * <p> If the {@code name} is “{@code <init>}” or “{@code <clinit>}” a<br>     * {@code NoSuchMethodException} is raised. Otherwise, the method to<br>     * be reflected is determined by the algorithm that follows.  Let C be the<br>     * class or interface represented by this object:<br>     * <OL><br>     * <LI> C is searched for a <I>matching method</I>, as defined below. If a<br>     *      matching method is found, it is reflected.</LI><br>     * <LI> If no matching method is found by step 1 then:<br>     *   <OL TYPE="a"><br>     *   <LI> If C is a class other than {@code Object}, then this algorithm is<br>     *        invoked recursively on the superclass of C.</LI><br>     *   <LI> If C is the class {@code Object}, or if C is an interface, then<br>     *        the superinterfaces of C (if any) are searched for a matching<br>     *        method. If any such method is found, it is reflected.</LI><br>     *   </OL></LI><br>     * </OL><br>     *<br>     * <p> To find a matching method in a class or interface C:&nbsp; If C<br>     * declares exactly one public method with the specified name and exactly<br>     * the same formal parameter types, that is the method reflected. If more<br>     * than one such method is found in C, and one of these methods has a<br>     * return type that is more specific than any of the others, that method is<br>     * reflected; otherwise one of the methods is chosen arbitrarily.<br>     *<br>     * <p>Note that there may be more than one matching method in a<br>     * class because while the Java language forbids a class to<br>     * declare multiple methods with the same signature but different<br>     * return types, the Java virtual machine does not.  This<br>     * increased flexibility in the virtual machine can be used to<br>     * implement various language features.  For example, covariant<br>     * returns can be implemented with {@linkplain<br>     * java.lang.reflect.Method#isBridge bridge methods}; the bridge<br>     * method and the method being overridden would have the same<br>     * signature but different return types.<br>     *<br>     * <p> If this {@code Class} object represents an array type, then this<br>     * method does not find the {@code clone()} method.<br>     *<br>     * <p> Static methods declared in superinterfaces of the class or interface<br>     * represented by this {@code Class} object are not considered members of<br>     * the class or interface.<br>     *<br>     * @param name the name of the method<br>     * @param parameterTypes the list of parameters<br>     * @return the {@code Method} object that matches the specified<br>     *         {@code name} and {@code parameterTypes}<br>     * @throws NoSuchMethodException if a matching method is not found<br>     *         or if the name is “&lt;init&gt;”or “&lt;clinit&gt;”.<br>     * @throws NullPointerException if {@code name} is {@code null}<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @jls 8.2 Class Members<br>     * @jls 8.4 Method Declarations<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<br>        throws NoSuchMethodException, SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        Method method = getMethod0(name, parameterTypes, true);<br>        if (method == null) {<br>            throw new NoSuchMethodException(getName() + “.” + name + argumentTypesToString(parameterTypes));<br>        }<br>        return method;<br>    }</p><p>    /**<br>     * Returns a {@code Constructor} object that reflects the specified<br>     * public constructor of the class represented by this {@code Class}<br>     * object. The {@code parameterTypes} parameter is an array of<br>     * {@code Class} objects that identify the constructor’s formal<br>     * parameter types, in declared order.<br>     *<br>     * If this {@code Class} object represents an inner class<br>     * declared in a non-static context, the formal parameter types<br>     * include the explicit enclosing instance as the first parameter.<br>     *<br>     * <p> The constructor to reflect is the public constructor of the class<br>     * represented by this {@code Class} object whose formal parameter<br>     * types match those specified by {@code parameterTypes}.<br>     *<br>     * @param parameterTypes the parameter array<br>     * @return the {@code Constructor} object of the public constructor that<br>     *         matches the specified {@code parameterTypes}<br>     * @throws NoSuchMethodException if a matching method is not found.<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and<br>     *         the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class.<br>     *<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)<br>        throws NoSuchMethodException, SecurityException {<br>        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);<br>        return getConstructor0(parameterTypes, Member.PUBLIC);<br>    }</p><p>    /**<br>     * Returns an array of {@code Class} objects reflecting all the<br>     * classes and interfaces declared as members of the class represented by<br>     * this {@code Class} object. This includes public, protected, default<br>     * (package) access, and private classes and interfaces declared by the<br>     * class, but excludes inherited classes and interfaces.  This method<br>     * returns an array of length 0 if the class declares no classes or<br>     * interfaces as members, or if this {@code Class} object represents a<br>     * primitive type, an array class, or void.<br>     *<br>     * @return the array of {@code Class} objects representing all the<br>     *         declared members of this class<br>     * @throws SecurityException<br>     *         If a security manager, <i>s</i>, is present and any of the<br>     *         following conditions is met:<br>     *<br>     *         <ul><br>     *<br>     *         <li> the caller’s class loader is not the same as the<br>     *         class loader of this class and invocation of<br>     *         {@link SecurityManager#checkPermission<br>     *         s.checkPermission} method with<br>     *         {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *         denies access to the declared classes within this class<br>     *<br>     *         <li> the caller’s class loader is not the same as or an<br>     *         ancestor of the class loader for the current class and<br>     *         invocation of {@link SecurityManager#checkPackageAccess<br>     *         s.checkPackageAccess()} denies access to the package<br>     *         of this class<br>     *<br>     *         </ul><br>     *<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), false);<br>        return getDeclaredClasses0();<br>    }</p><p>    /**<br>     * Returns an array of {@code Field} objects reflecting all the fields<br>     * declared by the class or interface represented by this<br>     * {@code Class} object. This includes public, protected, default<br>     * (package) access, and private fields, but excludes inherited fields.<br>     *<br>     * <p> If this {@code Class} object represents a class or interface with no<br>     * declared fields, then this method returns an array of length 0.<br>     *<br>     * <p> If this {@code Class} object represents an array type, a primitive<br>     * type, or void, then this method returns an array of length 0.<br>     *<br>     * <p> The elements in the returned array are not sorted and are not in any<br>     * particular order.<br>     *<br>     * @return  the array of {@code Field} objects representing all the<br>     *          declared fields of this class<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared fields within this class<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @since JDK1.1<br>     * @jls 8.2 Class Members<br>     * @jls 8.3 Field Declarations<br>     */<br>    @CallerSensitive<br>    public Field[] getDeclaredFields() throws SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        return copyFields(privateGetDeclaredFields(false));<br>    }</p><p>    /**<br>     *<br>     * Returns an array containing {@code Method} objects reflecting all the<br>     * declared methods of the class or interface represented by this {@code<br>     * Class} object, including public, protected, default (package)<br>     * access, and private methods, but excluding inherited methods.<br>     *<br>     * <p> If this {@code Class} object represents a type that has multiple<br>     * declared methods with the same name and parameter types, but different<br>     * return types, then the returned array has a {@code Method} object for<br>     * each such method.<br>     *<br>     * <p> If this {@code Class} object represents a type that has a class<br>     * initialization method {@code <clinit>}, then the returned array does<br>     * <em>not</em> have a corresponding {@code Method} object.<br>     *<br>     * <p> If this {@code Class} object represents a class or interface with no<br>     * declared methods, then the returned array has length 0.<br>     *<br>     * <p> If this {@code Class} object represents an array type, a primitive<br>     * type, or void, then the returned array has length 0.<br>     *<br>     * <p> The elements in the returned array are not sorted and are not in any<br>     * particular order.<br>     *<br>     * @return  the array of {@code Method} objects representing all the<br>     *          declared methods of this class<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared methods within this class<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @jls 8.2 Class Members<br>     * @jls 8.4 Method Declarations<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Method[] getDeclaredMethods() throws SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        return copyMethods(privateGetDeclaredMethods(false));<br>    }</p><p>    /**<br>     * Returns an array of {@code Constructor} objects reflecting all the<br>     * constructors declared by the class represented by this<br>     * {@code Class} object. These are public, protected, default<br>     * (package) access, and private constructors.  The elements in the array<br>     * returned are not sorted and are not in any particular order.  If the<br>     * class has a default constructor, it is included in the returned array.<br>     * This method returns an array of length 0 if this {@code Class}<br>     * object represents an interface, a primitive type, an array class, or<br>     * void.<br>     *<br>     * <p> See <em>The Java Language Specification</em>, section 8.2.<br>     *<br>     * @return  the array of {@code Constructor} objects representing all the<br>     *          declared constructors of this class<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared constructors within this class<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        return copyConstructors(privateGetDeclaredConstructors(false));<br>    }</p><p>    /**<br>     * Returns a {@code Field} object that reflects the specified declared<br>     * field of the class or interface represented by this {@code Class}<br>     * object. The {@code name} parameter is a {@code String} that specifies<br>     * the simple name of the desired field.<br>     *<br>     * <p> If this {@code Class} object represents an array type, then this<br>     * method does not find the {@code length} field of the array type.<br>     *<br>     * @param name the name of the field<br>     * @return  the {@code Field} object for the specified field in this<br>     *          class<br>     * @throws  NoSuchFieldException if a field with the specified name is<br>     *          not found.<br>     * @throws  NullPointerException if {@code name} is {@code null}<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared field<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @since JDK1.1<br>     * @jls 8.2 Class Members<br>     * @jls 8.3 Field Declarations<br>     */<br>    @CallerSensitive<br>    public Field getDeclaredField(String name)<br>        throws NoSuchFieldException, SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        Field field = searchFields(privateGetDeclaredFields(false), name);<br>        if (field == null) {<br>            throw new NoSuchFieldException(name);<br>        }<br>        return field;<br>    }</p><p>    /**<br>     * Returns a {@code Method} object that reflects the specified<br>     * declared method of the class or interface represented by this<br>     * {@code Class} object. The {@code name} parameter is a<br>     * {@code String} that specifies the simple name of the desired<br>     * method, and the {@code parameterTypes} parameter is an array of<br>     * {@code Class} objects that identify the method’s formal parameter<br>     * types, in declared order.  If more than one method with the same<br>     * parameter types is declared in a class, and one of these methods has a<br>     * return type that is more specific than any of the others, that method is<br>     * returned; otherwise one of the methods is chosen arbitrarily.  If the<br>     * name is “&lt;init&gt;”or “&lt;clinit&gt;” a {@code NoSuchMethodException}<br>     * is raised.<br>     *<br>     * <p> If this {@code Class} object represents an array type, then this<br>     * method does not find the {@code clone()} method.<br>     *<br>     * @param name the name of the method<br>     * @param parameterTypes the parameter array<br>     * @return  the {@code Method} object for the method of this class<br>     *          matching the specified name and parameters<br>     * @throws  NoSuchMethodException if a matching method is not found.<br>     * @throws  NullPointerException if {@code name} is {@code null}<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared method<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @jls 8.2 Class Members<br>     * @jls 8.4 Method Declarations<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)<br>        throws NoSuchMethodException, SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);<br>        if (method == null) {<br>            throw new NoSuchMethodException(getName() + “.” + name + argumentTypesToString(parameterTypes));<br>        }<br>        return method;<br>    }</p><p>    /**<br>     * Returns a {@code Constructor} object that reflects the specified<br>     * constructor of the class or interface represented by this<br>     * {@code Class} object.  The {@code parameterTypes} parameter is<br>     * an array of {@code Class} objects that identify the constructor’s<br>     * formal parameter types, in declared order.<br>     *<br>     * If this {@code Class} object represents an inner class<br>     * declared in a non-static context, the formal parameter types<br>     * include the explicit enclosing instance as the first parameter.<br>     *<br>     * @param parameterTypes the parameter array<br>     * @return  The {@code Constructor} object for the constructor with the<br>     *          specified parameter list<br>     * @throws  NoSuchMethodException if a matching method is not found.<br>     * @throws  SecurityException<br>     *          If a security manager, <i>s</i>, is present and any of the<br>     *          following conditions is met:<br>     *<br>     *          <ul><br>     *<br>     *          <li> the caller’s class loader is not the same as the<br>     *          class loader of this class and invocation of<br>     *          {@link SecurityManager#checkPermission<br>     *          s.checkPermission} method with<br>     *          {@code RuntimePermission(“accessDeclaredMembers”)}<br>     *          denies access to the declared constructor<br>     *<br>     *          <li> the caller’s class loader is not the same as or an<br>     *          ancestor of the class loader for the current class and<br>     *          invocation of {@link SecurityManager#checkPackageAccess<br>     *          s.checkPackageAccess()} denies access to the package<br>     *          of this class<br>     *<br>     *          </ul><br>     *<br>     * @since JDK1.1<br>     */<br>    @CallerSensitive<br>    public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)<br>        throws NoSuchMethodException, SecurityException {<br>        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br>        return getConstructor0(parameterTypes, Member.DECLARED);<br>    }</p><p>    /**<br>     * Finds a resource with a given name.  The rules for searching resources<br>     * associated with a given class are implemented by the defining<br>     * {@linkplain ClassLoader class loader} of the class.  This method<br>     * delegates to this object’s class loader.  If this object was loaded by<br>     * the bootstrap class loader, the method delegates to {@link<br>     * ClassLoader#getSystemResourceAsStream}.<br>     *<br>     * <p> Before delegation, an absolute resource name is constructed from the<br>     * given resource name using this algorithm:<br>     *<br>     * <ul><br>     *<br>     * <li> If the {@code name} begins with a {@code ‘/‘}<br>     * (<tt>‘&#92;u002f’</tt>), then the absolute name of the resource is the<br>     * portion of the {@code name} following the {@code ‘/‘}.<br>     *<br>     * <li> Otherwise, the absolute name is of the following form:<br>     *<br>     * <blockquote><br>     *   {@code modified_package_name/name}<br>     * </blockquote><br>     *<br>     * <p> Where the {@code modified_package_name} is the package name of this<br>     * object with {@code ‘/‘} substituted for {@code ‘.’}<br>     * (<tt>‘&#92;u002e’</tt>).<br>     *<br>     * </ul><br>     *<br>     * @param  name name of the desired resource<br>     * @return      A {@link java.io.InputStream} object or {@code null} if<br>     *              no resource with this name is found<br>     * @throws  NullPointerException If {@code name} is {@code null}<br>     * @since  JDK1.1<br>     */<br>     public InputStream getResourceAsStream(String name) {<br>        name = resolveName(name);<br>        ClassLoader cl = getClassLoader0();<br>        if (cl==null) {<br>            // A system class.<br>            return ClassLoader.getSystemResourceAsStream(name);<br>        }<br>        return cl.getResourceAsStream(name);<br>    }</p><p>    /**<br>     * Finds a resource with a given name.  The rules for searching resources<br>     * associated with a given class are implemented by the defining<br>     * {@linkplain ClassLoader class loader} of the class.  This method<br>     * delegates to this object’s class loader.  If this object was loaded by<br>     * the bootstrap class loader, the method delegates to {@link<br>     * ClassLoader#getSystemResource}.<br>     *<br>     * <p> Before delegation, an absolute resource name is constructed from the<br>     * given resource name using this algorithm:<br>     *<br>     * <ul><br>     *<br>     * <li> If the {@code name} begins with a {@code ‘/‘}<br>     * (<tt>‘&#92;u002f’</tt>), then the absolute name of the resource is the<br>     * portion of the {@code name} following the {@code ‘/‘}.<br>     *<br>     * <li> Otherwise, the absolute name is of the following form:<br>     *<br>     * <blockquote><br>     *   {@code modified_package_name/name}<br>     * </blockquote><br>     *<br>     * <p> Where the {@code modified_package_name} is the package name of this<br>     * object with {@code ‘/‘} substituted for {@code ‘.’}<br>     * (<tt>‘&#92;u002e’</tt>).<br>     *<br>     * </ul><br>     *<br>     * @param  name name of the desired resource<br>     * @return      A  {@link java.net.URL} object or {@code null} if no<br>     *              resource with this name is found<br>     * @since  JDK1.1<br>     */<br>    public java.net.URL getResource(String name) {<br>        name = resolveName(name);<br>        ClassLoader cl = getClassLoader0();<br>        if (cl==null) {<br>            // A system class.<br>            return ClassLoader.getSystemResource(name);<br>        }<br>        return cl.getResource(name);<br>    }</p><p>    /** protection domain returned when the internal domain is null */<br>    private static java.security.ProtectionDomain allPermDomain;</p><p>    /**<br>     * Returns the {@code ProtectionDomain} of this class.  If there is a<br>     * security manager installed, this method first calls the security<br>     * manager’s {@code checkPermission} method with a<br>     * {@code RuntimePermission(“getProtectionDomain”)} permission to<br>     * ensure it’s ok to get the<br>     * {@code ProtectionDomain}.<br>     *<br>     * @return the ProtectionDomain of this class<br>     *<br>     * @throws SecurityException<br>     *        if a security manager exists and its<br>     *        {@code checkPermission} method doesn’t allow<br>     *        getting the ProtectionDomain.<br>     *<br>     * @see java.security.ProtectionDomain<br>     * @see SecurityManager#checkPermission<br>     * @see java.lang.RuntimePermission<br>     * @since 1.2<br>     */<br>    public java.security.ProtectionDomain getProtectionDomain() {<br>        SecurityManager sm = System.getSecurityManager();<br>        if (sm != null) {<br>            sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);<br>        }<br>        java.security.ProtectionDomain pd = getProtectionDomain0();<br>        if (pd == null) {<br>            if (allPermDomain == null) {<br>                java.security.Permissions perms =<br>                    new java.security.Permissions();<br>                perms.add(SecurityConstants.ALL_PERMISSION);<br>                allPermDomain =<br>                    new java.security.ProtectionDomain(null, perms);<br>            }<br>            pd = allPermDomain;<br>        }<br>        return pd;<br>    }</p><p>    /**<br>     * Returns the ProtectionDomain of this class.<br>     */<br>    private native java.security.ProtectionDomain getProtectionDomain0();</p><p>    /*<br>     * Return the Virtual Machine’s Class object for the named<br>     * primitive type.<br>     */<br>    static native Class&lt;?&gt; getPrimitiveClass(String name);</p><p>    /*<br>     * Check if client is allowed to access members.  If access is denied,<br>     * throw a SecurityException.<br>     *<br>     * This method also enforces package access.<br>     *<br>     * <p> Default policy: allow all clients access with normal Java access<br>     * control.<br>     <em>/<br>    private void checkMemberAccess(int which, Class&lt;?&gt; caller, boolean checkProxyInterfaces) {<br>        final SecurityManager s = System.getSecurityManager();<br>        if (s != null) {<br>            /</em> Default policy allows access to all {@link Member#PUBLIC} members,<br>             * as well as access to classes that have the same class loader as the caller.<br>             * In all other cases, it requires RuntimePermission(“accessDeclaredMembers”)<br>             * permission.<br>             */<br>            final ClassLoader ccl = ClassLoader.getClassLoader(caller);<br>            final ClassLoader cl = getClassLoader0();<br>            if (which != Member.PUBLIC) {<br>                if (ccl != cl) {<br>                    s.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);<br>                }<br>            }<br>            this.checkPackageAccess(ccl, checkProxyInterfaces);<br>        }<br>    }</p><p>    /*<br>     * Checks if a client loaded in ClassLoader ccl is allowed to access this<br>     * class under the current package access policy. If access is denied,<br>     * throw a SecurityException.<br>     */<br>    private void checkPackageAccess(final ClassLoader ccl, boolean checkProxyInterfaces) {<br>        final SecurityManager s = System.getSecurityManager();<br>        if (s != null) {<br>            final ClassLoader cl = getClassLoader0();</p><p>            if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {<br>                String name = this.getName();<br>                int i = name.lastIndexOf(‘.’);<br>                if (i != -1) {<br>                    // skip the package access check on a proxy class in default proxy package<br>                    String pkg = name.substring(0, i);<br>                    if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {<br>                        s.checkPackageAccess(pkg);<br>                    }<br>                }<br>            }<br>            // check package access on the proxy interfaces<br>            if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {<br>                ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());<br>            }<br>        }<br>    }</p><p>    /**<br>     * Add a package name prefix if the name is not absolute Remove leading “/“<br>     * if name is absolute<br>     */<br>    private String resolveName(String name) {<br>        if (name == null) {<br>            return name;<br>        }<br>        if (!name.startsWith(“/“)) {<br>            Class&lt;?&gt; c = this;<br>            while (c.isArray()) {<br>                c = c.getComponentType();<br>            }<br>            String baseName = c.getName();<br>            int index = baseName.lastIndexOf(‘.’);<br>            if (index != -1) {<br>                name = baseName.substring(0, index).replace(‘.’, ‘/‘)<br>                    +”/“+name;<br>            }<br>        } else {<br>            name = name.substring(1);<br>        }<br>        return name;<br>    }</p><p>    /**<br>     * Atomic operations support.<br>     */<br>    private static class Atomic {<br>        // initialize Unsafe machinery here, since we need to call Class.class instance method<br>        // and have to avoid calling it in the static initializer of the Class class…<br>        private static final Unsafe unsafe = Unsafe.getUnsafe();<br>        // offset of Class.reflectionData instance field<br>        private static final long reflectionDataOffset;<br>        // offset of Class.annotationType instance field<br>        private static final long annotationTypeOffset;<br>        // offset of Class.annotationData instance field<br>        private static final long annotationDataOffset;</p><p>        static {<br>            Field[] fields = Class.class.getDeclaredFields0(false); // bypass caches<br>            reflectionDataOffset = objectFieldOffset(fields, “reflectionData”);<br>            annotationTypeOffset = objectFieldOffset(fields, “annotationType”);<br>            annotationDataOffset = objectFieldOffset(fields, “annotationData”);<br>        }</p><p>        private static long objectFieldOffset(Field[] fields, String fieldName) {<br>            Field field = searchFields(fields, fieldName);<br>            if (field == null) {<br>                throw new Error(“No “ + fieldName + “ field found in java.lang.Class”);<br>            }<br>            return unsafe.objectFieldOffset(field);<br>        }</p><p>        static <T> boolean casReflectionData(Class&lt;?&gt; clazz,<br>                                             SoftReference&lt;ReflectionData<T>&gt; oldData,<br>                                             SoftReference&lt;ReflectionData<T>&gt; newData) {<br>            return unsafe.compareAndSwapObject(clazz, reflectionDataOffset, oldData, newData);<br>        }</p><p>        static <T> boolean casAnnotationType(Class&lt;?&gt; clazz,<br>                                             AnnotationType oldType,<br>                                             AnnotationType newType) {<br>            return unsafe.compareAndSwapObject(clazz, annotationTypeOffset, oldType, newType);<br>        }</p><p>        static <T> boolean casAnnotationData(Class&lt;?&gt; clazz,<br>                                             AnnotationData oldData,<br>                                             AnnotationData newData) {<br>            return unsafe.compareAndSwapObject(clazz, annotationDataOffset, oldData, newData);<br>        }<br>    }</p><p>    /**<br>     * Reflection support.<br>     */</p><p>    // Caches for certain reflective results<br>    private static boolean useCaches = true;</p><p>    // reflection data that might get invalidated when JVM TI RedefineClasses() is called<br>    private static class ReflectionData<T> {<br>        volatile Field[] declaredFields;<br>        volatile Field[] publicFields;<br>        volatile Method[] declaredMethods;<br>        volatile Method[] publicMethods;<br>        volatile Constructor<T>[] declaredConstructors;<br>        volatile Constructor<T>[] publicConstructors;<br>        // Intermediate results for getFields and getMethods<br>        volatile Field[] declaredPublicFields;<br>        volatile Method[] declaredPublicMethods;<br>        volatile Class&lt;?&gt;[] interfaces;</p><p>        // Value of classRedefinedCount when we created this ReflectionData instance<br>        final int redefinedCount;</p><p>        ReflectionData(int redefinedCount) {<br>            this.redefinedCount = redefinedCount;<br>        }<br>    }</p><p>    private volatile transient SoftReference&lt;ReflectionData<T>&gt; reflectionData;</p><p>    // Incremented by the VM on each call to JVM TI RedefineClasses()<br>    // that redefines this class or a superclass.<br>    private volatile transient int classRedefinedCount = 0;</p><p>    // Lazily create and cache ReflectionData<br>    private ReflectionData<T> reflectionData() {<br>        SoftReference&lt;ReflectionData<T>&gt; reflectionData = this.reflectionData;<br>        int classRedefinedCount = this.classRedefinedCount;<br>        ReflectionData<T> rd;<br>        if (useCaches &amp;&amp;<br>            reflectionData != null &amp;&amp;<br>            (rd = reflectionData.get()) != null &amp;&amp;<br>            rd.redefinedCount == classRedefinedCount) {<br>            return rd;<br>        }<br>        // else no SoftReference or cleared SoftReference or stale ReflectionData<br>        // -&gt; create and replace new instance<br>        return newReflectionData(reflectionData, classRedefinedCount);<br>    }</p><p>    private ReflectionData<T> newReflectionData(SoftReference&lt;ReflectionData<T>&gt; oldReflectionData,<br>                                                int classRedefinedCount) {<br>        if (!useCaches) return null;</p><p>        while (true) {<br>            ReflectionData<T> rd = new ReflectionData&lt;&gt;(classRedefinedCount);<br>            // try to CAS it…<br>            if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {<br>                return rd;<br>            }<br>            // else retry<br>            oldReflectionData = this.reflectionData;<br>            classRedefinedCount = this.classRedefinedCount;<br>            if (oldReflectionData != null &amp;&amp;<br>                (rd = oldReflectionData.get()) != null &amp;&amp;<br>                rd.redefinedCount == classRedefinedCount) {<br>                return rd;<br>            }<br>        }<br>    }</p><p>    // Generic signature handling<br>    private native String getGenericSignature0();</p><p>    // Generic info repository; lazily initialized<br>    private volatile transient ClassRepository genericInfo;</p><p>    // accessor for factory<br>    private GenericsFactory getFactory() {<br>        // create scope and factory<br>        return CoreReflectionFactory.make(this, ClassScope.make(this));<br>    }</p><p>    // accessor for generic info repository;<br>    // generic info is lazily initialized<br>    private ClassRepository getGenericInfo() {<br>        ClassRepository genericInfo = this.genericInfo;<br>        if (genericInfo == null) {<br>            String signature = getGenericSignature0();<br>            if (signature == null) {<br>                genericInfo = ClassRepository.NONE;<br>            } else {<br>                genericInfo = ClassRepository.make(signature, getFactory());<br>            }<br>            this.genericInfo = genericInfo;<br>        }<br>        return (genericInfo != ClassRepository.NONE) ? genericInfo : null;<br>    }</p><p>    // Annotations handling<br>    native byte[] getRawAnnotations();<br>    // Since 1.8<br>    native byte[] getRawTypeAnnotations();<br>    static byte[] getExecutableTypeAnnotationBytes(Executable ex) {<br>        return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);<br>    }</p><p>    native ConstantPool getConstantPool();</p><p>    //<br>    //<br>    // java.lang.reflect.Field handling<br>    //<br>    //</p><p>    // Returns an array of “root” fields. These Field objects must NOT<br>    // be propagated to the outside world, but must instead be copied<br>    // via ReflectionFactory.copyField.<br>    private Field[] privateGetDeclaredFields(boolean publicOnly) {<br>        checkInitted();<br>        Field[] res;<br>        ReflectionData<T> rd = reflectionData();<br>        if (rd != null) {<br>            res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;<br>            if (res != null) return res;<br>        }<br>        // No cached value available; request value from VM<br>        res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));<br>        if (rd != null) {<br>            if (publicOnly) {<br>                rd.declaredPublicFields = res;<br>            } else {<br>                rd.declaredFields = res;<br>            }<br>        }<br>        return res;<br>    }</p><p>    // Returns an array of “root” fields. These Field objects must NOT<br>    // be propagated to the outside world, but must instead be copied<br>    // via ReflectionFactory.copyField.<br>    private Field[] privateGetPublicFields(Set&lt;Class&lt;?&gt;&gt; traversedInterfaces) {<br>        checkInitted();<br>        Field[] res;<br>        ReflectionData<T> rd = reflectionData();<br>        if (rd != null) {<br>            res = rd.publicFields;<br>            if (res != null) return res;<br>        }</p><p>        // No cached value available; compute value recursively.<br>        // Traverse in correct order for getField().<br>        List<Field> fields = new ArrayList&lt;&gt;();<br>        if (traversedInterfaces == null) {<br>            traversedInterfaces = new HashSet&lt;&gt;();<br>        }</p><p>        // Local fields<br>        Field[] tmp = privateGetDeclaredFields(true);<br>        addAll(fields, tmp);</p><p>        // Direct superinterfaces, recursively<br>        for (Class&lt;?&gt; c : getInterfaces()) {<br>            if (!traversedInterfaces.contains(c)) {<br>                traversedInterfaces.add(c);<br>                addAll(fields, c.privateGetPublicFields(traversedInterfaces));<br>            }<br>        }</p><p>        // Direct superclass, recursively<br>        if (!isInterface()) {<br>            Class&lt;?&gt; c = getSuperclass();<br>            if (c != null) {<br>                addAll(fields, c.privateGetPublicFields(traversedInterfaces));<br>            }<br>        }</p><p>        res = new Field[fields.size()];<br>        fields.toArray(res);<br>        if (rd != null) {<br>            rd.publicFields = res;<br>        }<br>        return res;<br>    }</p><p>    private static void addAll(Collection<Field> c, Field[] o) {<br>        for (int i = 0; i &lt; o.length; i++) {<br>            c.add(o[i]);<br>        }<br>    }</p><p>    //<br>    //<br>    // java.lang.reflect.Constructor handling<br>    //<br>    //</p><p>    // Returns an array of “root” constructors. These Constructor<br>    // objects must NOT be propagated to the outside world, but must<br>    // instead be copied via ReflectionFactory.copyConstructor.<br>    private Constructor<T>[] privateGetDeclaredConstructors(boolean publicOnly) {<br>        checkInitted();<br>        Constructor<T>[] res;<br>        ReflectionData<T> rd = reflectionData();<br>        if (rd != null) {<br>            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;<br>            if (res != null) return res;<br>        }<br>        // No cached value available; request value from VM<br>        if (isInterface()) {<br>            @SuppressWarnings(“unchecked”)<br>            Constructor<T>[] temporaryRes = (Constructor<T>[]) new Constructor&lt;?&gt;[0];<br>            res = temporaryRes;<br>        } else {<br>            res = getDeclaredConstructors0(publicOnly);<br>        }<br>        if (rd != null) {<br>            if (publicOnly) {<br>                rd.publicConstructors = res;<br>            } else {<br>                rd.declaredConstructors = res;<br>            }<br>        }<br>        return res;<br>    }</p><p>    //<br>    //<br>    // java.lang.reflect.Method handling<br>    //<br>    //</p><p>    // Returns an array of “root” methods. These Method objects must NOT<br>    // be propagated to the outside world, but must instead be copied<br>    // via ReflectionFactory.copyMethod.<br>    private Method[] privateGetDeclaredMethods(boolean publicOnly) {<br>        checkInitted();<br>        Method[] res;<br>        ReflectionData<T> rd = reflectionData();<br>        if (rd != null) {<br>            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;<br>            if (res != null) return res;<br>        }<br>        // No cached value available; request value from VM<br>        res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));<br>        if (rd != null) {<br>            if (publicOnly) {<br>                rd.declaredPublicMethods = res;<br>            } else {<br>                rd.declaredMethods = res;<br>            }<br>        }<br>        return res;<br>    }</p><p>    static class MethodArray {<br>        // Don’t add or remove methods except by add() or remove() calls.<br>        private Method[] methods;<br>        private int length;<br>        private int defaults;</p><p>        MethodArray() {<br>            this(20);<br>        }</p><p>        MethodArray(int initialSize) {<br>            if (initialSize &lt; 2)<br>                throw new IllegalArgumentException(“Size should be 2 or more”);</p><p>            methods = new Method[initialSize];<br>            length = 0;<br>            defaults = 0;<br>        }</p><p>        boolean hasDefaults() {<br>            return defaults != 0;<br>        }</p><p>        void add(Method m) {<br>            if (length == methods.length) {<br>                methods = Arrays.copyOf(methods, 2 * methods.length);<br>            }<br>            methods[length++] = m;</p><p>            if (m != null &amp;&amp; m.isDefault())<br>                defaults++;<br>        }</p><p>        void addAll(Method[] ma) {<br>            for (int i = 0; i &lt; ma.length; i++) {<br>                add(ma[i]);<br>            }<br>        }</p><p>        void addAll(MethodArray ma) {<br>            for (int i = 0; i &lt; ma.length(); i++) {<br>                add(ma.get(i));<br>            }<br>        }</p><p>        void addIfNotPresent(Method newMethod) {<br>            for (int i = 0; i &lt; length; i++) {<br>                Method m = methods[i];<br>                if (m == newMethod || (m != null &amp;&amp; m.equals(newMethod))) {<br>                    return;<br>                }<br>            }<br>            add(newMethod);<br>        }</p><p>        void addAllIfNotPresent(MethodArray newMethods) {<br>            for (int i = 0; i &lt; newMethods.length(); i++) {<br>                Method m = newMethods.get(i);<br>                if (m != null) {<br>                    addIfNotPresent(m);<br>                }<br>            }<br>        }</p><p>        /* Add Methods declared in an interface to this MethodArray.<br>         * Static methods declared in interfaces are not inherited.<br>         */<br>        void addInterfaceMethods(Method[] methods) {<br>            for (Method candidate : methods) {<br>                if (!Modifier.isStatic(candidate.getModifiers())) {<br>                    add(candidate);<br>                }<br>            }<br>        }</p><p>        int length() {<br>            return length;<br>        }</p><p>        Method get(int i) {<br>            return methods[i];<br>        }</p><p>        Method getFirst() {<br>            for (Method m : methods)<br>                if (m != null)<br>                    return m;<br>            return null;<br>        }</p><p>        void removeByNameAndDescriptor(Method toRemove) {<br>            for (int i = 0; i &lt; length; i++) {<br>                Method m = methods[i];<br>                if (m != null &amp;&amp; matchesNameAndDescriptor(m, toRemove)) {<br>                    remove(i);<br>                }<br>            }<br>        }</p><p>        private void remove(int i) {<br>            if (methods[i] != null &amp;&amp; methods[i].isDefault())<br>                defaults–;<br>            methods[i] = null;<br>        }</p><p>        private boolean matchesNameAndDescriptor(Method m1, Method m2) {<br>            return m1.getReturnType() == m2.getReturnType() &amp;&amp;<br>                   m1.getName() == m2.getName() &amp;&amp; // name is guaranteed to be interned<br>                   arrayContentsEq(m1.getParameterTypes(),<br>                           m2.getParameterTypes());<br>        }</p><p>        void compactAndTrim() {<br>            int newPos = 0;<br>            // Get rid of null slots<br>            for (int pos = 0; pos &lt; length; pos++) {<br>                Method m = methods[pos];<br>                if (m != null) {<br>                    if (pos != newPos) {<br>                        methods[newPos] = m;<br>                    }<br>                    newPos++;<br>                }<br>            }<br>            if (newPos != methods.length) {<br>                methods = Arrays.copyOf(methods, newPos);<br>            }<br>        }</p><p>        /* Removes all Methods from this MethodArray that have a more specific<br>         * default Method in this MethodArray.<br>         *<br>         * Users of MethodArray are responsible for pruning Methods that have<br>         * a more specific <em>concrete</em> Method.<br>         */<br>        void removeLessSpecifics() {<br>            if (!hasDefaults())<br>                return;</p><p>            for (int i = 0; i &lt; length; i++) {<br>                Method m = get(i);<br>                if  (m == null || !m.isDefault())<br>                    continue;</p><p>                for (int j  = 0; j &lt; length; j++) {<br>                    if (i == j)<br>                        continue;</p><p>                    Method candidate = get(j);<br>                    if (candidate == null)<br>                        continue;</p><p>                    if (!matchesNameAndDescriptor(m, candidate))<br>                        continue;</p><p>                    if (hasMoreSpecificClass(m, candidate))<br>                        remove(j);<br>                }<br>            }<br>        }</p><p>        Method[] getArray() {<br>            return methods;<br>        }</p><p>        // Returns true if m1 is more specific than m2<br>        static boolean hasMoreSpecificClass(Method m1, Method m2) {<br>            Class<?> m1Class = m1.getDeclaringClass();            Class<?> m2Class = m2.getDeclaringClass();<br>            return m1Class != m2Class &amp;&amp; m2Class.isAssignableFrom(m1Class);<br>        }<br>    }</p><p>    // Returns an array of “root” methods. These Method objects must NOT<br>    // be propagated to the outside world, but must instead be copied<br>    // via ReflectionFactory.copyMethod.<br>    private Method[] privateGetPublicMethods() {<br>        checkInitted();<br>        Method[] res;<br>        ReflectionData<T> rd = reflectionData();<br>        if (rd != null) {<br>            res = rd.publicMethods;<br>            if (res != null) return res;<br>        }</p><p>        // No cached value available; compute value recursively.<br>        // Start by fetching public declared methods<br>        MethodArray methods = new MethodArray();<br>        {<br>            Method[] tmp = privateGetDeclaredMethods(true);<br>            methods.addAll(tmp);<br>        }<br>        // Now recur over superclass and direct superinterfaces.<br>        // Go over superinterfaces first so we can more easily filter<br>        // out concrete implementations inherited from superclasses at<br>        // the end.<br>        MethodArray inheritedMethods = new MethodArray();<br>        for (Class<?> i : getInterfaces()) {            inheritedMethods.addInterfaceMethods(i.privateGetPublicMethods());        }        if (!isInterface()) {            Class<?> c = getSuperclass();<br>            if (c != null) {<br>                MethodArray supers = new MethodArray();<br>                supers.addAll(c.privateGetPublicMethods());<br>                // Filter out concrete implementations of any<br>                // interface methods<br>                for (int i = 0; i &lt; supers.length(); i++) {<br>                    Method m = supers.get(i);<br>                    if (m != null &amp;&amp;<br>                            !Modifier.isAbstract(m.getModifiers()) &amp;&amp;<br>                            !m.isDefault()) {<br>                        inheritedMethods.removeByNameAndDescriptor(m);<br>                    }<br>                }<br>                // Insert superclass’s inherited methods before<br>                // superinterfaces’ to satisfy getMethod’s search<br>                // order<br>                supers.addAll(inheritedMethods);<br>                inheritedMethods = supers;<br>            }<br>        }<br>        // Filter out all local methods from inherited ones<br>        for (int i = 0; i &lt; methods.length(); i++) {<br>            Method m = methods.get(i);<br>            inheritedMethods.removeByNameAndDescriptor(m);<br>        }<br>        methods.addAllIfNotPresent(inheritedMethods);<br>        methods.removeLessSpecifics();<br>        methods.compactAndTrim();<br>        res = methods.getArray();<br>        if (rd != null) {<br>            rd.publicMethods = res;<br>        }<br>        return res;<br>    }</p><p>    //<br>    // Helpers for fetchers of one field, method, or constructor<br>    //</p><p>    private static Field searchFields(Field[] fields, String name) {<br>        String internedName = name.intern();<br>        for (int i = 0; i &lt; fields.length; i++) {<br>            if (fields[i].getName() == internedName) {<br>                return getReflectionFactory().copyField(fields[i]);<br>            }<br>        }<br>        return null;<br>    }</p><p>    private Field getField0(String name) throws NoSuchFieldException {<br>        // Note: the intent is that the search algorithm this routine<br>        // uses be equivalent to the ordering imposed by<br>        // privateGetPublicFields(). It fetches only the declared<br>        // public fields for each class, however, to reduce the number<br>        // of Field objects which have to be created for the common<br>        // case where the field being requested is declared in the<br>        // class which is being queried.<br>        Field res;<br>        // Search declared public fields<br>        if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {<br>            return res;<br>        }<br>        // Direct superinterfaces, recursively<br>        Class<?>[] interfaces = getInterfaces();        for (int i = 0; i < interfaces.length; i++) {            Class<?> c = interfaces[i];<br>            if ((res = c.getField0(name)) != null) {<br>                return res;<br>            }<br>        }<br>        // Direct superclass, recursively<br>        if (!isInterface()) {<br>            Class&lt;?&gt; c = getSuperclass();<br>            if (c != null) {<br>                if ((res = c.getField0(name)) != null) {<br>                    return res;<br>                }<br>            }<br>        }<br>        return null;<br>    }</p><p>    private static Method searchMethods(Method[] methods,<br>                                        String name,<br>                                        Class&lt;?&gt;[] parameterTypes)<br>    {<br>        Method res = null;<br>        String internedName = name.intern();<br>        for (int i = 0; i &lt; methods.length; i++) {<br>            Method m = methods[i];<br>            if (m.getName() == internedName<br>                &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())<br>                &amp;&amp; (res == null<br>                    || res.getReturnType().isAssignableFrom(m.getReturnType())))<br>                res = m;<br>        }</p><p>        return (res == null ? res : getReflectionFactory().copyMethod(res));<br>    }</p><p>    private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes, boolean includeStaticMethods) {<br>        MethodArray interfaceCandidates = new MethodArray(2);<br>        Method res =  privateGetMethodRecursive(name, parameterTypes, includeStaticMethods, interfaceCandidates);<br>        if (res != null)<br>            return res;</p><p>        // Not found on class or superclass directly<br>        interfaceCandidates.removeLessSpecifics();<br>        return interfaceCandidates.getFirst(); // may be null<br>    }</p><p>    private Method privateGetMethodRecursive(String name,<br>            Class&lt;?&gt;[] parameterTypes,<br>            boolean includeStaticMethods,<br>            MethodArray allInterfaceCandidates) {<br>        // Note: the intent is that the search algorithm this routine<br>        // uses be equivalent to the ordering imposed by<br>        // privateGetPublicMethods(). It fetches only the declared<br>        // public methods for each class, however, to reduce the<br>        // number of Method objects which have to be created for the<br>        // common case where the method being requested is declared in<br>        // the class which is being queried.<br>        //<br>        // Due to default methods, unless a method is found on a superclass,<br>        // methods declared in any superinterface needs to be considered.<br>        // Collect all candidates declared in superinterfaces in {@code<br>        // allInterfaceCandidates} and select the most specific if no match on<br>        // a superclass is found.</p><p>        // Must <em>not</em> return root methods<br>        Method res;<br>        // Search declared public methods<br>        if ((res = searchMethods(privateGetDeclaredMethods(true),<br>                                 name,<br>                                 parameterTypes)) != null) {<br>            if (includeStaticMethods || !Modifier.isStatic(res.getModifiers()))<br>                return res;<br>        }<br>        // Search superclass’s methods<br>        if (!isInterface()) {<br>            Class<? super T> c = getSuperclass();            if (c != null) {                if ((res = c.getMethod0(name, parameterTypes, true)) != null) {                    return res;                }            }        }        // Search superinterfaces' methods        Class<?>[] interfaces = getInterfaces();<br>        for (Class&lt;?&gt; c : interfaces)<br>            if ((res = c.getMethod0(name, parameterTypes, false)) != null)<br>                allInterfaceCandidates.add(res);<br>        // Not found<br>        return null;<br>    }</p><p>    private Constructor<T> getConstructor0(Class&lt;?&gt;[] parameterTypes,<br>                                        int which) throws NoSuchMethodException<br>    {<br>        Constructor<T>[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));<br>        for (Constructor<T> constructor : constructors) {<br>            if (arrayContentsEq(parameterTypes,<br>                                constructor.getParameterTypes())) {<br>                return getReflectionFactory().copyConstructor(constructor);<br>            }<br>        }<br>        throw new NoSuchMethodException(getName() + “.<init>“ + argumentTypesToString(parameterTypes));<br>    }</p><p>    //<br>    // Other helpers and base implementation<br>    //</p><p>    private static boolean arrayContentsEq(Object[] a1, Object[] a2) {<br>        if (a1 == null) {<br>            return a2 == null || a2.length == 0;<br>        }</p><p>        if (a2 == null) {<br>            return a1.length == 0;<br>        }</p><p>        if (a1.length != a2.length) {<br>            return false;<br>        }</p><p>        for (int i = 0; i &lt; a1.length; i++) {<br>            if (a1[i] != a2[i]) {<br>                return false;<br>            }<br>        }</p><p>        return true;<br>    }</p><p>    private static Field[] copyFields(Field[] arg) {<br>        Field[] out = new Field[arg.length];<br>        ReflectionFactory fact = getReflectionFactory();<br>        for (int i = 0; i &lt; arg.length; i++) {<br>            out[i] = fact.copyField(arg[i]);<br>        }<br>        return out;<br>    }</p><p>    private static Method[] copyMethods(Method[] arg) {<br>        Method[] out = new Method[arg.length];<br>        ReflectionFactory fact = getReflectionFactory();<br>        for (int i = 0; i &lt; arg.length; i++) {<br>            out[i] = fact.copyMethod(arg[i]);<br>        }<br>        return out;<br>    }</p><p>    private static <U> Constructor<U>[] copyConstructors(Constructor<U>[] arg) {<br>        Constructor<U>[] out = arg.clone();<br>        ReflectionFactory fact = getReflectionFactory();<br>        for (int i = 0; i &lt; out.length; i++) {<br>            out[i] = fact.copyConstructor(out[i]);<br>        }<br>        return out;<br>    }</p><p>    private native Field[]       getDeclaredFields0(boolean publicOnly);<br>    private native Method[]      getDeclaredMethods0(boolean publicOnly);<br>    private native Constructor<T>[] getDeclaredConstructors0(boolean publicOnly);<br>    private native Class&lt;?&gt;[]   getDeclaredClasses0();</p><p>    private static String        argumentTypesToString(Class<?>[] argTypes) {        StringBuilder buf = new StringBuilder();        buf.append("(");        if (argTypes != null) {            for (int i = 0; i < argTypes.length; i++) {                if (i > 0) {                    buf.append(", ");                }                Class<?> c = argTypes[i];<br>                buf.append((c == null) ? “null” : c.getName());<br>            }<br>        }<br>        buf.append(“)”);<br>        return buf.toString();<br>    }</p><p>    /** use serialVersionUID from JDK 1.1 for interoperability */<br>    private static final long serialVersionUID = 3206093459760846163L;</p><p>    /**<br>     * Class Class is special cased within the Serialization Stream Protocol.<br>     *<br>     * A Class instance is written initially into an ObjectOutputStream in the<br>     * following format:<br>     * <pre><br>     *      {@code TC_CLASS} ClassDescriptor<br>     *      A ClassDescriptor is a special cased serialization of<br>     *      a {@code java.io.ObjectStreamClass} instance.<br>     * </pre><br>     * A new handle is generated for the initial time the class descriptor<br>     * is written into the stream. Future references to the class descriptor<br>     * are written as references to the initial class descriptor instance.<br>     *<br>     * @see java.io.ObjectStreamClass<br>     */<br>    private static final ObjectStreamField[] serialPersistentFields =<br>        new ObjectStreamField[0];</p><p>    /**<br>     * Returns the assertion status that would be assigned to this<br>     * class if it were to be initialized at the time this method is invoked.<br>     * If this class has had its assertion status set, the most recent<br>     * setting will be returned; otherwise, if any package default assertion<br>     * status pertains to this class, the most recent setting for the most<br>     * specific pertinent package default assertion status is returned;<br>     * otherwise, if this class is not a system class (i.e., it has a<br>     * class loader) its class loader’s default assertion status is returned;<br>     * otherwise, the system class default assertion status is returned.<br>     * <p><br>     * Few programmers will have any need for this method; it is provided<br>     * for the benefit of the JRE itself.  (It allows a class to determine at<br>     * the time that it is initialized whether assertions should be enabled.)<br>     * Note that this method is not guaranteed to return the actual<br>     * assertion status that was (or will be) associated with the specified<br>     * class when it was (or will be) initialized.<br>     *<br>     * @return the desired assertion status of the specified class.<br>     * @see    java.lang.ClassLoader#setClassAssertionStatus<br>     * @see    java.lang.ClassLoader#setPackageAssertionStatus<br>     * @see    java.lang.ClassLoader#setDefaultAssertionStatus<br>     * @since  1.4<br>     */<br>    public boolean desiredAssertionStatus() {<br>        ClassLoader loader = getClassLoader();<br>        // If the loader is null this is a system class, so ask the VM<br>        if (loader == null)<br>            return desiredAssertionStatus0(this);</p><p>        // If the classloader has been initialized with the assertion<br>        // directives, ask it. Otherwise, ask the VM.<br>        synchronized(loader.assertionLock) {<br>            if (loader.classAssertionStatus != null) {<br>                return loader.desiredAssertionStatus(getName());<br>            }<br>        }<br>        return desiredAssertionStatus0(this);<br>    }</p><p>    // Retrieves the desired assertion status of this class from the VM<br>    private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);</p><p>    /**<br>     * Returns true if and only if this class was declared as an enum in the<br>     * source code.<br>     *<br>     * @return true if and only if this class was declared as an enum in the<br>     *     source code<br>     * @since 1.5<br>     */<br>    public boolean isEnum() {<br>        // An enum must both directly extend java.lang.Enum and have<br>        // the ENUM bit set; classes for specialized enum constants<br>        // don’t do the former.<br>        return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;<br>        this.getSuperclass() == java.lang.Enum.class;<br>    }</p><p>    // Fetches the factory for reflective objects<br>    private static ReflectionFactory getReflectionFactory() {<br>        if (reflectionFactory == null) {<br>            reflectionFactory =<br>                java.security.AccessController.doPrivileged<br>                    (new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());<br>        }<br>        return reflectionFactory;<br>    }<br>    private static ReflectionFactory reflectionFactory;</p><p>    // To be able to query system properties as soon as they’re available<br>    private static boolean initted = false;<br>    private static void checkInitted() {<br>        if (initted) return;<br>        AccessController.doPrivileged(new PrivilegedAction<Void>() {<br>                public Void run() {<br>                    // Tests to ensure the system properties table is fully<br>                    // initialized. This is needed because reflection code is<br>                    // called very early in the initialization process (before<br>                    // command-line arguments have been parsed and therefore<br>                    // these user-settable properties installed.) We assume that<br>                    // if System.out is non-null then the System class has been<br>                    // fully initialized and that the bulk of the startup code<br>                    // has been run.</p><p>                    if (System.out == null) {<br>                        // java.lang.System not yet fully initialized<br>                        return null;<br>                    }</p><p>                    // Doesn’t use Boolean.getBoolean to avoid class init.<br>                    String val =<br>                        System.getProperty(“sun.reflect.noCaches”);<br>                    if (val != null &amp;&amp; val.equals(“true”)) {<br>                        useCaches = false;<br>                    }</p><p>                    initted = true;<br>                    return null;<br>                }<br>            });<br>    }</p><p>    /**<br>     * Returns the elements of this enum class or null if this<br>     * Class object does not represent an enum type.<br>     *<br>     * @return an array containing the values comprising the enum class<br>     *     represented by this Class object in the order they’re<br>     *     declared, or null if this Class object does not<br>     *     represent an enum type<br>     * @since 1.5<br>     */<br>    public T[] getEnumConstants() {<br>        T[] values = getEnumConstantsShared();<br>        return (values != null) ? values.clone() : null;<br>    }</p><p>    /**<br>     * Returns the elements of this enum class or null if this<br>     * Class object does not represent an enum type;<br>     * identical to getEnumConstants except that the result is<br>     * uncloned, cached, and shared by all callers.<br>     */<br>    T[] getEnumConstantsShared() {<br>        if (enumConstants == null) {<br>            if (!isEnum()) return null;<br>            try {<br>                final Method values = getMethod(“values”);<br>                java.security.AccessController.doPrivileged(<br>                    new java.security.PrivilegedAction<Void>() {<br>                        public Void run() {<br>                                values.setAccessible(true);<br>                                return null;<br>                            }<br>                        });<br>                @SuppressWarnings(“unchecked”)<br>                T[] temporaryConstants = (T[])values.invoke(null);<br>                enumConstants = temporaryConstants;<br>            }<br>            // These can happen when users concoct enum-like classes<br>            // that don’t comply with the enum spec.<br>            catch (InvocationTargetException | NoSuchMethodException |<br>                   IllegalAccessException ex) { return null; }<br>        }<br>        return enumConstants;<br>    }<br>    private volatile transient T[] enumConstants = null;</p><p>    /**<br>     * Returns a map from simple name to enum constant.  This package-private<br>     * method is used internally by Enum to implement<br>     * {@code public static &lt;T extends Enum<T>&gt; T valueOf(Class<T>, String)}<br>     * efficiently.  Note that the map is returned by this method is<br>     * created lazily on first use.  Typically it won’t ever get created.<br>     */<br>    Map&lt;String, T&gt; enumConstantDirectory() {<br>        if (enumConstantDirectory == null) {<br>            T[] universe = getEnumConstantsShared();<br>            if (universe == null)<br>                throw new IllegalArgumentException(<br>                    getName() + “ is not an enum type”);<br>            Map&lt;String, T&gt; m = new HashMap&lt;&gt;(2 * universe.length);<br>            for (T constant : universe)<br>                m.put(((Enum&lt;?&gt;)constant).name(), constant);<br>            enumConstantDirectory = m;<br>        }<br>        return enumConstantDirectory;<br>    }<br>    private volatile transient Map&lt;String, T&gt; enumConstantDirectory = null;</p><p>    /**<br>     * Casts an object to the class or interface represented<br>     * by this {@code Class} object.<br>     *<br>     * @param obj the object to be cast<br>     * @return the object after casting, or null if obj is null<br>     *<br>     * @throws ClassCastException if the object is not<br>     * null and is not assignable to the type T.<br>     *<br>     * @since 1.5<br>     */<br>    @SuppressWarnings(“unchecked”)<br>    public T cast(Object obj) {<br>        if (obj != null &amp;&amp; !isInstance(obj))<br>            throw new ClassCastException(cannotCastMsg(obj));<br>        return (T) obj;<br>    }</p><p>    private String cannotCastMsg(Object obj) {<br>        return “Cannot cast “ + obj.getClass().getName() + “ to “ + getName();<br>    }</p><p>    /**<br>     * Casts this {@code Class} object to represent a subclass of the class<br>     * represented by the specified class object.  Checks that the cast<br>     * is valid, and throws a {@code ClassCastException} if it is not.  If<br>     * this method succeeds, it always returns a reference to this class object.<br>     *<br>     * <p>This method is useful when a client needs to “narrow” the type of<br>     * a {@code Class} object to pass it to an API that restricts the<br>     * {@code Class} objects that it is willing to accept.  A cast would<br>     * generate a compile-time warning, as the correctness of the cast<br>     * could not be checked at runtime (because generic types are implemented<br>     * by erasure).<br>     *<br>     * @param <U> the type to cast this class object to<br>     * @param clazz the class of the type to cast this class object to<br>     * @return this {@code Class} object, cast to represent a subclass of<br>     *    the specified class object.<br>     * @throws ClassCastException if this {@code Class} object does not<br>     *    represent a subclass of the specified class (here “subclass” includes<br>     *    the class itself).<br>     * @since 1.5<br>     */<br>    @SuppressWarnings(“unchecked”)<br>    public <U> Class&lt;? extends U&gt; asSubclass(Class<U> clazz) {<br>        if (clazz.isAssignableFrom(this))<br>            return (Class&lt;? extends U&gt;) this;<br>        else<br>            throw new ClassCastException(this.toString());<br>    }</p><p>    /**<br>     * @throws NullPointerException {@inheritDoc}<br>     * @since 1.5<br>     */<br>    @SuppressWarnings(“unchecked”)<br>    public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {<br>        Objects.requireNonNull(annotationClass);</p><p>        return (A) annotationData().annotations.get(annotationClass);<br>    }</p><p>    /**<br>     * {@inheritDoc}<br>     * @throws NullPointerException {@inheritDoc}<br>     * @since 1.5<br>     */<br>    @Override<br>    public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {<br>        return GenericDeclaration.super.isAnnotationPresent(annotationClass);<br>    }</p><p>    /**<br>     * @throws NullPointerException {@inheritDoc}<br>     * @since 1.8<br>     */<br>    @Override<br>    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationClass) {<br>        Objects.requireNonNull(annotationClass);</p><p>        AnnotationData annotationData = annotationData();<br>        return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,<br>                                                          this,<br>                                                          annotationClass);<br>    }</p><p>    /**<br>     * @since 1.5<br>     */<br>    public Annotation[] getAnnotations() {<br>        return AnnotationParser.toArray(annotationData().annotations);<br>    }</p><p>    /**<br>     * @throws NullPointerException {@inheritDoc}<br>     * @since 1.8<br>     */<br>    @Override<br>    @SuppressWarnings(“unchecked”)<br>    public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass) {<br>        Objects.requireNonNull(annotationClass);</p><p>        return (A) annotationData().declaredAnnotations.get(annotationClass);<br>    }</p><p>    /**<br>     * @throws NullPointerException {@inheritDoc}<br>     * @since 1.8<br>     */<br>    @Override<br>    public <A extends Annotation> A[] getDeclaredAnnotationsByType(Class<A> annotationClass) {<br>        Objects.requireNonNull(annotationClass);</p><p>        return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,<br>                                                                 annotationClass);<br>    }</p><p>    /**<br>     * @since 1.5<br>     */<br>    public Annotation[] getDeclaredAnnotations()  {<br>        return AnnotationParser.toArray(annotationData().declaredAnnotations);<br>    }</p><p>    // annotation data that might get invalidated when JVM TI RedefineClasses() is called<br>    private static class AnnotationData {<br>        final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;<br>        final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;</p><p>        // Value of classRedefinedCount when we created this AnnotationData instance<br>        final int redefinedCount;</p><p>        AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,<br>                       Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,<br>                       int redefinedCount) {<br>            this.annotations = annotations;<br>            this.declaredAnnotations = declaredAnnotations;<br>            this.redefinedCount = redefinedCount;<br>        }<br>    }</p><p>    // Annotations cache<br>    @SuppressWarnings(“UnusedDeclaration”)<br>    private volatile transient AnnotationData annotationData;</p><p>    private AnnotationData annotationData() {<br>        while (true) { // retry loop<br>            AnnotationData annotationData = this.annotationData;<br>            int classRedefinedCount = this.classRedefinedCount;<br>            if (annotationData != null &amp;&amp;<br>                annotationData.redefinedCount == classRedefinedCount) {<br>                return annotationData;<br>            }<br>            // null or stale annotationData -&gt; optimistically create new instance<br>            AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);<br>            // try to install it<br>            if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {<br>                // successfully installed new AnnotationData<br>                return newAnnotationData;<br>            }<br>        }<br>    }</p><p>    private AnnotationData createAnnotationData(int classRedefinedCount) {<br>        Map&lt;Class<? extends Annotation>, Annotation> declaredAnnotations =            AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);        Class<?> superClass = getSuperclass();<br>        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;<br>        if (superClass != null) {<br>            Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =<br>                superClass.annotationData().annotations;<br>            for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {<br>                Class&lt;? extends Annotation&gt; annotationClass = e.getKey();<br>                if (AnnotationType.getInstance(annotationClass).isInherited()) {<br>                    if (annotations == null) { // lazy construction<br>                        annotations = new LinkedHashMap&lt;&gt;((Math.max(<br>                                declaredAnnotations.size(),<br>                                Math.min(12, declaredAnnotations.size() + superAnnotations.size())<br>                            ) * 4 + 2) / 3<br>                        );<br>                    }<br>                    annotations.put(annotationClass, e.getValue());<br>                }<br>            }<br>        }<br>        if (annotations == null) {<br>            // no inherited annotations -&gt; share the Map with declaredAnnotations<br>            annotations = declaredAnnotations;<br>        } else {<br>            // at least one inherited annotation -&gt; declared may override inherited<br>            annotations.putAll(declaredAnnotations);<br>        }<br>        return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);<br>    }</p><p>    // Annotation types cache their internal (AnnotationType) form</p><p>    @SuppressWarnings(“UnusedDeclaration”)<br>    private volatile transient AnnotationType annotationType;</p><p>    boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {<br>        return Atomic.casAnnotationType(this, oldType, newType);<br>    }</p><p>    AnnotationType getAnnotationType() {<br>        return annotationType;<br>    }</p><p>    Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {<br>        return annotationData().declaredAnnotations;<br>    }</p><p>    /* Backing store of user-defined values pertaining to this class.<br>     * Maintained by the ClassValue class.<br>     */<br>    transient ClassValue.ClassValueMap classValueMap;</p><p>    /**<br>     * Returns an {@code AnnotatedType} object that represents the use of a<br>     * type to specify the superclass of the entity represented by this {@code<br>     * Class} object. (The <em>use</em> of type Foo to specify the superclass<br>     * in ‘…  extends Foo’ is distinct from the <em>declaration</em> of type<br>     * Foo.)<br>     *<br>     * <p> If this {@code Class} object represents a type whose declaration<br>     * does not explicitly indicate an annotated superclass, then the return<br>     * value is an {@code AnnotatedType} object representing an element with no<br>     * annotations.<br>     *<br>     * <p> If this {@code Class} represents either the {@code Object} class, an<br>     * interface type, an array type, a primitive type, or void, the return<br>     * value is {@code null}.<br>     *<br>     * @return an object representing the superclass<br>     * @since 1.8<br>     */<br>    public AnnotatedType getAnnotatedSuperclass() {<br>        if (this == Object.class ||<br>                isInterface() ||<br>                isArray() ||<br>                isPrimitive() ||<br>                this == Void.TYPE) {<br>            return null;<br>        }</p><p>        return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);<br>    }</p><p>    /**<br>     * Returns an array of {@code AnnotatedType} objects that represent the use<br>     * of types to specify superinterfaces of the entity represented by this<br>     * {@code Class} object. (The <em>use</em> of type Foo to specify a<br>     * superinterface in ‘… implements Foo’ is distinct from the<br>     * <em>declaration</em> of type Foo.)<br>     *<br>     * <p> If this {@code Class} object represents a class, the return value is<br>     * an array containing objects representing the uses of interface types to<br>     * specify interfaces implemented by the class. The order of the objects in<br>     * the array corresponds to the order of the interface types used in the<br>     * ‘implements’ clause of the declaration of this {@code Class} object.<br>     *<br>     * <p> If this {@code Class} object represents an interface, the return<br>     * value is an array containing objects representing the uses of interface<br>     * types to specify interfaces directly extended by the interface. The<br>     * order of the objects in the array corresponds to the order of the<br>     * interface types used in the ‘extends’ clause of the declaration of this<br>     * {@code Class} object.<br>     *<br>     * <p> If this {@code Class} object represents a class or interface whose<br>     * declaration does not explicitly indicate any annotated superinterfaces,<br>     * the return value is an array of length 0.<br>     *<br>     * <p> If this {@code Class} object represents either the {@code Object}<br>     * class, an array type, a primitive type, or void, the return value is an<br>     * array of length 0.<br>     *<br>     * @return an array representing the superinterfaces<br>     * @since 1.8<br>     */<br>    public AnnotatedType[] getAnnotatedInterfaces() {<br>         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);<br>    }<br>}</p><p>     *<br>     * <p> If this {@code Class} object represents a class or interface whose<br>     * declaration does not explicitly indicate any annotated superinterfaces,<br>     * the return value is an array of length 0.<br>     *<br>     * <p> If this {@code Class} object represents either the {@code Object}<br>     * class, an array type, a primitive type, or void, the return value is an<br>     * array of length 0.<br>     *<br>     * @return an array representing the superinterfaces<br>     * @since 1.8<br>     */<br>    public AnnotatedType[] getAnnotatedInterfaces() {<br>         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);<br>    }<br>}</p><pre><code></code></pre>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>享元模式</title>
    <link href="/2021/11/16/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/11/16/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式</p><p>    意义：减少创建对象</p><p>    缺点：提高系统复杂度</p><p>    实现：提供一个工厂类中用map保存创建的对象</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外观模式</title>
    <link href="/2021/11/16/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/11/16/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式</p><p>    属于结构模式</p><p>    意义：提供可以需要访问的接口，内部实现对用户透明</p><p>    缺点：不符合开闭原则</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰器模式</title>
    <link href="/2021/11/15/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/11/15/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>装饰器模式</p><p>    属于结构型模式</p><p>    意义：对对象扩展功能，不改变结构</p><p>    缺点：装饰类需要抽象类实现接口，子类继承装饰类</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合模式</title>
    <link href="/2021/11/15/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/11/15/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式</p><p>    属于结构型模式</p><p>    意义：组装成树型模式</p><p>    缺点：破坏依赖倒置，传入的实现类</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过滤器模式</title>
    <link href="/2021/11/15/%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/11/15/%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h1><p>过滤器模式</p><p>    属于结构型模式</p><p>    意义：通过链式来进行过滤，通过逻辑运算来组合标准</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桥接模式</title>
    <link href="/2021/11/15/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/11/15/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式</p><p>    属于结构型模式</p><p>    意义：将抽象于实现分离开，实现解耦</p><p>    </p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桥接模式</title>
    <link href="/2021/11/15/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/11/15/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器模式</p><p>    属于结构型模式</p><p>    意义 ：使原来接口不匹配的产品相互使用，比如需要使用c口耳机转接器，使得3.5耳机可以在IPhone使用</p><p>    缺点：破坏系统接口性</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2021/11/15/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/11/15/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式</p><p>     属于创建型</p><p>     意义：利用现在的对象生成一个一模一样的对象</p><p>     缺点：实现Cloneable接口</p><p>    </p><p>    </p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES</title>
    <link href="/2021/11/15/ES/"/>
    <url>/2021/11/15/ES/</url>
    
    <content type="html"><![CDATA[<h1 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h1><ol><li>设置过期时间<ol><li>GET/_search?timeout=1s</li></ol></li><li>参数<ol><li>GET/_search?q=name:xxx</li><li>分页<ol><li>GET/_search?from=开始&amp;size=大小&amp;sort=xxx:asc生序</li></ol></li></ol></li></ol><p>    deep paging   </p><p>        分片5个，排序，全取，合并，排序，重取</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ防止消息重复</title>
    <link href="/2021/11/12/RocketMQ%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D/"/>
    <url>/2021/11/12/RocketMQ%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ防止消息重复"><a href="#RocketMQ防止消息重复" class="headerlink" title="RocketMQ防止消息重复"></a>RocketMQ防止消息重复</h1><p>重复产生的场景</p><p><img src="https://gitee.com/noahBlog/img-bed/raw/master/202111121752832.png"></p><p>    1.网络问题，Producer没有收到Broker的响应 phase1，又生产了一个</p><p>    2.网络问题，Brocker没有收到Cusmer的响应 phase2，又分配了一个</p><p>    解决方案:</p><p>        1.幂等，使用version做版本号控制，唯一索引，使用redis校验位唯一性</p><p>    </p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建造者模式</title>
    <link href="/2021/11/12/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/11/12/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式</p><p>     属于创建型</p><p>     通过组装多个对象生成需要使用的对象</p><p>     意义：肯德基套餐可以有多种组装方式，汉堡+鸡翅，汉堡+鸡块等，这些基础的对 象都是存在的，最终只要组装成的对象不同</p><p>     缺点：需要很多对象</p><p>    </p><p>    </p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ防消息丢失机制</title>
    <link href="/2021/11/12/RocketMQ%E9%98%B2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/11/12/RocketMQ%E9%98%B2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ防消息丢失机制"><a href="#RocketMQ防消息丢失机制" class="headerlink" title="RocketMQ防消息丢失机制"></a>RocketMQ防消息丢失机制</h1><p><img src="https://gitee.com/noahBlog/img-bed/raw/master/202111121749520.png"><br>丢失产生的场景</p><p>    1.生产阶段（phase1）</p><p>        Producer发送信息到Broker，添加事务，try-catch拦截异常，做事务回滚</p><p>        <img src="https://gitee.com/noahBlog/img-bed/raw/master/202111121750460.png"></p><p>        但是这里也可能出现新的问题，Producer发送的消息到了Broker,发生了错误，Broker返回错误信息之前，  挂掉了</p><p>        <img src="https://gitee.com/noahBlog/img-bed/raw/master/202111121751993.png"></p><p>        解决方案：使用事务监听器，先发送half消息，Broker写入消息，返回确认消息到Producer，Producer处理消息后，发送commit or rollback状态，即使Broker挂掉了，也会有回调来检查状态</p><p>    <img src="https://gitee.com/noahBlog/img-bed/raw/master/202111121751661.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//事务监听器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TransactionListener</span> </span>&#123;<br>    <span class="hljs-comment">//执行事务</span><br>    <span class="hljs-function">LocalTransactionState <span class="hljs-title">executeLocalTransaction</span><span class="hljs-params">(Message var1, Object var2)</span></span>;<br><br>    <span class="hljs-comment">//回调事务</span><br>    <span class="hljs-function">LocalTransactionState <span class="hljs-title">checkLocalTransaction</span><span class="hljs-params">(MessageExt var1)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">//1.创建消息生产者producer，并制定生产者组名</span><br>TransactionMQProducer producer = new TransactionMQProducer(<span class="hljs-string">&quot;xxx”);</span><br><br><span class="hljs-comment">//2. 设置NameServer的地址</span><br>producer.setNamesrvAddr(<span class="hljs-string">&quot;地址”);</span><br><br><span class="hljs-comment">//添加事务监听器</span><br>producer.setTransactionListener(new TransactionListener() &#123;&#125;);<br></code></pre></td></tr></table></figure><p>    2.存储消息</p><p>        直接写入缓存，如果Broker挂了，缓存丢失</p><p>        需要在消息刷盘后再返回响应给Producer</p><p>        解决方案：1.修改Broker的配置文件，将flushDiskType改为SYNC_FLUSH，保证同步刷盘</p><p>                        2.同步复制</p><p>    3.消费信息</p><p>        处理完业务再手动提交offset    </p><p>        注册一个消息监听器</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">MessageListenerConcurrently</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">MessageListener</span> &#123;<br>    ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; var1, ConsumeConcurrentlyContext var2);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 实例化消费者，指定组名</span><br>DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(<span class="hljs-string">&quot;xxx”);</span><br><br><span class="hljs-comment">// 设置NameServer的地址</span><br>consumer.setNamesrvAddr(“xxx”);<br><br><span class="hljs-comment">//注册消息监听器处理消息</span><br>consumer.registerMessageListener(new MessageListenerConcurrently() &#123;<br>   @Override<br>    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)&#123;                                                          <br>        <span class="hljs-comment">//对消息进行处理</span><br>        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ顺序问题</title>
    <link href="/2021/11/12/RocketMQ%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2021/11/12/RocketMQ%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ顺序问题"><a href="#RocketMQ顺序问题" class="headerlink" title="RocketMQ顺序问题"></a>RocketMQ顺序问题</h1><p>顺序产生的场景</p><p>    <img src="https://gitee.com/noahBlog/img-bed/raw/master/202111121753735.png"></p><p>1.每个消费者在Broker中拿到消费信息，但是无法保证Consumer中执行的顺序</p><p>2.单个消费者中多线程执行，没有办法保证顺序</p><p>    总的来说就是多个运行没有办法保证顺序</p><p>解决方案</p><p>    1.每一个消费者对应一个Broker中的队列</p><p>    2.Consumer拿到消息后，先排序再进行操作</p><p>    </p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream</title>
    <link href="/2021/10/13/Stream/"/>
    <url>/2021/10/13/Stream/</url>
    
    <content type="html"><![CDATA[<h2 id="steam流"><a href="#steam流" class="headerlink" title="steam流"></a>steam流</h2><p>一种可以处理数据的处理方法，类似于sql的筛选语句，结合lambda表达式，可以让代码更加的简洁</p><h2 id="并行流和串行流"><a href="#并行流和串行流" class="headerlink" title="并行流和串行流"></a>并行流和串行流</h2><h5 id="串行流："><a href="#串行流：" class="headerlink" title="串行流："></a>串行流：</h5><h5 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/2021/10/13/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/10/13/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Lambda的结构"><a href="#Lambda的结构" class="headerlink" title="Lambda的结构"></a>Lambda的结构</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(参数类型 参数名)</span> -&gt;</span> &#123;<br>    方法体;<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lambda的表达式"><a href="#lambda的表达式" class="headerlink" title="lambda的表达式"></a>lambda的表达式</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">对于单个变量可以有()，也可以没有<br><span class="hljs-number">1.</span><span class="hljs-function"><span class="hljs-params">(var1)</span>-&gt;</span>expression<br><span class="hljs-number">2.var</span>1-&gt;expression<br>对于多个变量需要有()<br><span class="hljs-number">3.</span><span class="hljs-function"><span class="hljs-params">(var1,var2)</span>-&gt;</span>expression<br></code></pre></td></tr></table></figure><h2 id="lambda应用"><a href="#lambda应用" class="headerlink" title="lambda应用"></a>lambda应用</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1.</span>简单应用<br><span class="hljs-function"><span class="hljs-params">(x,y)</span>-&gt;</span>x+y<br><span class="hljs-number">2.</span>实现排序<br>Comparator&lt;<span class="hljs-built_in">String</span>&gt; compare=（<span class="hljs-built_in">String</span> v1，<span class="hljs-built_in">String</span> v2)-&gt;-&gt;v1.getId().compareTo(v2.getId());<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT无法转换set&lt;&gt;集合</title>
    <link href="/2021/10/13/2/"/>
    <url>/2021/10/13/2/</url>
    
    <content type="html"><![CDATA[<h1 id="JWT无法转换set-lt-gt-集合"><a href="#JWT无法转换set-lt-gt-集合" class="headerlink" title="JWT无法转换set&lt;&gt;集合"></a>JWT无法转换set&lt;&gt;集合</h1><p>工程开发中，DTO类中存储了set集合，包装成token，经过jwt解析报List无法转换成set的错误</p><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ClassCastException</span>: java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span> cannot be cast to java<span class="hljs-selector-class">.util</span>.Set<br></code></pre></td></tr></table></figure><p>经过debug调试，找到jwt构成代码中</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe">UntypedObjectDeserializer&#123;<br>...<br><span class="hljs-comment">//495行</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-type"></span><br>                t = p.nextToken();<br>                <span class="hljs-keyword">if</span> (t == JsonToken.END_ARRAY) &#123;<br>                    <span class="hljs-keyword">if</span> (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) &#123;<br>                        <span class="hljs-keyword">return</span> UntypedObjectDeserializer.NO_OBJECTS;<br>                    &#125;<br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>原因在数组传输中转换成Json,反序列化构建成对象的时候，List和Set传输的json的格式是一样的，所以jwt无法判断到底是什么类型，所以他直接返回了一个ArryList</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>所以最终的解决方案，是传输过去一个Set过去，用List来获取反序列化的对象，再转换成Set做存储</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jwt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis pg数据库无法映射到实体类</title>
    <link href="/2021/10/13/1/"/>
    <url>/2021/10/13/1/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-pg数据库数组无法映射到实体类"><a href="#Mybatis-pg数据库数组无法映射到实体类" class="headerlink" title="Mybatis pg数据库数组无法映射到实体类"></a>Mybatis pg数据库数组无法映射到实体类</h1><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery">java<span class="hljs-built_in">.lang</span>.IllegalArgumentException: Result Maps<span class="hljs-built_in"> collection</span> does<span class="hljs-built_in"> not</span> contain <span class="hljs-keyword">value</span> <span class="hljs-keyword">for</span><br><br><br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这里给到的解决方案是设置一个拦截器来处理数据的转换</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerArrayTypeHandle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseTypeHandler&lt;Integer</span>[]<span class="hljs-title">&gt;</span> </span>&#123;<br>...<br><span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span>[] getIntegers(<span class="hljs-type">Array</span> array) <span class="hljs-keyword">throws</span> <span class="hljs-type">SQLException</span> &#123;<br>        <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">Object</span>[] arr = (<span class="hljs-type">Object</span>[]) array.getArray();<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Arrays</span>.stream(arr).filter(k-&gt; k!= <span class="hljs-literal">null</span>)<br>        .map(k-&gt;<span class="hljs-type">Integer</span>.valueOf(k.toString()))<br>        .toArray(<span class="hljs-type">Integer</span>[]::<span class="hljs-keyword">new</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;resultMap <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;类型的名称&quot;</span> type=<span class="hljs-string">&quot;指定的类&quot;</span>&gt;<br>...<br>    &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">&quot;数据库中对应的名&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;实体类中对应的名&quot;</span> typeHandler=<span class="hljs-string">&quot;拦截器的位置&quot;</span>&gt;&lt;/<span class="hljs-literal">result</span>&gt;<br>&lt;/resultMap&gt;<br></code></pre></td></tr></table></figure><p>这样处理就可以完成数据的转换处理</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DIP依赖倒置</title>
    <link href="/2021/10/13/DIP%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE/"/>
    <url>/2021/10/13/DIP%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="DIP依赖倒置"><a href="#DIP依赖倒置" class="headerlink" title="DIP依赖倒置"></a>DIP依赖倒置</h1><p>模块之间应该依赖于抽象，而非具体实现</p><p>面向接口编程</p><p>    生产主板的工厂和生产显卡的工程，共同遵循标准接口，来实现</p><p>非依赖于抽象</p><p><img src="https://gitee.com/noahBlog/img-bed/raw/master/202111100758341.png"></p><p>抽象出接口</p><p><img src="https://gitee.com/noahBlog/img-bed/raw/master/202111100758358.png"></p><p>实现接口<br><img src="https://gitee.com/noahBlog/img-bed/raw/master/202111100758617.png"></p><p>依赖于抽象</p><p><img src="https://gitee.com/noahBlog/img-bed/raw/master/202111100759241.png"></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EasyExcel</title>
    <link href="/2021/10/13/EasyExcel/"/>
    <url>/2021/10/13/EasyExcel/</url>
    
    <content type="html"><![CDATA[<h1 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h1><p>使用的类图<br><img src="https://gitee.com/noahBlog/img-bed/raw/master/202111100800666.png"><br>流程<br>     EasyExcelFactory工厂创建要使用的类<br>    ExcelWriter 创建ExcelWriter类，write方法中调用ExcelWriter的addContent方法<br>    ExcelWriter addContent方法<br>        1.创建ExcelWriteAddExecutor传入上下文参数并调用add的方法<br>        2.调用addOneRowOfDataToExcel方法，获取上下文中的row和其他信息<br>        3.调用addJavaObjectToExcel方法，将内容写入到Excel文件<br>扩展成多线程写入<br>    要解决的问题<br>        1.从指定行开始写<br>        2.解决head的重复写问题</p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EasyExcel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ISP接口隔离</title>
    <link href="/2021/10/13/ISP%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB/"/>
    <url>/2021/10/13/ISP%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="ISP接口隔离"><a href="#ISP接口隔离" class="headerlink" title="ISP接口隔离"></a>ISP接口隔离</h1><p>一个接口的职责尽量单一，降低耦合度</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LSP原则</title>
    <link href="/2021/10/13/LSP%E5%8E%9F%E5%88%99/"/>
    <url>/2021/10/13/LSP%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="LSP原则"><a href="#LSP原则" class="headerlink" title="LSP原则"></a>LSP原则</h1><p>父类应该在不改变程序的正确性的前提下被子类替换</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OCP原则</title>
    <link href="/2021/10/13/OCP%E5%8E%9F%E5%88%99/"/>
    <url>/2021/10/13/OCP%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="OCP原则"><a href="#OCP原则" class="headerlink" title="OCP原则"></a>OCP原则</h1><p>对扩展开放，对修改关闭</p><p>通过继承接口的方式来实现</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRP原则</title>
    <link href="/2021/10/13/SRP%E5%8E%9F%E5%88%99/"/>
    <url>/2021/10/13/SRP%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="SRP原则"><a href="#SRP原则" class="headerlink" title="SRP原则"></a>SRP原则</h1><p>单一职责</p><p>    指责越单一，被修改的可能性越低，内聚性越高</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat容器</title>
    <link href="/2021/10/13/Tomcat%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/10/13/Tomcat%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Tomcat容器"><a href="#Tomcat容器" class="headerlink" title="Tomcat容器"></a>Tomcat容器</h1><p>连接器connector</p><p>    1.创建一个服务器套接字，等待传入的HTTP请求</p><p>    2.实现了Runable接口</p><p>        run():</p><p>            1.等待HTTP请求</p><p>            2.创建Processor实例</p><p>            3.调用process方法</p><p>servlet容器</p><p>    四种容器</p><p>        1.Engine 整个Catalina servlet引擎</p><p>        2.Host 包含一个或多个Context容器的虚拟主机</p><p>        3.Context 独立的Web应用，包含多个Wrapper</p><p>        4.Wrapper 一个独立的Servlet</p><p>            负责管理基础servlet的生命周期</p><p>    管道任务</p><p>       <img src="https://gitee.com/noahBlog/img-bed/raw/master/202111100802864.png"></p><p>        管道中可以包含任意的阀</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2021/10/13/docker/"/>
    <url>/2021/10/13/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><ol><li>运行容器<ol><li>docker run <ol><li>-t 指定一个终端</li><li>-i 使用输入</li><li>-p 运行映射的端口</li><li>-P 随机映射到主机的端口</li><li>-d 后台运行<ol><li>想要后台运行后进入<ol><li>docker attach</li><li>docker exec<ol><li>docker -it xxx /bin/bash</li></ol></li></ol></li></ol></li><li>—name 容器的名称</li><li>-v 挂在数据卷</li></ol></li></ol></li><li>容器导出<ol><li>docker export<ol><li>docker export xxx &gt;  xx.tar</li></ol></li></ol></li><li>查看容器的状态<ol><li>映射的端口<ol><li>docker port</li></ol></li><li>查看日志<ol><li>docker logs<ol><li>-f 标准输出</li></ol></li></ol></li><li>查看容器信息<ol><li>docker ps</li></ol></li></ol></li><li>镜像操作<ol><li>查看镜像<ol><li>docker images</li></ol></li><li>查找镜像<ol><li>docker search</li></ol></li><li>获取镜像<ol><li>docker pull</li></ol></li><li>删除镜像<ol><li>docker rmi</li></ol></li><li>更新镜像<ol><li>创建容器 run</li><li>apt-get update</li><li>docker commit</li></ol></li><li>构建镜像<ol><li>docker build<ol><li>-t 目标镜像名</li><li>. dockerfile位置</li><li>docker build -t xxx ./</li></ol></li><li>添加标签<ol><li>docker tag</li></ol></li></ol></li><li>推送镜像<ol><li>docker tag xxx</li><li>docker push </li></ol></li></ol></li><li>网络<ol><li>docker network create <ol><li> bridge 隔离各个容器，让每个容器的端口都是隔离的</li><li>overlay 虚拟网络</li></ol></li></ol></li><li>dockerfile<ol><li>from 从xxx地方复制需要的组建</li><li>run 拼接shell命令 docker build的时候执行</li><li>copy 存储位置，目标位置</li><li>add 同copy，会解压</li><li>cmd 在docker run的时候执行</li><li>env 环境变量</li><li>arg 只在build的时候生效</li><li>volume 挂在数据卷</li><li>label 标签</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql调优</title>
    <link href="/2021/10/13/mysql%E8%B0%83%E4%BC%98/"/>
    <url>/2021/10/13/mysql%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql调优"><a href="#mysql调优" class="headerlink" title="mysql调优"></a>mysql调优</h1><p>mysql调优</p><p>    索引的结构</p><p>        1.BREE索引</p><p>        2.HASH索引</p><p>        3.R-TREE索引（空间索引）</p><p>        4.FULL-text索引（全文索引）</p><p>查询频率</p><p>    show global status like  ‘’</p><p>定位低效sql</p><p>    慢查询日志，当sql语句超过某个设定多个时间后保存在日志里</p><p>    show processlist 查看实时的查询</p><p>explain分析指令</p><p>    explain 语句</p><p>    id:查询的顺序</p><p>    select_type:simple简单表，primary主查询，union第二个或后面的查询语句，subquey第一个select</p><p>    possible_keys:可能用到的索引</p><p>    rows:扫描的行数</p><p>最左前缀法则</p><p>    从索引左向右可以递增不能跳跃，跟顺序没有关系</p><p>索引失效情况</p><p>    1.范围查询，后的索引失效</p><p>    2.索引列运算操作，索引失效，例如substring截取字符串</p><p>    3.字符串不加单引号</p><p>    4.or并非全都有索引</p><p>    5.%开头的通配不走索引，除非select的全部都是覆盖索索引的内容</p><p>    6.not int不走索引，in走索引</p><p>索引调优</p><p>    1.尽量使用覆盖索引，避免slect* 使用索引包含的列</p><p>        1.extra显示的含义</p><p>            using index，使用覆盖索引</p><p>            using where, 查找使用索引的情况下，还需要回表查询需要的数据</p><p>            using index condition, 查找使用了索引，但是数据不够回表查询</p><p>            using index</p><p>    2.全表更快，不使用索引</p><p>    3.尽量使用复合索引，少使用单列索引</p><p>        复合索引（a,b,c)</p><p>            索引存在情况</p><p>                a,ab,abc</p><p>        单列索引</p><p>            索引存在情况</p><p>                a,b,c</p><p>大批量数据插入</p><p>    1.按照主键顺序插入</p><p>    2.关闭唯一性校验</p><p>    3.手动提交事务</p><p>oderby优化</p><p>    两种排序，filesort.using index</p><p>    尽量减少额外排序，通过索引覆盖索引，order by顺序和索引顺序一致</p><p>子查询优化</p><p>    尽量减少子查询，使用多表链接代替</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例设计模式</title>
    <link href="/2021/10/13/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/13/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>单例设计模式</p><p>    单一的类，负责创建自己的对象，确保只有单个对象被创建，并且提供对外的全局访问点</p><p>    意义：</p><p>        避免类的频繁创建销毁，优化资源共享，减少内存的开销</p><p>    缺点：</p><p>        违背开闭原则，违背单一职责，并发模式公用一个单例</p><p>    懒汉式单例：</p><p>        </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span> </span>&#123;<br>    <span class="hljs-comment">//volatile保证多线程共享一个实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazySingleton INSTANCE;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (LazySingleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(INSTANCE==<span class="hljs-keyword">null</span>)&#123;<br>                    INSTANCE=<span class="hljs-keyword">new</span> LazySingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>    饿汉式单例：</p><p>    </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HungrySingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HungrySingleton INSTANCE=<span class="hljs-keyword">new</span> HungrySingleton();<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">HungrySingleton</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>        </p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>含两个奇数和N个偶数的数据中寻找两个奇数</title>
    <link href="/2021/10/13/%E5%90%AB%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%A5%87%E6%95%B0%E5%92%8CN%E4%B8%AA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%A5%87%E6%95%B0/"/>
    <url>/2021/10/13/%E5%90%AB%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%A5%87%E6%95%B0%E5%92%8CN%E4%B8%AA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%A5%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="含有两个奇数和N个偶数的数组中寻找两个奇数"><a href="#含有两个奇数和N个偶数的数组中寻找两个奇数" class="headerlink" title="含有两个奇数和N个偶数的数组中寻找两个奇数"></a>含有两个奇数和N个偶数的数组中寻找两个奇数</h1><p>含有两个奇数和N个偶数的数组中寻找两个奇数</p><p>找局部最小的数</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2021/10/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/10/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多线程</p><p>CAS: compare and swap,compare and exchange 比较和交换，没有锁的情况下保持对变量的递增、<img src="image/b75761ef510d99b5abcfca6af5e4668e.png" alt="b75761ef510d99b5abcfca6af5e4668e.png"></p><p>底层cmpxchg在写的时候可能会被修改</p><p>底层使用lock直接加锁，但是是最小的锁保证了原子性</p><p>lock cmpxchg</p><p>普通对象</p><p><img src="image/d544a479f9fe707b20457b00e18e27a6.png" alt="d544a479f9fe707b20457b00e18e27a6.png"></p><p>头内有锁</p><p>指针指向属于那个类</p><p>实力数据成员变量</p><p>对齐如果成员变量不能8整除就补全</p><p>头8字节</p><p>类型指针4个字节</p><p>一共8个字节</p><p><img src="image/427a2adf356ee60ecfa46397250c173d.png" alt="427a2adf356ee60ecfa46397250c173d.png"></p><p>最后补4个字节，被8整除</p><p><img src="image/3e1df0c2403f0e7521c5f41351a7d382.png" alt="3e1df0c2403f0e7521c5f41351a7d382.png"></p><p>数组类型</p><p>synchronized(）加锁</p><p>加锁后在markword里面加锁</p><p>无锁 刚new出对象的时候</p><p>偏向锁</p><p>轻量级锁 自选锁，无锁，自旋锁（cas）</p><p>重量级锁</p><p>加锁有一个升级过程</p><p><img src="image/653743c9f7c5a33daf48c88b84c0fc46.png" alt="653743c9f7c5a33daf48c88b84c0fc46.png"></p><p>31 identityhashcode没有调用的时候</p><p><img src="image/f554ccfdd0a3129884d642c6df98c0cb.png" alt="f554ccfdd0a3129884d642c6df98c0cb.png"></p><p>偏向锁，门上放一个标签，指明是谁的锁，偏向第一个获得到线程</p><p>当发生线程竞争的时候自动升级成重量级锁</p><p>{</p><p>    撤销偏向锁</p><p>    生成LR对象，看谁能先把LR贴到轻量锁（自旋）</p><p>    轻量级锁，自旋锁</p><p>}</p><p>超过10次自旋，或者Adapative self spining升级重量级锁</p><p>向内核申请，排斥量的指针，用户态-&gt;内核态</p><p>锁消除</p><p>锁加粗</p><p>synchonized实现过程</p><p>1.Java代码：synchronized</p><p>    1.monitorenter moniterexit监视进入和退出监视</p><p>    2.自动升级</p><p>    3.lock cmpxchg</p><p>volitile 保证线程的可见性</p><p>     </p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂方法模式</title>
    <link href="/2021/10/13/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/13/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式</p><p>    属于创建型模式</p><p>    提供一个工厂方法，根据参数不同选择不同的子类实现</p><p>    意义：</p><p>        解决接口选择不同实例的问题</p><p>        调用者不用关心具体的实现，只要知道名称即可</p><p>        具有扩展性</p><p>    缺点：</p><p>        增加类型要增加大量的具体实现的方法，和工厂类，增加了系统的依赖</p><p>    </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarFactory</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Car getCar(<span class="hljs-keyword">String</span> name)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;宝马&quot;</span>.equals(name))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BmCar</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;特斯拉&quot;</span>.equals(name))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">TslCar</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createCar</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BmCar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createCar</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这里是宝马&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TslCar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createCar</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这里是特斯拉&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123;<br>        CarFactory carFactory=<span class="hljs-keyword">new</span> <span class="hljs-built_in">CarFactory</span>();<br>        System.out.<span class="hljs-built_in">println</span>(carFactory.<span class="hljs-built_in">getCar</span>(<span class="hljs-string">&quot;宝马&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="/2021/10/13/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/13/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式</p><p>    属于创建型模式</p><p>    通过一个超级工厂创建其他工厂</p><p>    意义：</p><p>        整套产品设计统一工作，集成同一套</p><p>    缺点：</p><p>        难以扩展，需要修改抽象工厂，修改具体实现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2021/10/13/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2021/10/13/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库</p><p>    mysql里的日志类型：  </p><p>        log的进程，user space-&gt;kernel space，用户的缓存-&gt;系统的缓存-&gt;本地持久化</p><p>        write ahead log 预先日志，当发生一意外情况，可以直接从redo log恢复</p><p>                1.bin log</p><p>                2.undo log 逻辑日志</p><p>                3.redo log  存储日志</p><p>                4.relay log</p><p>                5.error log</p><p>                6.slow log</p><p>            日志归属服务:undo,redo归属与innodb存储引擎，其他归属于server</p><p>       <img src="https://gitee.com/noahBlog/img-bed/raw/master/202111100757625.png"></p><p>       <img src="https://gitee.com/noahBlog/img-bed/raw/master/202111100757671.png"></p><p>            bin和redo,undo产生原因:</p><p>                myisam不支持事务</p><p>            表的存储基于存储引擎，默认innodb</p><p>    ACID</p><p>        原子性: undo log回滚日志，失败的时候执行的语句进行回滚，多版本并发控制MVCC   </p><p>                    undo log: 记录的反向的逻辑，不是存储实际数据，存储在内存钟</p><p>        一致性: </p><p>        隔离性:</p><p>                    读未提交：脏读，不可重复读，幻读</p><p>                    读已提交：不可重复读，幻读               解决了脏读，读到没有commit的数据</p><p>                    可重复读：幻读                                   解决不可重复读，通过undo log实现分布式的读取，可重复读读取事务开启前最新的版本，不可重复度读取事务开启后最新的版本 </p><p>                    串行化：                                             解决了幻读，写数据的时候，一个事务commit insert后，另外一个事务读取不出来insert的数据，导致插入失败（自增id重复），解决方案：mvcc，间隙锁</p><p>                    mvvc提交事务后，等待锁</p><p>        持久性: redo log新数据备份，</p><p>本质实现加锁，版本号，日志，</p><p>锁的类型</p><p>    共享锁（读锁）</p><p>    排它锁（写锁）（独占锁）</p><p>    间隙锁：按照区间间隙来加锁</p><p>    临键锁：行锁+间隙锁</p><p>    自增锁：插入数据失败后，从插入失败的id以后自增</p><p>    库锁</p><p>myisam默认只能锁表</p><p>    共享锁，独占锁</p><p>innodb</p><p>    共享锁，排它锁，间隙锁，临键锁，自增锁</p><p>    </p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引</title>
    <link href="/2021/10/13/%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/10/13/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引</p><p>    单列索引：以某列作为索引</p><p>    唯一索引：单列索引的增强版，索引值唯一，允许为空</p><p>    复合索引：一个索引中包含多个列</p><p>索引设计原则</p><p>    查询频次较高</p><p>    使用where子句中提取</p><p>    使用唯一索引</p><p>    索引有维护代价</p><p>    使用短索引</p><p>    最左索引，多列中要从最左开始</p><p>存储过程，存储函数</p><p>    存储过程没有返回值</p><p>    存储函数存在返回值</p><p>    预编译提交效率</p><p>    分隔符</p><p>    delimiter $(分隔符已经替换为$)</p><p>    1.创建存储过程</p><p>        ctreate procedure name(参数)</p><p>        begin</p><p>        end;</p><p>    2.调用存储过程</p><p>        call procedure_name()</p><p>    3.查询存储过程</p><p>        select name from mysql.pro where db=’库名’;</p><p>        show procedure status;</p><p>    4.删除存储过程</p><p>        drop procedure 存储过程名;</p><p>    变量</p><p>        定义</p><p>            declare 变量名 type 值 default默认值</p><p>        赋值</p><p>            set 变量=值</p><p>            select count(*) into变量 from</p><p>        传参</p><p>            in输入(默认），out输出，inout输入输出</p><p>                in：</p><p>                    create procedure test(in k int)</p><p>    逻辑</p><p>        判断</p><p>            if xx then </p><p>        case结构</p><p>                case</p><p>                    when (and) then</p><p>                end case</p><p>    循环</p><p>        while满足条件执行</p><p>            while (条件) do</p><p>            end while</p><p>        repeat满足条件推出</p><p>            repeat</p><p>                unteil</p><p>            end repeat</p><p>        loop简单的循环</p><p>            c:loop</p><p>                xxx</p><p>                if (条件) then</p><p>                    leave c;</p><p>            end loop c;</p><p>触发器</p><p>    insert触发器 new表示新的数据</p><p>    update触发器 new新的数据，old旧的数据</p><p>    delete触发器 new新的数据，old旧的数据</p><p>    创建</p><p>        create trigger name</p><p>        brefore/after insert/update/delete</p><p>        on 表名</p><p>        for each row</p><p>        begin</p><p>        end</p><p>    删除</p><p>        drop trigger schema_name(默认但其概念数据库) trigger_name</p><p>    查看触发器</p><p>        show triggers</p><p>        </p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞与非阻塞</title>
    <link href="/2021/10/13/%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <url>/2021/10/13/%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h1><p>进程访问某个资源的时候，数据的处理方式</p><p>阻塞：资源处理完成后，返回结果</p><p>非阻塞：直接返回结果</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
